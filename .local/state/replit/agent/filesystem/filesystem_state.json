{"file_contents":{"README.md":{"content":"# üéØ RTPA Studio - Real-Time Poker Analysis\n\n**Logiciel d'analyse de poker en temps r√©el avec OCR et calculs CFR/Nash**\n\n## üöÄ Fonctionnalit√©s\n\n### ‚ú® Analyse Temps R√©el\n- **OCR automatique** : Capture non-intrusive des donn√©es de jeu\n- **Calculs CFR/Nash continus** : Recommandations optimales en temps r√©el\n- **Support multi-clients** : Compatible PokerStars, Winamax, et autres\n- **Latence ultra-faible** : < 50ms pour l'OCR, calculs en continu\n\n### üéÆ Types de Jeu Support√©s\n- **Cash Games** : Texas Hold'em No Limit 9-max\n- **Tournois** : Avec ajustements ICM automatiques\n- **Antes et Blinds** : Gestion compl√®te des structures\n\n### üéØ Recommandations Intelligentes\n- **Actions optimales** : Fold, Check, Call, Bet (Small/Medium/Large/All-in)\n- **Probabilit√©s de victoire** : Calculs Monte Carlo pr√©cis\n- **Niveau de risque** : √âvaluation en temps r√©el (0-100%)\n- **Reasoning** : Explications d√©taill√©es des recommandations\n\n### üìä Statistiques et Performance\n- **Suivi des performances** : Mains jou√©es/gagn√©es, taux de victoire\n- **Comparaison pro** : Benchmark avec joueurs professionnels (65% attendu)\n- **Historique complet** : Base de donn√©es en m√©moire haute performance\n- **Exports** : CSV, PDF pour analyse approfondie\n\n### ‚öôÔ∏è Interface et Param√®tres\n- **Interface moderne** : CustomTkinter √©l√©gant et responsive\n- **Multilingue** : Fran√ßais et Anglais\n- **Param√®tres avanc√©s** : Override manuel du risque, gestion GPU/CPU/RAM\n- **Th√®mes** : Mode sombre/clair\n- **Configuration YAML** : Param√®tres persistants\n\n## üèóÔ∏è Architecture Technique\n\n### ü§ñ Intelligence Artificielle Hybride\n\n#### **CFR Classique (Algorithmes Math√©matiques)**\n- **Counterfactual Regret Minimization** : Optimisation par regret minimal\n- **Tables Nash** : Stockage en m√©moire (regret_sum, strategy_sum)\n- **Convergence rapide** : √âquilibre Nash calcul√© en temps r√©el\n- **Performance** : > 50,000 actions/seconde\n\n#### **Deep CFR (R√©seaux de Neurones PyTorch)**\n- **Framework** : PyTorch 2.8.0+ avec TorchVision\n- **Architecture duale** :\n  - `advantage_net` : R√©seau neuronal des valeurs d'actions\n  - `strategy_net` : R√©seau neuronal des strat√©gies optimales\n- **Acc√©l√©ration GPU** : Support CUDA optionnel\n- **Apprentissage profond** : Reconnaissance de patterns complexes\n\n#### **Fonctionnement Hybride Intelligent**\n- **D√©marrage CFR** : Algorithmes math√©matiques pour base solide\n- **Deep CFR optionnel** : Activation automatique si PyTorch disponible\n- **Combinaison** : Meilleur des deux approches selon la situation\n- **Auto-adaptation** : Choix automatique de la m√©thode optimale\n\n#### **Apprentissage Continu 24/7**\n- **G√©n√©ration automatique** : 50 nouvelles mains toutes les 100ms\n- **Int√©gration temps r√©el** : Mise √† jour imm√©diate des tables CFR\n- **Sources multiples** :\n  - Mains historiques r√©elles (1424+ mains charg√©es)\n  - G√©n√©ration synth√©tique continue\n  - Parties jou√©es en direct\n- **Am√©lioration perp√©tuelle** : Nash s'am√©liore constamment sans interruption\n\n### üß† Algorithmes CFR/CFR+\n- **Regret Minimization** : Calculs Nash en temps r√©el\n- **Card Abstraction** : Buckets optimis√©s (64 par d√©faut)\n- **Action Abstraction** : Bet sizing intelligent\n- **Deep CFR** : Support PyTorch avec r√©seaux neuronaux\n\n### üñ•Ô∏è Capture OCR\n- **Tesseract OCR** : Reconnaissance haute pr√©cision\n- **Preprocessing avanc√©** : CLAHE, d√©bruitage, seuillage adaptatif\n- **Zones ROI** : D√©tection automatique des clients poker\n- **Cache intelligent** : Optimisation m√©moire\n\n### üíæ Base de Donn√©es\n- **In-Memory SQLite** : Performance maximale\n- **Structure optimis√©e** : Index pour recherches rapides\n- **Persistance optionnelle** : Sauvegarde s√©lective\n- **Threading-safe** : Acc√®s concurrent s√©curis√©\n\n### ‚ö° Performance et IA\n- **Multi-threading** : OCR, CFR, et r√©seaux neuronaux en parall√®le\n- **GPU Acceleration** : PyTorch CUDA pour Deep CFR\n- **Resource Management** : Gestion automatique CPU/RAM/GPU\n- **Optimisations Numba** : Calculs critiques compil√©s JIT\n- **Apprentissage continu** : G√©n√©ration de 50 mains/100ms en arri√®re-plan\n- **Cache intelligent** : Optimisation m√©moire pour r√©seaux neuronaux\n\n## üéõÔ∏è Utilisation\n\n### D√©marrage Rapide\n```bash\n# Test des composants\npython test_rtpa.py\n\n# Lancement complet\npython main.py\n```\n\n### Interface Principale\n1. **√âtat du Jeu** : Cartes h√©ros, board, pot, stack\n2. **Recommandations** : Action optimale avec probabilit√©s\n3. **Statistiques** : Performance et comparaisons\n4. **Param√®tres** : Configuration avanc√©e\n\n### Param√®tres Avanc√©s\n- **Type de table** : Cash Game / Tournoi\n- **Pourcentage de risque** : Manuel ou automatique\n- **Resources** : Allocation CPU/GPU/RAM\n- **OCR** : Zones et seuils de confiance\n\n## üîß Configuration\n\n### Fichiers de Configuration\n- `config/settings.yaml` : Param√®tres principaux\n- `logs/rtpa_studio.log` : Journaux d'activit√©\n\n### Technologies et IA\n- **Python 3.11+** : Interface et orchestration\n- **PyTorch 2.8.0+** : R√©seaux neuronaux Deep CFR\n- **NumPy/Numba** : Optimisations math√©matiques JIT\n- **pybind11** : Modules C++ haute performance\n- **Tesseract OCR** : Reconnaissance optique de caract√®res\n- **CUDA** : Acc√©l√©ration GPU pour r√©seaux neuronaux\n\n## üìã Sp√©cifications Techniques\n\n### Exigences Syst√®me\n- **OS** : Windows 10+, Linux x64\n- **RAM** : 4GB minimum, 8GB recommand√©\n- **GPU** : CUDA optionnel pour Deep CFR\n- **CPU** : Multi-core recommand√©\n\n### Performance Cibles\n- **OCR** : < 50ms par capture\n- **CFR** : ‚â• 50k actions/s\n- **Monte Carlo** : ‚â• 200k iterations/s\n- **Interface** : 60 FPS, < 100ms latence\n\n### S√©curit√© et √âthique\n- **Usage d'√©tude uniquement** : Formation et simulation\n- **Pas d'int√©gration live** : Aucune communication avec clients poker\n- **Donn√©es locales** : Aucune transmission externe\n- **Open source** : Code transparent et v√©rifiable\n\n## üèÜ Objectifs Strat√©giques\n\n### Optimisation Bankroll\n- **Minimisation des pertes** : Strat√©gies conservatrices\n- **Maximisation du stack** : Opportunit√©s EV positives\n- **Gestion du risque** : Adaptation au type de jeu\n- **ICM Tournament** : Ajustements bubble/ITM\n\n### Apprentissage Continu Automatique\n- **G√©n√©ration perp√©tuelle** : 50 nouvelles mains toutes les 100ms\n- **Int√©gration temps r√©el** : Mise √† jour imm√©diate des tables CFR\n- **Sources d'apprentissage multiples** :\n  - Mains historiques r√©elles (1424+ mains)\n  - G√©n√©ration synth√©tique intelligente\n  - Parties jou√©es en direct par l'utilisateur\n- **Am√©lioration Nash continue** : Convergence progressive 24/7\n- **R√©seaux neuronaux √©volutifs** : Deep CFR s'adapte aux nouveaux patterns\n- **Adaptation adversaires** : Reconnaissance de styles de jeu\n- **Situations complexes** : Multi-way pots, short-stack, ICM\n- **Meta-game** : √âvolution strat√©gique perp√©tuelle\n\n## üìä M√©triques de Succ√®s\n\n### KPIs Principaux\n- **Taux de victoire** : Target 65%+ (niveau pro)\n- **BB/100** : Profit par 100 mains\n- **Variance** : Stabilit√© des r√©sultats\n- **ROI Tournois** : Return on Investment\n\n### Indicateurs Techniques\n- **Latence OCR** : < 50ms\n- **Pr√©cision reconnaissance** : > 95%\n- **Uptime** : 99.9%+ stabilit√©\n- **Resource usage** : < 80% CPU/RAM\n\n---\n\n---\n\n## üîß Installation Automatique\n\n### √âtape 1 : T√©l√©chargement\n```bash\n# Cloner le repository ou t√©l√©charger l'archive\ncd rtpa-studio\n```\n\n### √âtape 2 : Installation Automatique\n```bash\n# Lancer l'installateur automatique\npython setup_installer.py\n```\n\nL'installateur va automatiquement :\n- ‚úÖ V√©rifier Python 3.8+\n- ‚úÖ Installer Tesseract OCR\n- ‚úÖ Installer toutes les d√©pendances Python  \n- ‚úÖ Configurer les r√©pertoires\n- ‚úÖ Tester l'installation\n- ‚úÖ Cr√©er les raccourcis\n\n### √âtape 3 : Lancement\n```bash\n# Interface graphique compl√®te\npython rtpa_studio.py\n# OU directement\npython main_gui.py\n```\n\n---\n\n## üõ†Ô∏è Installation Manuelle (si n√©cessaire)\n\n### Pr√©requis Syst√®me\n- **Python 3.8+** (3.9+ recommand√©)\n- **Tesseract OCR 4.0+**\n- **4 GB RAM minimum** (8 GB recommand√©)\n- **R√©solution √©cran** 1920x1080+ pour OCR optimal\n\n### Installation Tesseract OCR\n\n#### Windows\n```bash\n# T√©l√©charger depuis GitHub\nhttps://github.com/UB-Mannheim/tesseract/releases\n# Ajouter au PATH syst√®me : C:\\Program Files\\Tesseract-OCR\n```\n\n#### macOS\n```bash\nbrew install tesseract\n```\n\n#### Linux (Ubuntu/Debian)\n```bash\nsudo apt update\nsudo apt install tesseract-ocr tesseract-ocr-fra\n```\n\n### Installation D√©pendances Python\n```bash\npip install -r requirements.txt\n# OU installation compl√®te manuelle :\npip install numpy>=2.2.6 opencv-python>=4.12.0 pytesseract>=0.3.13\npip install pillow>=11.3.0 customtkinter>=5.2.2 mss>=10.1.0\npip install psutil>=7.0.0 pybind11>=2.12.0 pyyaml>=6.0.2\npip install matplotlib>=3.10.6 seaborn>=0.13.2 scipy>=1.16.1\npip install numba>=0.61.2 pygame>=2.6.1\n# IA et Deep Learning :\npip install torch>=2.8.0 torchvision>=0.23.0\n```\n\n---\n\n## üéÆ Guide d'Utilisation D√©taill√©\n\n### Premier Lancement\n1. **Lancez l'interface** : `python main_gui.py`\n2. **Ouvrez votre client poker** (PokerStars, Winamax, PMU)\n3. **Joignez une table** de poker\n4. **Acc√©dez √† l'onglet \"Configuration\"**\n5. **S√©lectionnez votre client** et lancez le calibrage\n\n### Onglets Interface\n\n#### üéØ Game State - √âtat Actuel du Jeu\n- **Cartes h√©ros** : Visualisation r√©aliste avec couleurs\n- **Cartes board** : Flop, Turn, River\n- **Informations** : Pot, stack, blinds, position\n- **Action** : Tour du joueur (action_to_hero)\n\n#### üß† Recommendations - Conseils Strat√©giques  \n- **Action optimale** : Fold, Check, Call, Bet_Small/Medium/Large\n- **Probabilit√© victoire** : Calculs Monte Carlo en temps r√©el\n- **Niveau de risque** : √âvaluation 0-100%\n- **Raisonnement** : Explications d√©taill√©es de la strat√©gie\n- **Actions alternatives** : Autres choix possibles\n\n#### üìä Statistics - Performance et Historique\n- **Taux de victoire** : Pourcentage mains gagn√©es\n- **Performance vs Pro** : Comparaison avec joueurs professionnels (65% cible)\n- **Graphiques temps r√©el** : √âvolution de la performance\n- **Historique complet** : Toutes les mains analys√©es\n\n#### ‚öôÔ∏è Configuration - Param√®tres Syst√®me\n- **Calibrage OCR** : Zones de capture pour chaque client poker\n- **S√©lection client** : PokerStars, Winamax, PMU\n- **Param√®tres CFR** : It√©rations, exploration, discount factor\n- **Th√®mes** : Dark/Light mode, couleurs d'accent, polices\n- **Langues** : Fran√ßais/Anglais\n\n#### üîß Performance - Monitoring Syst√®me\n- **Usage ressources** : CPU, RAM, GPU en temps r√©el\n- **Status PyTorch** : Installation et support CUDA\n- **Vitesse calculs** : Recommandations/seconde\n- **Gestion automatique** : Optimisation des ressources\n\n#### üíæ Database - Gestion Donn√©es\n- **Export/Import CFR** : Sauvegarde apprentissages Nash\n- **Historique complet** : Base de donn√©es mains\n- **Statistiques d√©taill√©es** : Performance par session\n- **Nettoyage** : Purge des anciennes donn√©es\n\n### Modes de Lancement\n\n#### Mode Interface Graphique\n```bash\npython main_gui.py        # Interface compl√®te\npython rtpa_studio.py     # Raccourci cr√©√© par l'installateur\n```\n\n#### Mode Console/D√©mo\n```bash\npython main_headless.py   # D√©monstration temps r√©el en console\n```\n\n#### Tests et Validation\n```bash\npython test_final.py                    # Tests complets du syst√®me\npython test_algorithms_validation.py    # Validation algorithmes CFR/Nash\npython test_performance_benchmarks.py   # Benchmarks de performance\n```\n\n---\n\n## üéØ Calibrage OCR pour Clients Poker\n\n### Calibrage Automatique\n1. **Client ouvert** avec une table active\n2. **Configuration > Calibrage OCR**\n3. **\"D√©tection Automatique\"**\n4. **Validation** des zones d√©tect√©es\n\n### Zones OCR Pr√©d√©finies\n\n#### PokerStars\n```yaml\nhero_cards: {top: 580, left: 440, width: 140, height: 50}\nboard_cards: {top: 280, left: 350, width: 320, height: 60}\npot_size: {top: 220, left: 450, width: 120, height: 30}\nhero_stack: {top: 650, left: 420, width: 100, height: 25}\n```\n\n#### Winamax\n```yaml\nhero_cards: {top: 590, left: 460, width: 130, height: 45}\nboard_cards: {top: 290, left: 370, width: 300, height: 55}\npot_size: {top: 230, left: 470, width: 110, height: 28}\nhero_stack: {top: 660, left: 440, width: 90, height: 23}\n```\n\n### Optimisation OCR\n- **R√©solution** : 1920x1080+ recommand√©\n- **Zoom client** : 100% (pas de zoom)\n- **Th√®me** : Couleurs contrast√©es\n- **Position** : Fen√™tre stable\n- **√âclairage** : √âcran uniforme\n\n---\n\n## üîß D√©pannage et Support\n\n### Probl√®mes Fr√©quents\n\n#### Tesseract Non Trouv√©\n```bash\n# V√©rification\ntesseract --version\n\n# Windows : Ajout PATH\nset PATH=%PATH%;C:\\Program Files\\Tesseract-OCR\n```\n\n#### OCR Impr√©cis\n- Recalibrez les zones dans Configuration\n- V√©rifiez r√©solution √©cran et zoom client 100%\n- Am√©liorez √©clairage et contraste\n\n#### Performance Lente\n- R√©duisez it√©rations CFR dans Configuration > Avanc√©\n- Activez GPU si disponible\n- Fermez applications gourmandes\n\n#### Plantage Interface\n```bash\n# Mode debug\npython main_gui.py --debug\n\n# Logs d√©taill√©s\ntail -f logs/rtpa_studio.log\n```\n\n### Tests Composants\n```bash\n# Test CFR\npython -c \"import src.algorithms.cfr_engine; print('CFR OK')\"\n\n# Test Tesseract\npython -c \"import pytesseract; print(pytesseract.get_tesseract_version())\"\n\n# Test capture √©cran\npython -c \"import mss; print('Capture OK')\"\n```\n\n---\n\n## üìÇ Structure Fichiers\n\n```\nrtpa-studio/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ algorithms/          # Moteur CFR et Nash\n‚îÇ   ‚îú‚îÄ‚îÄ core/               # Gestionnaire principal  \n‚îÇ   ‚îú‚îÄ‚îÄ database/           # Base de donn√©es m√©moire\n‚îÇ   ‚îú‚îÄ‚îÄ gui/                # Interface graphique\n‚îÇ   ‚îú‚îÄ‚îÄ ocr/                # Syst√®me OCR\n‚îÇ   ‚îú‚îÄ‚îÄ config/             # Configuration\n‚îÇ   ‚îî‚îÄ‚îÄ utils/              # Utilitaires\n‚îú‚îÄ‚îÄ config/                 # Fichiers configuration\n‚îú‚îÄ‚îÄ logs/                   # Logs d'activit√©\n‚îú‚îÄ‚îÄ exports/                # Donn√©es export√©es\n‚îú‚îÄ‚îÄ main_gui.py            # Interface graphique\n‚îú‚îÄ‚îÄ main_headless.py       # Mode console\n‚îú‚îÄ‚îÄ setup_installer.py     # Installateur automatique\n‚îî‚îÄ‚îÄ rtpa_studio.py         # Raccourci de lancement\n```\n\n---\n\n**‚ö†Ô∏è Usage Responsable**: Ce logiciel est con√ßu exclusivement √† des fins d'√©tude, formation et simulation post-session. L'utilisation en live ou pour contourner les r√®gles des sites de poker est strictement interdite.\n\n**üéì Objectif P√©dagogique**: RTPA Studio vise √† am√©liorer la compr√©hension de la th√©orie des jeux et des strat√©gies optimales au poker Texas Hold'em No Limit.\n\n**üìß Contact**: Pour contributions acad√©miques ou recherche en th√©orie des jeux.\n\n---\n\n## üß™ Intelligence Artificielle - D√©tails Techniques\n\n### **Architecture IA Compl√®te**\n\n#### **1. CFR Traditionnel (Base Math√©matique)**\n```python\n# Stockage en m√©moire haute performance\nregret_sum = {}          # Tables de regrets accumul√©s\nstrategy_sum = {}        # Strat√©gies cumulatives\ninfo_sets = {}          # Ensembles d'information\n```\n\n#### **2. Deep CFR (R√©seaux de Neurones)**\n```python\n# R√©seaux PyTorch pour situations complexes\nadvantage_net = None     # R√©seau des valeurs d'actions\nstrategy_net = None      # R√©seau des strat√©gies optimales\ndeep_cfr_enabled = False # Activation conditionnelle\n```\n\n#### **3. Fonctionnement Intelligent**\n- **D√©marrage** : CFR classique pour convergence rapide\n- **Complexit√©** : Activation automatique Deep CFR si n√©cessaire\n- **GPU** : Acc√©l√©ration CUDA pour r√©seaux neuronaux\n- **Hybride** : Combinaison optimale selon la situation\n\n### **G√©n√©ration Continue de Donn√©es**\n- **Fr√©quence** : 50 mains/100ms (30,000 mains/minute)\n- **Sc√©narios prioritaires** : Heads-up, tournois, stacks vari√©s\n- **Int√©gration imm√©diate** : Calcul CFR et mise √† jour Nash temps r√©el\n- **Apprentissage perp√©tuel** : Am√©lioration continue sans arr√™t\n\n### **Technologies IA Utilis√©es**\n- **PyTorch 2.8.0+** : Framework de deep learning\n- **CUDA** : Acc√©l√©ration GPU optionnelle\n- **NumPy** : Calculs matriciels optimis√©s\n- **Numba** : Compilation JIT pour performances critiques\n- **CFR/CFR+** : Algorithmes de th√©orie des jeux\n- **Monte Carlo** : Simulations probabilistes\n\n---\n\n*Derni√®re mise √† jour : Septembre 2025 - Version 1.0.0*  \n*Statut : ‚úÖ Stable et Op√©rationnel*  \n*IA : ü§ñ CFR Hybride + Deep Learning PyTorch*","size_bytes":16459},"main.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRTPA Studio - Real-Time Poker Analysis Studio\nLogiciel d'analyse de poker en temps r√©el avec OCR et calculs CFR/Nash\n\"\"\"\n\nimport sys\nimport os\nimport threading\nimport time\nfrom pathlib import Path\n\n# Configuration du projet\nPROJECT_ROOT = Path(__file__).parent\nsys.path.append(str(PROJECT_ROOT))\n\n# Auto-installation des d√©pendances au premier lancement\nprint(\"üöÄ RTPA Studio - D√©marrage\")\nprint(\"=\" * 40)\n\ntry:\n    from src.utils.auto_install import auto_install_dependencies\n    if auto_install_dependencies():\n        print(\"‚úÖ D√©pendances v√©rifi√©es/install√©es avec succ√®s!\\n\")\n    else:\n        print(\"‚ö†Ô∏è  Probl√®me avec l'installation automatique\\n\")\nexcept Exception as e:\n    print(f\"‚ö†Ô∏è  Auto-installation √©chou√©e: {e}\")\n    print(\"üìù Tentative de poursuite...\\n\")\n\n# Import des modules principaux\nfrom src.core.app_manager import RTAPStudioManager\nfrom src.gui.main_window import RTAPMainWindow\nfrom src.utils.logger import setup_logger\n\ndef main():\n    \"\"\"Point d'entr√©e principal de RTPA Studio\"\"\"\n    try:\n        # Configuration des logs\n        logger = setup_logger()\n        logger.info(\"D√©marrage de RTPA Studio...\")\n        \n        # Initialisation du gestionnaire principal\n        app_manager = RTAPStudioManager()\n        \n        # Lancement de l'interface graphique\n        main_window = RTAPMainWindow(app_manager)\n        main_window.run()\n        \n    except Exception as e:\n        print(f\"Erreur critique au d√©marrage: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()","size_bytes":1564},"main_gui.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nLancement de RTPA Studio avec interface graphique moderne\n\"\"\"\n\nimport sys\nimport os\nfrom pathlib import Path\n\nPROJECT_ROOT = Path(__file__).parent\nsys.path.append(str(PROJECT_ROOT))\n\n# Configuration pour Windows - Nom du processus dans le gestionnaire des t√¢ches\nif sys.platform == \"win32\":\n    try:\n        import ctypes\n        # D√©finir le nom de l'application pour Windows\n        ctypes.windll.kernel32.SetConsoleTitleW(\"RTPA Studio\")\n        \n        # Essayer de changer l'identifiant du processus (si possible)\n        try:\n            # Note: cela n√©cessite des privil√®ges √©lev√©s et peut ne pas fonctionner\n            app_id = \"RTAPStudio.PokerAnalysis.1.0\"\n            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(app_id)\n        except Exception:\n            pass  # Ne pas √©chouer si cela ne fonctionne pas\n            \n    except ImportError:\n        pass  # ctypes n'est pas disponible\n\ndef main():\n    \"\"\"Lance RTPA Studio avec interface graphique\"\"\"\n    \n    # Auto-installation des d√©pendances\n    print(\"üöÄ RTPA Studio - Interface Graphique\")\n    print(\"=\" * 45)\n    \n    try:\n        from src.utils.auto_install import auto_install_dependencies\n        if auto_install_dependencies():\n            print(\"‚úÖ D√©pendances v√©rifi√©es/install√©es avec succ√®s!\\n\")\n        else:\n            print(\"‚ö†Ô∏è  Probl√®me avec l'installation automatique\\n\")\n    except Exception as e:\n        print(f\"‚ö†Ô∏è  Auto-installation √©chou√©e: {e}\")\n        print(\"üìù Tentative de poursuite...\\n\")\n    \n    try:\n        from src.core.app_manager import RTAPStudioManager\n        from src.gui.rtpa_gui import RTAPGUIWindow\n        from src.utils.logger import setup_logger\n        \n        logger = setup_logger()\n        logger.info(\"D√©marrage de RTPA Studio avec interface graphique\")\n        \n        # Initialisation du gestionnaire\n        app_manager = RTAPStudioManager()\n        \n        # Lancement de l'interface\n        gui = RTAPGUIWindow(app_manager)\n        \n        # Connecter la GUI au gestionnaire pour les callbacks de statut\n        app_manager.set_gui_window(gui)\n        \n        gui.run()\n        \n    except Exception as e:\n        print(f\"Erreur critique: {e}\")\n        import traceback\n        traceback.print_exc()\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()","size_bytes":2362},"main_headless.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nVersion headless de RTPA Studio pour d√©monstration\nFonctionne sans interface graphique X11\n\"\"\"\n\nimport sys\nimport time\nimport threading\nfrom pathlib import Path\n\nPROJECT_ROOT = Path(__file__).parent\nsys.path.append(str(PROJECT_ROOT))\n\nfrom src.core.app_manager import RTAPStudioManager\nfrom src.utils.logger import setup_logger\n\ndef main():\n    \"\"\"Point d'entr√©e pour la d√©monstration headless\"\"\"\n    try:\n        logger = setup_logger()\n        logger.info(\"D√©marrage de RTPA Studio (mode headless)\")\n        \n        # Initialisation du gestionnaire\n        app_manager = RTAPStudioManager()\n        \n        # D√©marrage de l'analyse\n        app_manager.start()\n        logger.info(\"Analyse d√©marr√©e - Mode d√©monstration\")\n        \n        print(\"üéØ RTPA Studio - D√©monstration\")\n        print(\"=\" * 50)\n        print(\"Mode: Simulation (sans capture d'√©cran r√©elle)\")\n        print(\"Appuyez sur Ctrl+C pour arr√™ter\")\n        print()\n        \n        try:\n            while True:\n                # Affichage des donn√©es actuelles\n                game_state = app_manager.get_current_state()\n                recommendation = app_manager.get_recommendation()\n                stats = app_manager.get_statistics()\n                \n                # Clear screen\n                print(\"\\033[2J\\033[H\", end=\"\")\n                \n                print(\"üéØ RTPA Studio - D√©monstration Temps R√©el\")\n                print(\"=\" * 60)\n                print(f\"üìä Situation Actuelle:\")\n                print(f\"   Cartes H√©ros: {game_state.hero_cards[0]} {game_state.hero_cards[1]}\")\n                print(f\"   Board: {' '.join(game_state.board_cards)}\")\n                print(f\"   Pot: {game_state.pot_size:.2f}‚Ç¨\")\n                print(f\"   Stack: {game_state.hero_stack:.2f}‚Ç¨\")\n                print(f\"   Type: {game_state.table_type}\")\n                print()\n                \n                if recommendation:\n                    print(\"üéØ Recommandation:\")\n                    print(f\"   Action: {recommendation['action_type'].upper()}\")\n                    if recommendation['bet_size'] > 0:\n                        print(f\"   Taille: {recommendation['bet_size']:.2f}‚Ç¨\")\n                    print(f\"   Probabilit√© Victoire: {recommendation['win_probability']:.1f}%\")\n                    print(f\"   Niveau Risque: {recommendation['risk_level']:.0f}%\")\n                    print(f\"   Confiance: {recommendation['confidence']:.0f}%\")\n                    print(f\"   Raisonnement: {recommendation['reasoning']}\")\n                    print()\n                \n                print(\"üìà Statistiques:\")\n                print(f\"   Mains Jou√©es: {stats['hands_played']}\")\n                print(f\"   Mains Gagn√©es: {stats['hands_won']}\")\n                print(f\"   Taux Victoire: {stats['win_rate']:.1f}%\")\n                print(f\"   Taux Attendu: {stats['expected_win_rate']:.1f}%\")\n                print(f\"   Performance: {stats['performance_ratio']:.1f}%\")\n                print()\n                \n                print(\"‚ö° Syst√®me:\")\n                print(\"   Status: ‚úÖ Actif\")\n                print(\"   OCR: üîÑ Simulation\")\n                print(\"   CFR: üß† Calculs continus\")\n                print(\"   Base: üíæ En m√©moire\")\n                \n                time.sleep(2)  # Mise √† jour toutes les 2 secondes\n                \n        except KeyboardInterrupt:\n            print(\"\\n\\nüõë Arr√™t demand√©...\")\n            app_manager.stop()\n            print(\"‚úÖ RTPA Studio arr√™t√© proprement\")\n        \n    except Exception as e:\n        print(f\"‚ùå Erreur critique: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()","size_bytes":3694},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"customtkinter>=5.2.2\",\n    \"matplotlib>=3.10.6\",\n    \"mss>=10.1.0\",\n    \"numba>=0.61.2\",\n    \"numpy>=2.2.6\",\n    \"opencv-python>=4.12.0.88\",\n    \"pillow>=11.3.0\",\n    \"psutil>=7.0.0\",\n    \"pygame>=2.6.1\",\n    \"pytesseract>=0.3.13\",\n    \"pybind11>=2.12.0\",\n    \"pyyaml>=6.0.2\",\n    \"scipy>=1.16.1\",\n    \"seaborn>=0.13.2\",\n    \"torch>=2.8.0\",\n    \"torchvision>=0.23.0\",\n]\n\n[[tool.uv.index]]\nexplicit = true\nname = \"pytorch-cpu\"\nurl = \"https://download.pytorch.org/whl/cpu\"\n\n[tool.uv.sources]\nAA-module = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nABlooper = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nAnalysisG = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nAutoRAG = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nBERTeam = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nBxTorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nByaldi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nCALM-Pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nCOPEX-high-rate-compression-quality-metrics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nCityLearn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nCoCa-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nCoLT5-attention = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nComfyUI-EasyNodes = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nCrawl4AI = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nDALL-E = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nDI-toolkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nDatasetRising = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nDeepCache = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nDeepMatter = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nDraugr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nESRNN = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nEn-transformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nExpoSeq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nFLAML = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nFSRS-Optimizer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nGANDLF = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nGQLAlchemy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nGhostScan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nGraKeL = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nHEBO = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nIOPaint = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nISLP = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nInvokeAI = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nJAEN = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nKapoorLabs-Lightning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nLightAutoML = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nLingerGRN = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nMMEdu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nMRzeroCore = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nModeva = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nNeuralFoil = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nNiMARE = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nNinjaTools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nOpenHosta = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nOpenNMT-py = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nPOT = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nPVNet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nPaLM-rlhf-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nPepperPepper = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nPiML = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nPoutyne = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nQNCP = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nRAGatouille = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nRareGO = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nRealtimeSTT = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nRelevanceAI-Workflows-Core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nResemblyzer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nScandEval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nSimba-UW-tf-dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nSwissArmyTransformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nTPOT = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nTTS = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nTorchCRF = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nTotalSegmentator = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nUtilsRL = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nWhisperSpeech = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nXAISuite = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\na-unet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\na5dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naccelerate = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naccelerated-scan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naccern-xyme = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nachatbot = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nacids-rave = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nactorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nacvl-utils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadabelief-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadam-atan2-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadan-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadapters = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadmin-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadtoolbox = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadversarial-robustness-toolbox = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naeiou = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naeon = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nafricanwhisper = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nag-llama-api = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nagentdojo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nagilerl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai-edge-torch-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai-parrot = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai-python = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai-transform = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai2-olmo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai2-olmo-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai2-tango = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naicmder = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naider-chat = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naider-chat-x = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naif360 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naihwkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naimodelshare = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nairllm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nairtestProject = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nairunner = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naisak = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naislib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naisquared = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naistore = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naithree = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nakasha-terminal = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalibi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalibi-detect = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalignn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nall-clip = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nallennlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nallennlp-models = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nallennlp-pvt-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nallophant = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nallosaurus = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naloy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalpaca-eval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalphafold2-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalphafold3-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalphamed-federated = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalphawave = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\namazon-braket-pennylane-plugin = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\namazon-photos = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nanemoi-graphs = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nanemoi-models = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nanomalib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\napache-beam = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\napache-tvm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naperturedb = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naphrodite-engine = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naqlm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\narcAGI2024 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\narchisound = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nargbind = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\narize = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\narm-pytorch-utilities = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\narray-api-compat = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\narus = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nassert-llm-tools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nasteroid = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nasteroid-filterbanks = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nastra-llm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nastrovision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\natomate2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nattacut = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naudio-diffusion-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naudio-encoders-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naudio-separator = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naudiocraft = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naudiolm-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nauralis = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nauraloss = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nauto-gptq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nautoawq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nautoawq-kernels = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\n\"autogluon.multimodal\" = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\n\"autogluon.tabular\" = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\n\"autogluon.timeseries\" = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nautotrain-advanced = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\navdeepfake1m = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naws-fortuna = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nax-platform = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nazureml-automl-dnn-vision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nazureml-contrib-automl-dnn-forecasting = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nazureml-evaluate-mlflow = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nazureml-metrics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nazureml-train-automl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nb2bTools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbackpack-for-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbalrog-nle = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbatch-face = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbatchalign = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbatchgeneratorsv2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbatchtensor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbbrl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbenchpots = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbent = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbert-score = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbertopic = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbertviz = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbestOf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbetty-ml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbig-sleep = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbigdl-core-cpp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbigdl-core-npu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbigdl-llm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbigdl-nano = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\n\"bioimageio.core\" = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbitfount = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbitsandbytes = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbittensor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbittensor-cli = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nblackboxopt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nblanc = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nblindai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbm25-pt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nboltz = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbotorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nboxmot = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbrainchain = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbraindecode = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbrevitas = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbriton = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbrowsergym-visualwebarena = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbuzz-captions = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbyotrack = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbyzerllm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nc4v-py = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncalflops = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncame-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncamel-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncamel-tools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncannai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncaptum = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncarte-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncarvekit-colab = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncatalyst = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncausalml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncausalnex = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncausy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncbrkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncca-zoo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncdp-backend = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncellacdc = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncellfinder = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncellpose = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncellxgene-census = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nchattts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nchemprop = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nchgnet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nchitra = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncircuitsvis = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncjm-yolox-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclarinpl-embeddings = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclass-resolver = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclassifier-free-guidance-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclassiq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclassy-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclean-fid = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncleanvision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclip-anytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclip-benchmark = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclip-by-openai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclip-interrogator = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclip-retrieval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncltk = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclusterops = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncnocr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncnstd = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncoba = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncofi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncolbert-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncolpali-engine = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncompel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncomposabl-ray = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncomposabl-ray-dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncomposabl-train = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncomposabl-train-dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncomposer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncompressai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncompressed-tensors = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncompressed-tensors-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nconcrete-python = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nconfit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nconformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncontextualSpellCheck = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncontinual-inference = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncontrolnet-aux = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nconvokit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncoola = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncoqui-tts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncoqui-tts-trainer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncraft-text-detector = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncreme = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncrocodile = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncrowd-kit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncryoSPHERE = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncsle-common = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncsle-system-identification = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nctgan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncurated-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncut-cross-entropy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncvat-sdk = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncybertask = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nd3rlpy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndalle-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndalle2-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndanila-lib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndanling = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndarts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndarwin-py = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndata-gradients = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndatachain = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndataclass-array = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndataeval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndatarobot-drum = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndatarobotx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndatasets = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndatumaro = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndctorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeep-utils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepchecks = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepchem = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepctr-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepecho = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepepochs = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepforest = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeeplabcut = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepmd-kit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepmultilingualpunctuation = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepparse = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeeprobust = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepsparse = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepsparse-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepspeed = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndenoising-diffusion-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndescript-audio-codec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndescript-audiotools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndetecto = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndetoxify = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndgenerate = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndghs-imgutils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndgl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndialogy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndice-ml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndiffgram = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndiffq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndiffusers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndistilabel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndistrifuser = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndnikit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndocarray = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndoclayout-yolo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndocling-ibm-models = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndocquery = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndomino-code-assist = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndreamsim = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndropblock = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndruida = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndvclive = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ne2-tts-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ne2cnn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ne3nn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\neasyocr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nebtorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\necallisto-ng = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nedsnlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\neffdet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\neinx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\neir-dl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\neis1600 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\neland = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nema-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nembedchain = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nenformer-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nentmax = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nesm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nespaloma-charge = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nespnet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\netils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\netna = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nevadb = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nevalscope = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nevaluate = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nexllamav2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nextractable = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nface-alignment = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfacenet-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfacexlib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfair-esm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfairseq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfairseq2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfairseq2n = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfaker-file = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfarm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfast-bert = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfast-pytorch-kmeans = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfastai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfastcore = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfastestimator-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfasttreeshap = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfedml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfelupe = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfemr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfft-conv-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfickling = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfireworks-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflair = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflashrag-dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflax = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflexgen = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflgo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflopth = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflowcept = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflytekitplugins-kfpytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflytekitplugins-onnxpytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfmbench = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfocal-frequency-loss = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfoldedtensor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfractal-tasks-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfreegenius = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfreqtrade = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfschat = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfunasr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfunctorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfunlbm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfunsor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngalore-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngarak = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngarf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngateloop-transformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngeffnet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngenutility = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngfpgan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngigagan-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngin-config = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nglasflow = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngliner = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngluonts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngmft = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngoogle-cloud-aiplatform = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngpforecaster = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngpt3discord = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngpytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngrad-cam = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngraph-weather = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngraphistry = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngravitorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngretel-synthetics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngsplat = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nguardrails-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nguidance = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngymnasium = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhanlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhappytransformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhbutils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nheavyball = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhezar = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhf-deepali = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhf-doc-builder = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhigher = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhjxdl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhkkang-utils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhordelib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhpsv2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhuggingface-hub = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhummingbird-ml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhvae-backbone = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhya = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhypothesis-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nibm-metrics-plugin = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nibm-watson-machine-learning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nibm-watsonx-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nicetk = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nicevision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\niden = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nidvpackage = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\niglovikov-helper-functions = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nimagededup = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nimagen-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nimaginAIry = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nimg2vec-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nincendio = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninference = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninference-gpu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninfinity-emb = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninfo-nce-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninfoapps-mlops-sdk = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninstructlab = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninstructlab-dolomite = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninstructlab-eval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninstructlab-sdg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninstructlab-training = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninvisible-watermark = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\niobm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nipex-llm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\niree-turbine = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nirisml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nirisml-tasks-azure-openai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nirisml-tasks-torchvision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nirisml-tasks-training = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nitem-matching = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nivadomed = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\njaqpotpy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\njina = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\njudo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\njunky = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nk-diffusion = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nk1lib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nk2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkappadata = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkappamodules = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkarbonn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkats = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkbnf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkedro-datasets = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkeybert = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkeytotext = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkhoj = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkiui = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkonfuzio-sdk = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkornia = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkornia-moons = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkraken = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkwarray = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkwimage = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlabml-nn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlagent = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlaion-clap = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlale = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlama-cleaner = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlancedb = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlangcheck = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlangkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlangroid = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlangtest = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlayoutparser = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nldp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nleafmap = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nleap-ie = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nleibniz = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nleptonai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nletmedoit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlhotse = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlib310 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlibpecos = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlibrec-auto = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlibretranslate = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nliger-kernel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nliger-kernel-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightning-bolts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightning-fabric = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightning-habana = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightning-lite = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightrag = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightweight-gan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightwood = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlinear-attention-transformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlinear-operator = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlinformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlinformer-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nliom-toolkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlion-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlit-nlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlitdata = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlitelama = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlitgpt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllama-index-embeddings-adapter = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllama-index-embeddings-clip = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllama-index-embeddings-instructor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllama-index-llms-huggingface = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllama-index-postprocessor-colbert-rerank = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllm-blender = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllm-foundry = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllm-guard = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllm-rs = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllm2vec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllmcompressor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllmlingua = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllmvm-cli = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlm-eval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlmdeploy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlmms-eval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlocal-attention = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlovely-tensors = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlpips = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlycoris-lora = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmace-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmagic-pdf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmagicsoup = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmagvit2-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmaite = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmanga-ocr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmanifest-ml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmanipulation = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmarker-pdf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmatgl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmed-imagetools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmedaka = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmedcat = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmedmnist = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmegablocks = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmegatron-energon = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmemos = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmeshgpt-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmetatensor-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmflux = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmia-vgg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmiditok = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nminari = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nminicons = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nml2rt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmlagents = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmlbench-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmlcroissant = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmlpfile = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmlx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmlx-whisper = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmmaction2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmmengine = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmmengine-lite = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmmocr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmmpose = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmmsegmentation = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmodeci-mdf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmodel2vec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmodelscope = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmodelspec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmonai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmonai-weekly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmonotonic-alignment-search = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmonty = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmosaicml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmosaicml-streaming = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmoshi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmteb = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmtmtrain = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmulti-quantization = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmyhand = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnGPT-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnaeural-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnapari = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnapatrackmater = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnara-wpe = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnatten = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnbeats-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnebulae = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnemo-toolkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneptune = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneptune-client = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnerfacc = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnerfstudio = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnessai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnetcal = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneural-rag = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneuralforecast = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneuralnets = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneuralprophet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneuspell = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnevergrad = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnexfort = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnimblephysics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnirtorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnkululeko = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnlptooltest = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnnAudio = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnnodely = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnnsight = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnnunetv2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnoisereduce = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnonebot-plugin-nailongremove = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnowcasting-dataloader = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnowcasting-forecast = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnshtrainer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnuwa-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnvflare = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnvidia-modelopt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nocf-datapipes = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nocnn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nogb = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nohmeow-blurr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nolive-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nomlt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nommlx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nonediff = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nonediffx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nonnx2pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nonnx2torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopacus = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopen-clip-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopen-flamingo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopen-interpreter = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenbb-terminal-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenmim = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenparse = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenunmix = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenvino-dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenvino-tokenizers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenvino-xai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenwakeword = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopt-einsum-fx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptimum = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptimum-habana = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptimum-intel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptimum-neuron = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptimum-quanto = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptree = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptuna = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptuna-dashboard = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptuna-integration = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noracle-ads = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\norbit-ml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\notx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noutetts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noutlines = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noutlines-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npaddlenlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npai-easycv = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npandasai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npanns-inference = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npatchwork-cli = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npeft = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npegasuspy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npelutils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npenn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nperforatedai-freemium = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nperformer-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npetastorm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npfio = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npgmpy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nphenolrs = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nphobos = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npi-zero-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npinecone-text = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npiq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npix2tex = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npix2text = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npnnx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npolicyengine-us-data = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npolyfuzz = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npomegranate = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npositional-encodings = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nprefigure = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nproduct-key-memory = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nptflops = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nptwt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npulser-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npunctuators = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npy2ls = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyabsa = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\n\"pyannote.audio\" = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyawd = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyclarity = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npycox = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyfemtet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyg-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npygrinder = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyhealth = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyhf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyiqa = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npykeen = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npykeops = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npylance = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npylineaGT = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npymanopt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npymde = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npypots = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyqlib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyqtorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyro-ppl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npysentimiento = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyserini = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npysr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npythainlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npython-doctr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-fid = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-forecasting = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-ignite = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-kinematics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-lightning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-lightning-bolts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-metric-learning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-model-summary = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-msssim = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-pfn-extras = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-pretrained-bert = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-ranger = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-seed = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-tabnet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-tabular = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-toolbelt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-transformers-pvt-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-triton-rocm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-warmup = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-wavelets = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch_optimizer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch_revgrad = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorchcv = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorchltr2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyvene = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyvespa = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nqianfan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nqibo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nqiskit-machine-learning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nqtorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nquanto = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nquick-anomaly-detector = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrastervision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrastervision-pytorch-backend = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrastervision-pytorch-learner = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nray-lightning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrclip = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrealesrgan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrecbole = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrecommenders = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nredcat = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nreformer-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nregex-sampler = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nreplay-rec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrerankers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nresearch-framework = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nresemble-enhance = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nresnest = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrf-clip = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrf-groundingdino = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrfconv = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrich-logger = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nring-attention-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrltrade-test = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrotary-embedding-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrsp-ml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrust-circuit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ns2fft = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ns3prl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ns3torchconnector = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsaferx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsafetensors = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsagemaker-huggingface-inference-toolkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsagemaker-ssh-helper = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsalesforce-lavis = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsalesforce-merlion = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsamv2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nscib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nscib-metrics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nscvi-tools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsdmetrics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsecretflow = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsegment-anything-hq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsegment-anything-py = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsegmentation-models-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nself-rewarding-lm-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsemantic-kernel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsemantic-router = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsenselab = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsent2vec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsentence-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsequence-model-train = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nserotiny = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsevenn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsglang = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nshap = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsilero-api-server = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsilero-vad = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsilicondiff-npu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsimclr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsimple-lama-inpainting = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsinabs = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsixdrepnet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nskforecast = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nskorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nskrl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nskt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsktime = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsktmls = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nslangtorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsmartnoise-synth = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsmashed = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsmplx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsmqtk-descriptors = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsmqtk-detection = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsnntorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsnorkel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsnowflake-ml-python = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nso-vits-svc-fork = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsonusai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsony-custom-layers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsotopia = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspacr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspacy-curated-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspacy-experimental = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspacy-huggingface-pipelines = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspacy-llm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspacy-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspan-marker = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspandrel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspandrel-extra-arches = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsparrow-python = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspatialdata = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspeechbrain = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspeechtokenizer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspikeinterface = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspikingjelly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspotiflow = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspotpython = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspotriver = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsquirrel-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstable-baselines3 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstable-diffusion-sdkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstable-ts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstanford-stk = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstanfordnlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstanza = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstartorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstreamtasks = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstruct-eqtable = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstylegan2-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsupar = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsuper-gradients = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsuper-image = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsuperlinked = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsupervisely = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsurya-ocr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsvdiff-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nswarm-models = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nswarmauri = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nswarms-memory = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nswebench = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsyft = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsympytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsyne-tune = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsynthcity = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nt5 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntab-transformer-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntabpfn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntaming-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntaming-transformers-rom1504 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntaskwiz = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntbparse = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntecton = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntensor-parallel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntensorcircuit-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntensordict = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntensordict-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntensorizer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntensorrt-llm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntexify = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntext2text = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntextattack = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntfkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nthepipe-api = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nthinc = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nthingsvision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nthirdai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nthop = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntianshou = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntidy3d = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntimesfm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntimm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntipo-kgen = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntmnt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntoad = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntomesd = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntop2vec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-audiomentations = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-dct = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-delaunay = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-directml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-ema = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-encoding = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-fidelity = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-geometric = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-geopooling = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-harmonics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-kmeans = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-lr-finder = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-max-mem = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-npu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-optimi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-optimizer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-ort = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-pitch-shift = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-ppr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-pruning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-snippets = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-stoi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-struct = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-tensorrt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchani = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchattacks = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchaudio = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchbiggraph = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchcam = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchcde = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchcfm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchcrepe = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchdata = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchdatasets-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchdiffeq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchdyn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchestra = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorcheval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorcheval-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchextractor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchfcpe = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchfun = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchfunc-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchgeo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchgeometry = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchio = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchjpeg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchlayers-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchmeta = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchmetrics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchmocks = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchpack = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchpippy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchpq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchprofile = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchquantlib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchrec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchrec-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchrec-nightly-cpu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchrl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchrl-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchscale = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchsde = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchseg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchserve = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchserve-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchsnapshot-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchsr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchstain = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchsummaryX = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchtext = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchtnt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchtnt-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchtyping = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchutil = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchvinecopulib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchvision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchviz = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchx-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchxrayvision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntotalspineseg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntracebloc-package-dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntrainer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransformer-engine = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransformer-lens = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransformer-smaller-training-vocab = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransformers-domain-adaptation = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransfusion-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransparent-background = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntreescope = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntrolo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntsai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntslearn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nttspod = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntxtai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntyro = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nu8darts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nuhg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nuitestrunner-syberos = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nultimate-rvc = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nultralytics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nultralytics-thop = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunav = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunbabel-comet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunderthesea = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunfoldNd = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunimernet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunitorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunitxt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunsloth = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunsloth-zoo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunstructured = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunstructured-inference = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nutilsd = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nv-diffusion-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvIQA = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvectice = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvector-quantize-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvectorhub-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nversatile-audio-upscaler = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvertexai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvesin = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvgg-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvideo-representations-extractor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nviser = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvision-datasets = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvisionmetrics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvisu3d = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvit-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nviturka-nn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvllm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvllm-flash-attn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvocos = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvollseg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvtorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwavmark = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwdoc = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwhisper-live = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwhisper-timestamped = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwhisperx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwilds = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwordllama = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nworker-automate-hub = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwxbtool = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nx-clip = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nx-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nxaitk_saliency = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nxformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nxgrammar = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nxinference = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nxtts-api-server = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nyolo-poser = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nyolov5 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nyolov7-package = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nyta-general-utils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nzensvi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nzetascale = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nzuko = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\n","size_bytes":90897},"replit.md":{"content":"# RTPA Studio - Real-Time Poker Assistant\n\n## Overview\nRTPA Studio is an advanced poker analysis system designed for education and training. It combines traditional CFR algorithms with Deep CFR neural networks to provide optimal strategic recommendations in real-time. The system leverages Nash equilibrium to offer mathematically sound game advice, aiming to improve user poker skills through continuous learning and sophisticated analysis.\n\n## User Preferences\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Core Architecture\nThe application features a modular, event-driven architecture. An `App Manager` orchestrates system components, which are organized into distinct packages (core, algorithms, ocr, database, gui, utils). It employs a multi-threaded model for screen capture, CFR calculations, and GUI updates, and uses a YAML-based configuration system for runtime parameter adjustment.\n\n### Data Flow & Processing\nA real-time pipeline handles OCR capture, game state extraction, CFR engine processing, recommendations generation, and GUI display. It utilizes an in-memory database for high performance, with SQLite as a fallback for persistence. Smart caching optimizes OCR results and CFR calculations, while centralized state management tracks game history.\n\n### Algorithm Implementation\nThe core algorithm is an advanced Counterfactual Regret Minimization (CFR) engine with CFR+ optimizations. It includes sophisticated card abstraction for computational efficiency, dynamic bet sizing, and contextual action spaces. High-speed Monte Carlo simulations are used for win rate estimations.\n\n### UI Architecture\nThe UI is built with `CustomTkinter` for a modern, themed look with dark/light mode support. It features real-time updates via a dedicated thread for responsiveness, complete French/English localization, and an adaptive layout for various screen resolutions. The visual display includes realistic poker cards with accurate symbols.\n\n### Performance Optimization\nThe system includes robust resource management, monitoring CPU, RAM, and GPU usage with automatic throttling. It leverages concurrent processing for OCR, CFR, and UI updates, and optimizes memory with efficient data structures. A headless mode is available for non-GUI environments. The system dynamically switches between CPU and GPU based on workload, utilizing CUDA for GPU acceleration.\n\n### Automatic Dependency Management\nRTPA Studio features an intelligent auto-installation system that automatically detects and installs missing dependencies at first launch. The system checks 14 critical packages (yaml, opencv, numpy, etc.), installs only what's missing, and handles installation errors with fallback mechanisms. This ensures a seamless first-time user experience with zero manual configuration required.\n\n### Feature Specifications\n- **Hybrid AI**: Combines CFR and Deep CFR Neural Networks (PyTorch) for strategic analysis.\n- **Automatic Detection**: Monitors and automatically launches/pauses with poker platforms (PokerStars, Winamax, PMU).\n- **Advanced OCR**: Captures screenshots and recognizes game states automatically.\n- **Continuous Learning**: Perpetually improves strategies 24/7 by generating and integrating 450 hands/minute.\n- **Nash Recommendations**: Provides optimal actions based on game theory.\n- **GPU Acceleration**: Utilizes CUDA for massive parallel computations.\n- **In-Memory Database**: High-performance storage with SQLite fallback.\n- **Intelligent Caching**: Optimizes equity calculations and card abstractions.\n- **Real-time Probabilities**: Monte Carlo calculations for win estimations.\n- **Performance Tracking**: Compares user performance against professional play.\n- **ICM Support**: Adjusts for tournament play with the Independent Chip Model.\n- **Configurable CFR**: Detailed parameters for fine-tuning algorithms (Iterations, Discount Factor, Exploration Rate, Depth, Epsilon).\n- **PyTorch/GPU Management**: Automatic detection, installation, and dynamic CPU/GPU switching with configurable memory limits.\n- **CFR Base Export/Import**: Allows saving and restoring complete CFR data, learning, and statistics in JSON format.\n- **Customizable Interface**: Adjustable accent colors, opacity, fonts, themes (dark/light), and adaptive layouts.\n\n## External Dependencies\n\n### Core Libraries\n- **NumPy/SciPy**: Mathematical computations for CFR algorithms.\n- **OpenCV**: Image processing for OCR preprocessing.\n- **PyTesseract**: OCR engine for text recognition.\n- **PyTorch**: Deep learning framework for advanced CFR implementations.\n- **Numba**: Just-in-time compilation for performance-critical operations.\n\n### GUI Framework\n- **CustomTkinter**: GUI framework for native-looking interfaces.\n- **PIL/Pillow**: Image processing for GUI components.\n- **Matplotlib/Seaborn**: Data visualization and statistical plotting.\n\n### System Integration\n- **MSS**: High-performance screen capture.\n- **PSUtil**: System resource monitoring.\n- **PyYAML**: Configuration file parsing.\n- **Threading/Multiprocessing**: Concurrency for parallel processing.\n\n### Data Storage\n- **SQLite3**: Lightweight database for data persistence and hand history.\n\n---\n\n## üöÄ Guide de D√©marrage Rapide\n\n### Installation Ultra-Simple\n```bash\n# 1. Cloner le projet\ngit clone <repository-url>\ncd rtpa-studio\n\n# 2. Lancement direct (installation automatique)\npython main_gui.py\n```\n\n### üéØ **Installation Automatique Int√©gr√©e**\n‚úÖ **Aucune installation manuelle requise !**\n- **Premier lancement** : Les d√©pendances s'installent automatiquement\n- **D√©tection intelligente** : V√©rification et installation des packages manquants\n- **Z√©ro configuration** : Pr√™t √† l'emploi en une commande\n\n### ‚ö° Utilisation Imm√©diate\n1. **Lancez simplement** : `python main_gui.py` ou `python test_rtpa.py`\n2. **Installation auto** : Les d√©pendances se t√©l√©chargent automatiquement au premier lancement\n3. **Ouvrez votre plateforme poker** (PokerStars, Winamax, PMU)\n4. **D√©tection automatique** : RTPA se lance automatiquement\n5. **Recommandations instantan√©es** : Les conseils Nash apparaissent en temps r√©el\n6. **Am√©lioration continue** : Le syst√®me s'am√©liore pendant que vous jouez\n\n---\n\n## ‚ùì Questions Fr√©quentes\n\n### Fonctionnement CFR/Nash\n**Q: Quelle est la diff√©rence entre CFR et Nash ?**\nüìä **CFR est l'algorithme qui calcule Nash.** CFR (Counterfactual Regret Minimization) utilise les regrets pour converger vers l'√©quilibre de Nash optimal. Ce n'est pas deux calculs s√©par√©s.\n\n**Q: Puis-je utiliser RTPA pendant l'apprentissage ?**\n‚úÖ **Oui !** L'apprentissage est continu en arri√®re-plan (450 mains/minute). Vous pouvez jouer imm√©diatement et profiter des am√©liorations progressives. Pas besoin d'attendre !\n\n### Configuration Technique\n**Q: GPU vs CPU ?**\n‚ö° Le syst√®me bascule automatiquement : CPU pour petits calculs, GPU pour gros batches (50+ mains). Fallback s√©curis√© si GPU indisponible.\n\n**Q: Installation PyTorch/GPU ?**\nüî• D√©tection automatique avec bouton d'installation directe dans l'interface. Support CUDA avec gestion m√©moire intelligente.\n\n### Troubleshooting\n**üî¥ Erreur 'No module named'** : Relancez le programme, l'auto-installation se d√©clenchera\n**üî¥ Installation √©choue** : V√©rifiez connexion internet et permissions Python\n**üî¥ Performance lente** : Activez GPU dans Configuration, augmentez limite m√©moire\n**üî¥ Erreurs m√©moire GPU** : R√©duisez `gpu_memory_limit` √† 0.6 et `batch_size` √† 1000\n**üî¥ D√©tection √©choue** : V√©rifiez plateforme ouverte, red√©marrez RTPA\n\n### üõ†Ô∏è Commandes de Test et Lancement\n```bash\n# Test automatique avec installation des d√©pendances\npython test_rtpa.py\n\n# Interface graphique compl√®te\npython main_gui.py\n\n# Version console/headless\npython main_headless.py\n```","size_bytes":7822},"test_final.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTest final complet de RTPA Studio\nV√©rifie tous les composants et fonctionnalit√©s\n\"\"\"\n\nimport sys\nimport time\nfrom pathlib import Path\n\nPROJECT_ROOT = Path(__file__).parent\nsys.path.append(str(PROJECT_ROOT))\n\ndef test_all_components():\n    \"\"\"Test complet de tous les composants\"\"\"\n    \n    print(\"üéØ RTPA Studio - Test Final Complet\")\n    print(\"=\" * 50)\n    \n    try:\n        # Test 1: Imports\n        print(\"1Ô∏è‚É£ Test des imports...\")\n        from src.core.app_manager import RTAPStudioManager\n        from src.utils.logger import get_logger\n        from src.database.memory_db import MemoryDatabase\n        from src.config.settings import Settings\n        from src.algorithms.cfr_engine import CFREngine\n        from src.ocr.screen_capture_headless import ScreenCaptureHeadless\n        print(\"   ‚úÖ Tous les imports OK\")\n        \n        # Test 2: Logger\n        print(\"2Ô∏è‚É£ Test du syst√®me de logging...\")\n        logger = get_logger(\"test_final\")\n        logger.info(\"Test du logger\")\n        print(\"   ‚úÖ Logger fonctionnel\")\n        \n        # Test 3: Configuration\n        print(\"3Ô∏è‚É£ Test de la configuration...\")\n        settings = Settings()\n        print(f\"   ‚úÖ Langue: {settings.language}\")\n        print(f\"   ‚úÖ Risque: {settings.risk_percentage}%\")\n        print(f\"   ‚úÖ GPU: {settings.gpu_enabled}\")\n        \n        # Test 4: Base de donn√©es\n        print(\"4Ô∏è‚É£ Test de la base de donn√©es...\")\n        db = MemoryDatabase()\n        \n        # Test insertion\n        from src.core.app_manager import GameState\n        test_state = GameState(\n            hero_cards=(\"As\", \"Kh\"),\n            board_cards=[\"Ah\", \"Kd\", \"7c\"],\n            pot_size=150.0,\n            hero_stack=2500.0\n        )\n        db.store_game_state(test_state)\n        \n        # Test r√©cup√©ration\n        latest_state = db.get_latest_game_state()\n        assert latest_state is not None\n        print(\"   ‚úÖ Base de donn√©es op√©rationnelle\")\n        \n        # Test 5: OCR (simulation)\n        print(\"5Ô∏è‚É£ Test du syst√®me OCR (simulation)...\")\n        ocr = ScreenCaptureHeadless()\n        game_data = ocr.capture_and_analyze()\n        assert game_data is not None\n        assert 'hero_cards' in game_data\n        assert 'pot_size' in game_data\n        print(f\"   ‚úÖ OCR simul√© - Cartes: {game_data['hero_cards']}\")\n        \n        # Test 6: Moteur CFR\n        print(\"6Ô∏è‚É£ Test du moteur CFR...\")\n        cfr_engine = CFREngine()\n        recommendation = cfr_engine.get_recommendation(test_state)\n        assert recommendation is not None\n        assert 'action_type' in recommendation\n        assert 'win_probability' in recommendation\n        print(f\"   ‚úÖ CFR - Action: {recommendation['action_type']}\")\n        print(f\"   ‚úÖ CFR - Probabilit√©: {recommendation['win_probability']:.1f}%\")\n        \n        # Test 7: Gestionnaire principal\n        print(\"7Ô∏è‚É£ Test du gestionnaire principal...\")\n        app_manager = RTAPStudioManager()\n        \n        # Test √©tat initial\n        current_state = app_manager.get_current_state()\n        assert current_state is not None\n        print(f\"   ‚úÖ √âtat initial: {current_state.table_type}\")\n        \n        # Test statistiques\n        stats = app_manager.get_statistics()\n        assert stats is not None\n        print(f\"   ‚úÖ Stats: {stats['hands_played']} mains\")\n        \n        # Test 8: Fonctionnement temps r√©el (court)\n        print(\"8Ô∏è‚É£ Test temps r√©el (5 secondes)...\")\n        app_manager.start()\n        \n        for i in range(5):\n            time.sleep(1)\n            state = app_manager.get_current_state()\n            rec = app_manager.get_recommendation()\n            \n            if rec:\n                print(f\"   ‚è±Ô∏è T+{i+1}s: {rec['action_type']} ({rec['win_probability']:.1f}%)\")\n        \n        app_manager.stop()\n        print(\"   ‚úÖ Test temps r√©el r√©ussi\")\n        \n        # Test 9: Gestion des param√®tres\n        print(\"9Ô∏è‚É£ Test gestion param√®tres...\")\n        app_manager.update_settings({\n            'language': 'en',\n            'risk_percentage': 75.0,\n            'gpu_enabled': False\n        })\n        print(\"   ‚úÖ Param√®tres mis √† jour\")\n        \n        # Test 10: Override manuel\n        print(\"üîü Test override manuel...\")\n        app_manager.manual_override(85.0)\n        print(\"   ‚úÖ Override manuel appliqu√©\")\n        \n        # R√©sum√© final\n        print(\"\\nüéâ TOUS LES TESTS R√âUSSIS!\")\n        print(\"=\" * 50)\n        print(\"‚úÖ Architecture compl√®te et fonctionnelle\")\n        print(\"‚úÖ Tous les composants int√©gr√©s\")\n        print(\"‚úÖ Calculs CFR/Nash op√©rationnels\")\n        print(\"‚úÖ OCR simulation fonctionnelle\")\n        print(\"‚úÖ Interface de configuration compl√®te\")\n        print(\"‚úÖ Base de donn√©es haute performance\")\n        print(\"‚úÖ Gestion des ressources implement√©e\")\n        print(\"‚úÖ Syst√®me multilingue actif\")\n        print(\"‚úÖ Mode temps r√©el valid√©\")\n        \n        print(\"\\nüöÄ RTPA Studio est pr√™t pour l'utilisation!\")\n        print(\"   ‚Üí Lancement d√©mo: python main_headless.py\")\n        print(\"   ‚Üí Interface compl√®te: python main.py\")\n        print(\"   ‚Üí Tests: python test_final.py\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"\\n‚ùå ERREUR lors du test: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\nif __name__ == \"__main__\":\n    success = test_all_components()\n    sys.exit(0 if success else 1)","size_bytes":5517},"test_rtpa.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTest simple pour v√©rifier que RTPA Studio d√©marre correctement\n\"\"\"\n\nimport sys\nimport os\nfrom pathlib import Path\n\n# Ajout du chemin du projet\nPROJECT_ROOT = Path(__file__).parent\nsys.path.append(str(PROJECT_ROOT))\n\n# Auto-installation des d√©pendances\nprint(\"üöÄ RTPA Studio - Test de d√©marrage\")\nprint(\"=\" * 50)\n\ntry:\n    # Import et ex√©cution de l'auto-installation\n    from src.utils.auto_install import auto_install_dependencies\n    auto_install_dependencies()\n    print()\nexcept Exception as e:\n    print(f\"‚ö†Ô∏è  Auto-installation √©chou√©e: {e}\")\n    print(\"üìù Tentative de poursuite du test...\")\n\ntry:\n    # Test des imports principaux\n    print(\"üîÑ Test des imports...\")\n    \n    from src.core.app_manager import RTAPStudioManager\n    from src.utils.logger import get_logger\n    from src.database.memory_db import MemoryDatabase\n    from src.config.settings import Settings\n    \n    print(\"‚úÖ Imports OK\")\n    \n    # Test initialisation des composants\n    print(\"üîÑ Test initialisation des composants...\")\n    \n    logger = get_logger(\"test\")\n    logger.info(\"Logger initialis√©\")\n    \n    settings = Settings()\n    print(f\"‚úÖ Settings charg√©s (langue: {settings.language})\")\n    \n    db = MemoryDatabase()\n    print(\"‚úÖ Base de donn√©es m√©moire initialis√©e\")\n    \n    app_manager = RTAPStudioManager()\n    print(\"‚úÖ AppManager initialis√©\")\n    \n    # Test √©tat de base\n    game_state = app_manager.get_current_state()\n    print(f\"‚úÖ √âtat de jeu r√©cup√©r√©: {game_state.table_type}\")\n    \n    # Test statistiques\n    stats = app_manager.get_statistics()\n    print(f\"‚úÖ Statistiques: {stats['hands_played']} mains jou√©es\")\n    \n    print(\"\\nüéâ Tous les tests sont pass√©s avec succ√®s!\")\n    print(\"RTPA Studio est pr√™t √† fonctionner.\")\n    \n    # Test interface graphique (sans l'afficher)\n    print(\"\\nüîÑ Test interface graphique...\")\n    from src.gui.main_window import RTAPMainWindow\n    print(\"‚úÖ Interface graphique import√©e avec succ√®s\")\n    \n    print(\"\\nüöÄ Pour lancer RTPA Studio complet, ex√©cutez: python main.py\")\n    \nexcept Exception as e:\n    print(f\"‚ùå Erreur lors du test: {e}\")\n    import traceback\n    traceback.print_exc()\n    sys.exit(1)","size_bytes":2233},"attached_assets/cahier_des_charges_1757239581203.md":{"content":"# üìò Cahier des charges ‚Äî **RTPA Studio** (v2025-09-06)\n\n> **Cadre legal & ethique**\n> Usage etude/formation/simulation uniquement (post-session, sandbox, self-play).\n> Interdits : capture/overlay/hook live sur clients de poker, communication avec plateformes, anti-detection/evasion.\n> Entrees autorisees : historiques de mains (HH), donnees de reference locales, saisie manuelle d'etats.\n\n---\n\n## 0) Synthese & adaptations\n- Conservation : base C++20, architecture modulaire, CFR/CFR+/Deep CFR, UI d'etude (ImGui), haute perf, packaging, tests.\n- Remplacement (vs propositions Cline temps reel) : pas de capture ecran/Windows API, pas d'integration Winamax/PokerStars/Bwin, pas de 'non-detectabilite'.\n- Nouveautes (accelerer dev) : integration DeepStack-Leduc (toy game) et Hands_History comme ressources d'entrainement/validation et echantillons.\n\n---\n\n## 1) Portee & objectifs\n- Pipeline complet : HH -> DB SQLite -> features -> CFR+ / Deep CFR (opt) -> evaluation -> UI etude & rapports.\n- Seed initiale : (a) import Hands_History + (b) generation N mains synthetiques self-play baselines + (c) scenarios DeepStack-Leduc (validation/toy).\n- Reproductibilite : seeds RNG, checkpoints modeles/datasets, configs YAML versionnees.\n- Extensibilite : nouveaux parsers HH, nouveaux binnings, nouveaux algorithmes.\nHors perimetre : integration live, anti-cheat, automations systeme/Windows, interaction avec clients tiers.\n\n---\n\n## 2) Exigences\n### 2.1 Fonctionnelles (FR-xx)\n- FR-01 Import HH multi-rooms (Winamax, PokerStars) + auto-detection (RoomDetect).\n- FR-02 Normalisation -> SQLite + index; migrations versionnees.\n- FR-03 Encodage features (etat compact) + labels (action / size_bin).\n- FR-04 Binnings actions/sizings contextualises (SPR/street), board textures, buckets 1326->K.\n- FR-05 CFR+ discret : regrets>=0, averaging pondere, sampling External/Outcome.\n- FR-06 Deep CFR (option torch) : A-Net/P-Net, buffers reservoir, cycles.\n- FR-07 Evaluation : EV self-play, regret moyen, proxy exploitabilite (sous abstraction), ablations.\n- FR-08 UI etude (Dashboard/Review/Sandbox/Training) + exports CSV/PDF.\n- FR-09 Seed initiale : importer Hands_History + generer N mains synthetiques + importer scenarios Leduc.\n- FR-10 Outils CLI : rtpa_db_init, rtpa_import_hh, rtpa_make_features, rtpa_train_cfr, rtpa_eval, rtpa_ui, rtpa_dump_bins, rtpa_seed_synth.\n\n### 2.2 Non-fonctionnelles (NFR-xx)\n- NFR-Perf : objectifs indicatifs Desktop moderne - CFR+ >= 50k actions/s binned ; EV MC >= 200k it/s.\n- NFR-Robustesse : build OK sans torch (Deep CFR off) ; tests unitaires/integration ; ctest.\n- NFR-Portabilite : Windows 10+/Linux x64 ; MSVC/Clang/GCC ; CMake >= 3.20.\n- NFR-Securite : pas d'acces process externes ; pas de reseau par defaut.\n- NFR-Evolutivite : interfaces stables, options CMake, configs YAML.\n\n---\n\n## 3) Architecture\n### 3.1 Modules\n```\ncore/  : arbres, CFR+, regrets/strategies, binnings, RNG, utils\ndeep/  : A-Net, P-Net, replay buffers (libtorch) [optionnel]\ndata/  : parsers HH, normalisation, FeatureEncoder, import DeepStack-Leduc\ndb/    : SQLite RAII, migrations, DAO, train_runs, eval_metrics\nsim/   : EV/rollouts Monte-Carlo, self-play, baselines\nui/    : ImGui (Dashboard/Review/Sandbox/Training/Exports)\ntools/ : CLI (db_init, import_hh, make_features, train_cfr, train_deep_cfr, eval, ui, dump_bins, seed_synth)\ntests/ : unitaires, integration, perf, fuzz/property parsers\ndocs/  : guides (install/usage/datasets/algo/ui), samples (HH, Leduc), config_samples/\nthird_party/, cmake/, CMakeLists.txt\n```\n\n### 3.2 Options CMake\nRTPA_WITH_DEEPCFR(OFF), RTPA_WITH_IMGUI(ON), RTPA_WITH_QT(OFF), RTPA_WITH_RUST_FFI(OFF).\nLibs : fmt, spdlog, sqlite3 amalgamation, yaml-cpp, ImGui+GLFW, Catch2/GoogleTest.\n\n---\n\n## 4) Donnees & DB\n### 4.1 Schema (DDL abrege)\nTables : players, hands, seats, actions, boards, showdowns, features, models, train_runs, eval_metrics, config.\nIndex : (hand_id, street) sur actions, (street) sur features, (model_id) sur train_runs.\n\n### 4.2 Sources & licensing\n- Hands_History/ (locaux) : importer -> normaliser ; verifier droits/licence ; anonymiser.\n- DeepStack-Leduc/ : integrer scenarios Leduc (toy) pour tests/validation.\n- Synthetiques : rtpa_seed_synth produit N mains self-play baseline (configurable).\n\n### 4.3 Pipeline\n/data/raw -> parse/normalize -> insert DB -> features -> split train/val/test (stratifie) -> dataset_tag.\n\n---\n\n## 5) Etats & abstractions\n- Buckets cartes 1326->K (K in {32,64,128,...}) par equite vs ranges, isomorphismes et card-removal.\n- Textures board : dry/semi-wet/wet, monotone/2-tone, paire, high/low, connecte.\n- Binnings actions : {{Fold, Check/Call, Bet/Raise : 25/33/50/66/75/100/Pot/All-in}} filtres par SPR/street.\n- Feature encoding : hero (bucket, pos, stack eff, SPR), board (texture +/- cartes), history (seq binned), contexte (nb joueurs).\n- Labels : (action_class, size_bin), eventuellement logits/advantage.\n\n---\n\n## 6) Algorithmes\n### 6.1 CFR / CFR+\nRegret (I,a) :\nR^t(I,a) = R^{t-1}(I,a) + sum_{z in Z_I} pi^{sigma}_{-i}(z[I]) * (u_i(sigma_{I->a}, z) - u_i(sigma, z))\nRegret-matching :\nsigma^{t+1}(I,a) = R^t(I,a)^+ / sum_b R^t(I,b)^+\nCFR+ : clipping regrets >= 0 ; averaging pondere ; sampling External/Outcome.\n\n### 6.2 Monte-Carlo EV\nRollouts partiels street-by-street ; RNG thread-local ; back-solves (river->turn->flop) pour amorcer regrets.\n\n### 6.3 Deep CFR (option)\nA-Net/P-Net, buffers reservoir ; cycles : traversals -> train A -> update sigma -> train P.\nHyperparams init : width 256-512, depth 3-5, dropout 0.1-0.2, lr 1e-3, batch 2k-8k, cosine decay.\n\n### 6.4 Validation Leduc\nLeduc Hold'em (etat reduit) pour tests unitaires : convergence CFR+ rapide ; verifs de coherence.\nPont d'abstraction : memes interfaces (GameTree/Infosets), autre jeu.\n\n---\n\n## 7) UI d'etude (ImGui)\nDashboard (KPIs, runs, checkpoints), Review (replayer HH + alternatives/EV), Sandbox (editeur d'etats), Training (jobs CFR/Deep), Exports (CSV/PDF).\nNon-bloquante ; filtres ; themes ; ouverture dossiers exports/checkpoints.\n\n---\n\n## 8) Config, logs, qualite\nYAML : global.yaml, bins.yaml, cfr.yaml, deep.yaml (docs/config_samples/).\nLogs : spdlog rotatif ; niveaux ; timestamps ; journaux runs (DB).\nTests : unitaires/integration ; fuzz/property parsers ; perf microbench ; seuils regression optionnels.\nSanitizers : ASan/UBSan (Clang/GCC) ; /W4 /WX (MSVC).\n\n---\n\n## 9) Packaging & deploiement\ncpack zip/7z : binaires, rtpa.db vierge, docs, samples (HH/Leduc), config, docs/config_samples.\nRTPA_VERSION (semver) ; --version dans chaque binaire.\n\n---\n\n## 10) Roadmap & livrables\nM1 DB+ingestion ; M2 EV+CFR+ ; M3 Deep CFR (opt) ; M4 UI ; M5 Eval+Docs.\nLivrables : binaires, DB, checkpoints, scripts seeds, docs completes.\n\n---\n\n## 11) Risques & mitigations\nVariabilite HH -> tests & fuzz ; licences/droits HH -> verif & anonymisation.\nPerf -> binnings adaptatifs, Rust FFI (option).\nComplexite Deep -> voie CFR+ only complete & stable.\n\n---\n\n## 12) Annexes\nPseudo-code CFR+/Deep CFR, exemples YAML, modeles rapports CSV.\nNotes : mappages Leduc<->NLHE (abstractions, tailles d'actions) pour tests.\n","size_bytes":7094},"attached_assets/cahier_des_charges_1757242186713.md":{"content":"# üìò Cahier des charges ‚Äî **RTPA Studio** (v2025-09-06)\n\n> **Cadre legal & ethique**\n> Usage etude/formation/simulation uniquement (post-session, sandbox, self-play).\n> Interdits : capture/overlay/hook live sur clients de poker, communication avec plateformes, anti-detection/evasion.\n> Entrees autorisees : historiques de mains (HH), donnees de reference locales, saisie manuelle d'etats.\n\n---\n\n## 0) Synthese & adaptations\n- Conservation : base C++20, architecture modulaire, CFR/CFR+/Deep CFR, UI d'etude (ImGui), haute perf, packaging, tests.\n- Remplacement (vs propositions Cline temps reel) : pas de capture ecran/Windows API, pas d'integration Winamax/PokerStars/Bwin, pas de 'non-detectabilite'.\n- Nouveautes (accelerer dev) : integration DeepStack-Leduc (toy game) et Hands_History comme ressources d'entrainement/validation et echantillons.\n\n---\n\n## 1) Portee & objectifs\n- Pipeline complet : HH -> DB SQLite -> features -> CFR+ / Deep CFR (opt) -> evaluation -> UI etude & rapports.\n- Seed initiale : (a) import Hands_History + (b) generation N mains synthetiques self-play baselines + (c) scenarios DeepStack-Leduc (validation/toy).\n- Reproductibilite : seeds RNG, checkpoints modeles/datasets, configs YAML versionnees.\n- Extensibilite : nouveaux parsers HH, nouveaux binnings, nouveaux algorithmes.\nHors perimetre : integration live, anti-cheat, automations systeme/Windows, interaction avec clients tiers.\n\n---\n\n## 2) Exigences\n### 2.1 Fonctionnelles (FR-xx)\n- FR-01 Import HH multi-rooms (Winamax, PokerStars) + auto-detection (RoomDetect).\n- FR-02 Normalisation -> SQLite + index; migrations versionnees.\n- FR-03 Encodage features (etat compact) + labels (action / size_bin).\n- FR-04 Binnings actions/sizings contextualises (SPR/street), board textures, buckets 1326->K.\n- FR-05 CFR+ discret : regrets>=0, averaging pondere, sampling External/Outcome.\n- FR-06 Deep CFR (option torch) : A-Net/P-Net, buffers reservoir, cycles.\n- FR-07 Evaluation : EV self-play, regret moyen, proxy exploitabilite (sous abstraction), ablations.\n- FR-08 UI etude (Dashboard/Review/Sandbox/Training) + exports CSV/PDF.\n- FR-09 Seed initiale : importer Hands_History + generer N mains synthetiques + importer scenarios Leduc.\n- FR-10 Outils CLI : rtpa_db_init, rtpa_import_hh, rtpa_make_features, rtpa_train_cfr, rtpa_eval, rtpa_ui, rtpa_dump_bins, rtpa_seed_synth.\n\n### 2.2 Non-fonctionnelles (NFR-xx)\n- NFR-Perf : objectifs indicatifs Desktop moderne - CFR+ >= 50k actions/s binned ; EV MC >= 200k it/s.\n- NFR-Robustesse : build OK sans torch (Deep CFR off) ; tests unitaires/integration ; ctest.\n- NFR-Portabilite : Windows 10+/Linux x64 ; MSVC/Clang/GCC ; CMake >= 3.20.\n- NFR-Securite : pas d'acces process externes ; pas de reseau par defaut.\n- NFR-Evolutivite : interfaces stables, options CMake, configs YAML.\n\n---\n\n## 3) Architecture\n### 3.1 Modules\n```\ncore/  : arbres, CFR+, regrets/strategies, binnings, RNG, utils\ndeep/  : A-Net, P-Net, replay buffers (libtorch) [optionnel]\ndata/  : parsers HH, normalisation, FeatureEncoder, import DeepStack-Leduc\ndb/    : SQLite RAII, migrations, DAO, train_runs, eval_metrics\nsim/   : EV/rollouts Monte-Carlo, self-play, baselines\nui/    : ImGui (Dashboard/Review/Sandbox/Training/Exports)\ntools/ : CLI (db_init, import_hh, make_features, train_cfr, train_deep_cfr, eval, ui, dump_bins, seed_synth)\ntests/ : unitaires, integration, perf, fuzz/property parsers\ndocs/  : guides (install/usage/datasets/algo/ui), samples (HH, Leduc), config_samples/\nthird_party/, cmake/, CMakeLists.txt\n```\n\n### 3.2 Options CMake\nRTPA_WITH_DEEPCFR(OFF), RTPA_WITH_IMGUI(ON), RTPA_WITH_QT(OFF), RTPA_WITH_RUST_FFI(OFF).\nLibs : fmt, spdlog, sqlite3 amalgamation, yaml-cpp, ImGui+GLFW, Catch2/GoogleTest.\n\n---\n\n## 4) Donnees & DB\n### 4.1 Schema (DDL abrege)\nTables : players, hands, seats, actions, boards, showdowns, features, models, train_runs, eval_metrics, config.\nIndex : (hand_id, street) sur actions, (street) sur features, (model_id) sur train_runs.\n\n### 4.2 Sources & licensing\n- Hands_History/ (locaux) : importer -> normaliser ; verifier droits/licence ; anonymiser.\n- DeepStack-Leduc/ : integrer scenarios Leduc (toy) pour tests/validation.\n- Synthetiques : rtpa_seed_synth produit N mains self-play baseline (configurable).\n\n### 4.3 Pipeline\n/data/raw -> parse/normalize -> insert DB -> features -> split train/val/test (stratifie) -> dataset_tag.\n\n---\n\n## 5) Etats & abstractions\n- Buckets cartes 1326->K (K in {32,64,128,...}) par equite vs ranges, isomorphismes et card-removal.\n- Textures board : dry/semi-wet/wet, monotone/2-tone, paire, high/low, connecte.\n- Binnings actions : {{Fold, Check/Call, Bet/Raise : 25/33/50/66/75/100/Pot/All-in}} filtres par SPR/street.\n- Feature encoding : hero (bucket, pos, stack eff, SPR), board (texture +/- cartes), history (seq binned), contexte (nb joueurs).\n- Labels : (action_class, size_bin), eventuellement logits/advantage.\n\n---\n\n## 6) Algorithmes\n### 6.1 CFR / CFR+\nRegret (I,a) :\nR^t(I,a) = R^{t-1}(I,a) + sum_{z in Z_I} pi^{sigma}_{-i}(z[I]) * (u_i(sigma_{I->a}, z) - u_i(sigma, z))\nRegret-matching :\nsigma^{t+1}(I,a) = R^t(I,a)^+ / sum_b R^t(I,b)^+\nCFR+ : clipping regrets >= 0 ; averaging pondere ; sampling External/Outcome.\n\n### 6.2 Monte-Carlo EV\nRollouts partiels street-by-street ; RNG thread-local ; back-solves (river->turn->flop) pour amorcer regrets.\n\n### 6.3 Deep CFR (option)\nA-Net/P-Net, buffers reservoir ; cycles : traversals -> train A -> update sigma -> train P.\nHyperparams init : width 256-512, depth 3-5, dropout 0.1-0.2, lr 1e-3, batch 2k-8k, cosine decay.\n\n### 6.4 Validation Leduc\nLeduc Hold'em (etat reduit) pour tests unitaires : convergence CFR+ rapide ; verifs de coherence.\nPont d'abstraction : memes interfaces (GameTree/Infosets), autre jeu.\n\n---\n\n## 7) UI d'etude (ImGui)\nDashboard (KPIs, runs, checkpoints), Review (replayer HH + alternatives/EV), Sandbox (editeur d'etats), Training (jobs CFR/Deep), Exports (CSV/PDF).\nNon-bloquante ; filtres ; themes ; ouverture dossiers exports/checkpoints.\n\n---\n\n## 8) Config, logs, qualite\nYAML : global.yaml, bins.yaml, cfr.yaml, deep.yaml (docs/config_samples/).\nLogs : spdlog rotatif ; niveaux ; timestamps ; journaux runs (DB).\nTests : unitaires/integration ; fuzz/property parsers ; perf microbench ; seuils regression optionnels.\nSanitizers : ASan/UBSan (Clang/GCC) ; /W4 /WX (MSVC).\n\n---\n\n## 9) Packaging & deploiement\ncpack zip/7z : binaires, rtpa.db vierge, docs, samples (HH/Leduc), config, docs/config_samples.\nRTPA_VERSION (semver) ; --version dans chaque binaire.\n\n---\n\n## 10) Roadmap & livrables\nM1 DB+ingestion ; M2 EV+CFR+ ; M3 Deep CFR (opt) ; M4 UI ; M5 Eval+Docs.\nLivrables : binaires, DB, checkpoints, scripts seeds, docs completes.\n\n---\n\n## 11) Risques & mitigations\nVariabilite HH -> tests & fuzz ; licences/droits HH -> verif & anonymisation.\nPerf -> binnings adaptatifs, Rust FFI (option).\nComplexite Deep -> voie CFR+ only complete & stable.\n\n---\n\n## 12) Annexes\nPseudo-code CFR+/Deep CFR, exemples YAML, modeles rapports CSV.\nNotes : mappages Leduc<->NLHE (abstractions, tailles d'actions) pour tests.\n","size_bytes":7094},"config/settings.yaml":{"content":"abstraction_buckets: 64\nauto_hand_target: true\nauto_resource_management: true\ncfr_iterations: 1000\ncfr_sampling_enabled: true\ncpu_usage_limit: 80.0\ndefault_table_type: cashgame\ngpu_enabled: false\ngpu_memory_limit: 80.0\nlanguage: en\nmanual_risk_override: false\nmax_players: 9\nnash_calculation_interval_ms: 50\nocr_confidence_threshold: 0.8\nocr_enabled: true\nocr_interval_ms: 50\nram_usage_limit: 70.0\nrisk_percentage: 75.0\nscreen_region:\n  height: 1080\n  width: 1920\n  x: 0\n  y: 0\nshow_probabilities: true\nshow_recommendations: true\nshow_statistics: true\ntarget_hands_per_100: 65\ntheme: dark\n","size_bytes":589},"cpp_modules/rtpa_core.cpp":{"content":"/*\n * RTPA Studio - Module C++ Core\n * Optimisations hautes performances pour calculs CFR/Nash et OCR\n */\n\n#include <Python.h>\n#include <vector>\n#include <unordered_map>\n#include <random>\n#include <chrono>\n#include <algorithm>\n#include <cmath>\n#include <string>\n\n// Structure pour √©tat de jeu optimis√©\nstruct GameState {\n    int street;\n    int hero_cards[2];\n    int board_cards[5];\n    double pot_size;\n    double hero_stack;\n    int position;\n    int num_players;\n    double current_bet;\n    bool action_to_hero;\n    std::string table_type;\n};\n\n// Structure pour recommandation\nstruct Recommendation {\n    std::string action_type;\n    double bet_size;\n    double win_probability;\n    double expected_value;\n    double risk_level;\n    double confidence;\n    std::string reasoning;\n};\n\n// Classe CFR optimis√©e\nclass OptimizedCFR {\nprivate:\n    std::unordered_map<std::string, std::unordered_map<std::string, double>> regret_sum;\n    std::unordered_map<std::string, std::unordered_map<std::string, double>> strategy_sum;\n    std::mt19937 rng;\n    \npublic:\n    OptimizedCFR() : rng(std::chrono::steady_clock::now().time_since_epoch().count()) {}\n    \n    // Calcul rapide d'√©quit√© Monte Carlo\n    double calculate_equity(const std::vector<int>& hero_cards, \n                          const std::vector<int>& board_cards,\n                          int num_opponents = 1,\n                          int simulations = 10000) {\n        \n        int wins = 0;\n        std::vector<int> deck;\n        \n        // Cr√©ation du deck (52 cartes - cartes connues)\n        for (int i = 0; i < 52; i++) {\n            bool used = false;\n            for (int card : hero_cards) {\n                if (card == i) { used = true; break; }\n            }\n            for (int card : board_cards) {\n                if (card == i) { used = true; break; }\n            }\n            if (!used) deck.push_back(i);\n        }\n        \n        // Simulations Monte Carlo\n        for (int sim = 0; sim < simulations; sim++) {\n            std::shuffle(deck.begin(), deck.end(), rng);\n            \n            // Compl√©tion du board si n√©cessaire\n            std::vector<int> full_board = board_cards;\n            int board_index = 0;\n            while (full_board.size() < 5) {\n                full_board.push_back(deck[board_index++]);\n            }\n            \n            // Distribution des cartes adverses\n            std::vector<std::vector<int>> opponent_hands(num_opponents);\n            for (int opp = 0; opp < num_opponents; opp++) {\n                opponent_hands[opp] = {deck[board_index], deck[board_index + 1]};\n                board_index += 2;\n            }\n            \n            // √âvaluation des mains\n            int hero_strength = evaluate_hand(hero_cards, full_board);\n            bool wins_hand = true;\n            \n            for (const auto& opp_hand : opponent_hands) {\n                int opp_strength = evaluate_hand(opp_hand, full_board);\n                if (opp_strength >= hero_strength) {\n                    wins_hand = false;\n                    break;\n                }\n            }\n            \n            if (wins_hand) wins++;\n        }\n        \n        return static_cast<double>(wins) / simulations;\n    }\n    \n    // √âvaluation rapide de main (simplifi√©e)\n    int evaluate_hand(const std::vector<int>& hand_cards, const std::vector<int>& board_cards) {\n        std::vector<int> all_cards = hand_cards;\n        all_cards.insert(all_cards.end(), board_cards.begin(), board_cards.end());\n        \n        // Conversion en rangs et couleurs\n        std::vector<int> ranks(all_cards.size());\n        std::vector<int> suits(all_cards.size());\n        \n        for (size_t i = 0; i < all_cards.size(); i++) {\n            ranks[i] = all_cards[i] % 13;\n            suits[i] = all_cards[i] / 13;\n        }\n        \n        // Comptage des rangs\n        std::vector<int> rank_counts(13, 0);\n        for (int rank : ranks) {\n            rank_counts[rank]++;\n        }\n        \n        // Recherche de combinaisons (simplifi√©e)\n        std::sort(rank_counts.rbegin(), rank_counts.rend());\n        \n        if (rank_counts[0] == 4) return 7000; // Carr√©\n        if (rank_counts[0] == 3 && rank_counts[1] == 2) return 6000; // Full\n        if (rank_counts[0] == 3) return 3000; // Brelan\n        if (rank_counts[0] == 2 && rank_counts[1] == 2) return 2000; // Double paire\n        if (rank_counts[0] == 2) return 1000; // Paire\n        \n        // Carte haute\n        std::sort(ranks.rbegin(), ranks.rend());\n        return ranks[0] * 10 + ranks[1];\n    }\n    \n    // Calcul CFR optimis√©\n    Recommendation get_recommendation(const GameState& state) {\n        Recommendation rec;\n        \n        // Conversion cartes\n        std::vector<int> hero_cards = {state.hero_cards[0], state.hero_cards[1]};\n        std::vector<int> board_cards;\n        for (int i = 0; i < 5 && state.board_cards[i] != -1; i++) {\n            board_cards.push_back(state.board_cards[i]);\n        }\n        \n        // Calcul d'√©quit√©\n        double equity = calculate_equity(hero_cards, board_cards, state.num_players - 1);\n        \n        // Logique de d√©cision simplifi√©e mais rapide\n        if (equity > 0.7) {\n            rec.action_type = \"bet_large\";\n            rec.bet_size = state.pot_size * 0.75;\n            rec.risk_level = 40.0;\n        } else if (equity > 0.5) {\n            rec.action_type = \"bet_medium\";\n            rec.bet_size = state.pot_size * 0.5;\n            rec.risk_level = 50.0;\n        } else if (equity > 0.3) {\n            if (state.current_bet == 0) {\n                rec.action_type = \"check\";\n                rec.bet_size = 0.0;\n            } else {\n                rec.action_type = \"call\";\n                rec.bet_size = state.current_bet;\n            }\n            rec.risk_level = 60.0;\n        } else {\n            rec.action_type = \"fold\";\n            rec.bet_size = 0.0;\n            rec.risk_level = 0.0;\n        }\n        \n        rec.win_probability = equity * 100.0;\n        rec.expected_value = equity * state.pot_size - (1.0 - equity) * rec.bet_size;\n        rec.confidence = std::min(95.0, 50.0 + equity * 50.0);\n        rec.reasoning = \"Analyse C++ optimis√©e\";\n        \n        return rec;\n    }\n};\n\n// Variables globales\nstatic OptimizedCFR* cfr_engine = nullptr;\n\n// Fonctions Python-C++\nextern \"C\" {\n    \n    // Initialisation du moteur CFR\n    static PyObject* init_cfr_engine(PyObject* self, PyObject* args) {\n        if (cfr_engine) delete cfr_engine;\n        cfr_engine = new OptimizedCFR();\n        Py_RETURN_NONE;\n    }\n    \n    // Calcul d'√©quit√© rapide\n    static PyObject* calculate_equity_fast(PyObject* self, PyObject* args) {\n        PyObject* hero_cards_list;\n        PyObject* board_cards_list;\n        int num_opponents = 1;\n        int simulations = 10000;\n        \n        if (!PyArg_ParseTuple(args, \"OO|ii\", &hero_cards_list, &board_cards_list, \n                             &num_opponents, &simulations)) {\n            return NULL;\n        }\n        \n        // Conversion des listes Python en vecteurs C++\n        std::vector<int> hero_cards;\n        std::vector<int> board_cards;\n        \n        // Traitement des cartes h√©ros\n        if (PyList_Check(hero_cards_list)) {\n            for (Py_ssize_t i = 0; i < PyList_Size(hero_cards_list); i++) {\n                PyObject* item = PyList_GetItem(hero_cards_list, i);\n                if (PyLong_Check(item)) {\n                    hero_cards.push_back(PyLong_AsLong(item));\n                }\n            }\n        }\n        \n        // Traitement des cartes board\n        if (PyList_Check(board_cards_list)) {\n            for (Py_ssize_t i = 0; i < PyList_Size(board_cards_list); i++) {\n                PyObject* item = PyList_GetItem(board_cards_list, i);\n                if (PyLong_Check(item)) {\n                    board_cards.push_back(PyLong_AsLong(item));\n                }\n            }\n        }\n        \n        // Calcul\n        if (!cfr_engine) cfr_engine = new OptimizedCFR();\n        double equity = cfr_engine->calculate_equity(hero_cards, board_cards, \n                                                   num_opponents, simulations);\n        \n        return PyFloat_FromDouble(equity);\n    }\n    \n    // Recommandation rapide\n    static PyObject* get_recommendation_fast(PyObject* self, PyObject* args) {\n        // Param√®tres\n        int street, hero_card1, hero_card2, position, num_players;\n        double pot_size, hero_stack, current_bet;\n        PyObject* board_cards_list;\n        const char* table_type;\n        int action_to_hero;\n        \n        if (!PyArg_ParseTuple(args, \"iiiidddOsi\", &street, &hero_card1, &hero_card2,\n                             &position, &num_players, &pot_size, &hero_stack, \n                             &current_bet, &board_cards_list, &table_type, &action_to_hero)) {\n            return NULL;\n        }\n        \n        // Construction de l'√©tat\n        GameState state;\n        state.street = street;\n        state.hero_cards[0] = hero_card1;\n        state.hero_cards[1] = hero_card2;\n        state.position = position;\n        state.num_players = num_players;\n        state.pot_size = pot_size;\n        state.hero_stack = hero_stack;\n        state.current_bet = current_bet;\n        state.action_to_hero = action_to_hero == 1;\n        state.table_type = std::string(table_type);\n        \n        // Board cards\n        for (int i = 0; i < 5; i++) state.board_cards[i] = -1;\n        \n        if (PyList_Check(board_cards_list)) {\n            for (Py_ssize_t i = 0; i < PyList_Size(board_cards_list) && i < 5; i++) {\n                PyObject* item = PyList_GetItem(board_cards_list, i);\n                if (PyLong_Check(item)) {\n                    state.board_cards[i] = PyLong_AsLong(item);\n                }\n            }\n        }\n        \n        // Calcul de la recommandation\n        if (!cfr_engine) cfr_engine = new OptimizedCFR();\n        Recommendation rec = cfr_engine->get_recommendation(state);\n        \n        // Cr√©ation du dictionnaire de retour\n        PyObject* dict = PyDict_New();\n        PyDict_SetItemString(dict, \"action_type\", PyUnicode_FromString(rec.action_type.c_str()));\n        PyDict_SetItemString(dict, \"bet_size\", PyFloat_FromDouble(rec.bet_size));\n        PyDict_SetItemString(dict, \"win_probability\", PyFloat_FromDouble(rec.win_probability));\n        PyDict_SetItemString(dict, \"expected_value\", PyFloat_FromDouble(rec.expected_value));\n        PyDict_SetItemString(dict, \"risk_level\", PyFloat_FromDouble(rec.risk_level));\n        PyDict_SetItemString(dict, \"confidence\", PyFloat_FromDouble(rec.confidence));\n        PyDict_SetItemString(dict, \"reasoning\", PyUnicode_FromString(rec.reasoning.c_str()));\n        \n        return dict;\n    }\n    \n    // Nettoyage\n    static PyObject* cleanup_cfr(PyObject* self, PyObject* args) {\n        if (cfr_engine) {\n            delete cfr_engine;\n            cfr_engine = nullptr;\n        }\n        Py_RETURN_NONE;\n    }\n    \n    // Table des m√©thodes\n    static PyMethodDef RTPAMethods[] = {\n        {\"init_cfr_engine\", init_cfr_engine, METH_VARARGS, \"Initialise le moteur CFR C++\"},\n        {\"calculate_equity_fast\", calculate_equity_fast, METH_VARARGS, \"Calcul d'√©quit√© rapide\"},\n        {\"get_recommendation_fast\", get_recommendation_fast, METH_VARARGS, \"Recommandation rapide\"},\n        {\"cleanup_cfr\", cleanup_cfr, METH_VARARGS, \"Nettoyage du moteur CFR\"},\n        {NULL, NULL, 0, NULL}\n    };\n    \n    // D√©finition du module\n    static struct PyModuleDef rtpamodule = {\n        PyModuleDef_HEAD_INIT,\n        \"rtpa_core\",\n        \"Module C++ optimis√© pour RTPA Studio\",\n        -1,\n        RTPAMethods\n    };\n    \n    // Initialisation du module\n    PyMODINIT_FUNC PyInit_rtpa_core(void) {\n        return PyModule_Create(&rtpamodule);\n    }\n}\n\n// Fonction de test pour compilation\nint main() {\n    OptimizedCFR cfr;\n    std::vector<int> hero = {12, 25}; // As de pique, Roi de coeur\n    std::vector<int> board = {11, 24, 6}; // Dame de pique, Roi de tr√®fle, 7 de pique\n    \n    double equity = cfr.calculate_equity(hero, board, 1, 1000);\n    printf(\"√âquit√© calcul√©e: %.2f%%\\\\n\", equity * 100);\n    \n    return 0;\n}\n","size_bytes":12181},"cpp_modules/setup.py":{"content":"\"\"\"\nConfiguration pour compiler le module C++ RTPA Studio\n\"\"\"\n\nfrom pybind11.setup_helpers import Pybind11Extension, build_ext\nfrom pybind11 import get_cmake_dir\nimport pybind11\nfrom distutils.core import setup, Extension\n\n# Extension C++ pour RTPA Studio\nrtpa_core_module = Extension(\n    'rtpa_core',\n    sources=['rtpa_core.cpp'],\n    include_dirs=[\n        # Path to pybind11 headers\n        pybind11.get_include(),\n    ],\n    language='c++',\n    extra_compile_args=['-std=c++17', '-O3', '-march=native'],\n)\n\nsetup(\n    name='rtpa_core',\n    version='1.0',\n    description='Module C++ optimis√© pour RTPA Studio',\n    ext_modules=[rtpa_core_module],\n    cmdclass={'build_ext': build_ext},\n    zip_safe=False,\n)","size_bytes":714},"src/__init__.py":{"content":"# RTPA Studio Package","size_bytes":21},"src/algorithms/__init__.py":{"content":"# Algorithms module","size_bytes":19},"src/algorithms/cfr_engine.py":{"content":"\"\"\"\nMoteur CFR/CFR+ pour calculs Nash en temps r√©el\nImpl√©mentation optimis√©e pour le poker Texas Hold'em No Limit\n\"\"\"\n\nimport numpy as np\nimport math\nimport time\nimport threading\nfrom typing import Dict, List, Tuple, Any, Optional\nfrom dataclasses import dataclass\nfrom collections import defaultdict, deque\nimport itertools\nimport multiprocessing as mp\n\n# GPU/CPU Acceleration support\ntry:\n    import torch\n    import torch.nn as nn\n    import torch.optim as optim\n    import torch.nn.functional as F\n    TORCH_AVAILABLE = True\nexcept ImportError:\n    TORCH_AVAILABLE = False\n    torch = None\n\nfrom numba import jit, prange\nfrom ..utils.logger import get_logger\nfrom .card_abstraction import CardAbstraction\nfrom .action_abstraction import ActionAbstraction\n\n@dataclass\nclass PokerState:\n    \"\"\"√âtat de poker pour CFR\"\"\"\n    street: int  # 0=preflop, 1=flop, 2=turn, 3=river\n    hero_cards: Tuple[str, str]\n    board_cards: List[str]\n    pot_size: float\n    hero_stack: float\n    position: int\n    num_players: int\n    current_bet: float\n    action_history: List[str]\n    table_type: str  # \"cashgame\" ou \"tournament\"\n\n@dataclass\nclass ActionSpace:\n    \"\"\"Espace d'actions possibles\"\"\"\n    fold: bool = True\n    check_call: bool = True\n    bet_sizes: Optional[List[float]] = None  # En pourcentage du pot\n    \n    def __post_init__(self):\n        if self.bet_sizes is None:\n            self.bet_sizes = [0.25, 0.33, 0.5, 0.66, 0.75, 1.0, 1.5, 2.0]  # Pourcentages du pot\n\nclass CFREngine:\n    \"\"\"Moteur CFR+ optimis√© pour poker temps r√©el avec acc√©l√©ration GPU/CPU\"\"\"\n    \n    def __init__(self):\n        self.logger = get_logger(__name__)\n        \n        # Configuration des param√®tres - Utiliser les param√®tres globaux\n        from ..config.settings import Settings\n        self.config = Settings()\n        \n        # Configuration d'acc√©l√©ration GPU/CPU\n        self.device = self._setup_compute_device()\n        self.use_acceleration = TORCH_AVAILABLE\n        self.gpu_enabled = self.config.gpu_enabled if hasattr(self.config, 'gpu_enabled') else False\n        self.gpu_memory_limit = 0.8  # 80% max m√©moire GPU\n        self.cpu_threads = mp.cpu_count()\n        \n        # Tables de regrets et strat√©gies\n        self.regret_sum = defaultdict(lambda: defaultdict(float))\n        self.strategy_sum = defaultdict(lambda: defaultdict(float))\n        self.current_strategy = defaultdict(lambda: defaultdict(float))\n        \n        # Cache tenseurs pour optimisation\n        self._tensor_cache = {}\n        self._computation_cache = {}\n        \n        # Configuration CFR optimis√©e GPU\n        self.iterations = 0\n        self.iterations_count = 0  # Pour compatibilit√© avec export/import\n        self.total_training_time = 0.0  # Temps total d'entra√Ænement\n        self.discount_factor = 0.95\n        self.exploration_rate = 0.1\n        self.gpu_batch_size = 2000  # Taille batch optimale GPU\n        self.gpu_auto_scaling = True  # Scaling automatique selon charge\n        \n        # Nouveaux composants pour entra√Ænement massif\n        self.cfr_trainer = None\n        self.auto_training_enabled = True\n        self.training_target_reached = False\n        \n        # Abstractions\n        self.card_abstraction = CardAbstraction()\n        self.action_abstraction = ActionAbstraction()\n        \n        # Cache des calculs\n        self.equity_cache = {}\n        self.abstraction_cache = {}\n        \n        # Multithreading optimis√©\n        self.calculation_lock = threading.RLock()\n        self.background_thread = None\n        self.is_running = False\n        \n        # Configuration du threading optimal (seulement si pas d√©j√† configur√©)\n        if TORCH_AVAILABLE:\n            try:\n                torch.set_num_threads(self.cpu_threads)\n                torch.set_num_interop_threads(max(1, self.cpu_threads // 2))\n            except RuntimeError as e:\n                # Threads d√©j√† configur√©s, ignorer l'erreur\n                self.logger.debug(f\"Threads PyTorch d√©j√† configur√©s: {e}\")\n        \n        # Mod√®le Deep CFR (optionnel)\n        self.deep_cfr_enabled = False\n        self.advantage_net = None\n        self.strategy_net = None\n        \n        # Initialisation de l'entra√Æneur CFR (sera fait plus tard pour √©viter import circulaire)\n        self.cfr_trainer = None\n        \n        # Initialiser l'acc√©l√©rateur GPU\n        self._init_gpu_accelerator()\n        \n        self.logger.info(\"CFREngine initialis√© avec entra√Ænement automatique\")\n        if self.use_acceleration:\n            self.logger.info(f\"Acc√©l√©ration disponible: {self.device}\")\n    \n    def update_gpu_settings(self, gpu_enabled: bool, memory_limit: float):\n        \"\"\"Met √† jour sp√©cifiquement les param√®tres GPU\"\"\"\n        self.gpu_enabled = gpu_enabled\n        self.config.gpu_enabled = gpu_enabled\n        \n        if hasattr(self, 'accelerator') and self.accelerator:\n            self.accelerator.update_config(gpu_enabled, memory_limit)\n            \n        self.logger.info(f\"Param√®tres GPU mis √† jour: enabled={gpu_enabled}, memory={memory_limit*100:.0f}%\")\n    \n    def _setup_compute_device(self):\n        \"\"\"Configure le device optimal pour les calculs\"\"\"\n        if not TORCH_AVAILABLE:\n            return \"cpu\"\n        \n        # V√©rifier disponibilit√© GPU\n        if torch.cuda.is_available():\n            device = torch.device(\"cuda:0\")\n            gpu_props = torch.cuda.get_device_properties(0)\n            self.logger.info(f\"GPU d√©tect√©: {gpu_props.name} ({gpu_props.total_memory // 1024**2} MB)\")\n            return device\n        else:\n            device = torch.device(\"cpu\")\n            self.logger.info(f\"Utilisation CPU optimis√©: {mp.cpu_count()} threads\")\n            return device\n    \n    def set_gpu_enabled(self, enabled: bool, memory_limit: float = 0.8):\n        \"\"\"Active/d√©sactive l'utilisation du GPU\"\"\"\n        self.gpu_enabled = enabled and torch.cuda.is_available() if TORCH_AVAILABLE else False\n        self.gpu_memory_limit = memory_limit\n        \n        if self.gpu_enabled:\n            self.device = torch.device(\"cuda:0\")\n            # Limiter l'utilisation m√©moire GPU\n            torch.cuda.set_per_process_memory_fraction(memory_limit)\n            self.logger.info(f\"GPU activ√© avec limite m√©moire: {memory_limit*100:.0f}%\")\n        else:\n            self.device = torch.device(\"cpu\")\n            self.logger.info(\"Utilisation CPU forc√©e\")\n        \n        # Vider les caches\n        self._clear_tensor_cache()\n    \n    def _clear_tensor_cache(self):\n        \"\"\"Vide les caches de tenseurs\"\"\"\n        self._tensor_cache.clear()\n        self._computation_cache.clear()\n        if self.gpu_enabled and torch.cuda.is_available():\n            torch.cuda.empty_cache()\n    \n    def get_gpu_memory_usage(self):\n        \"\"\"Retourne l'utilisation m√©moire GPU\"\"\"\n        if not self.gpu_enabled or not torch.cuda.is_available():\n            return {\"available\": False, \"used\": 0, \"total\": 0}\n        \n        used = torch.cuda.memory_allocated() / 1024**2\n        total = torch.cuda.get_device_properties(0).total_memory / 1024**2\n        return {\n            \"available\": True,\n            \"used\": used,\n            \"total\": total,\n            \"percent\": (used / total) * 100\n        }\n    \n    def compute_strategy_regrets(self, utilities, strategy_probs):\n        \"\"\"Calcul optimis√© des regrets avec acc√©l√©ration GPU prioritaire\"\"\"\n        if self.gpu_accelerator and len(utilities) > 50:  # Seuil abaiss√© pour plus d'usage GPU\n            # Utiliser l'acc√©l√©rateur GPU pour la majorit√© des calculs\n            utilities_batch = utilities.reshape(1, -1)\n            strategy_batch = strategy_probs.reshape(1, -1)\n            regrets = self.gpu_accelerator.compute_regrets_batch(utilities_batch, strategy_batch)\n            return regrets.flatten()\n        else:\n            # Utiliser Numba pour tr√®s petits calculs uniquement\n            return self._compute_regrets_numba(utilities, strategy_probs)\n    \n    @jit(nopython=True)\n    def _compute_regrets_numba(self, utilities, strategy_probs):\n        \"\"\"Calcul optimis√© des regrets avec Numba\"\"\"\n        regrets = np.zeros_like(utilities)\n        ev = np.sum(utilities * strategy_probs)\n        \n        for i in prange(len(utilities)):\n            regrets[i] = utilities[i] - ev\n        \n        return regrets\n    \n    def compute_nash_equilibrium_fast(self, payoff_matrix, max_iterations=1000):\n        \"\"\"Calcul √©quilibre de Nash avec acc√©l√©ration\"\"\"\n        if self.gpu_accelerator:\n            return self.gpu_accelerator.compute_nash_equilibrium(payoff_matrix, max_iterations)\n        else:\n            # Fallback vers m√©thode traditionnelle\n            return self._compute_nash_traditional(payoff_matrix, max_iterations)\n    \n    def _compute_nash_traditional(self, payoff_matrix, max_iterations):\n        \"\"\"Calcul Nash traditionnel\"\"\"\n        n_actions = payoff_matrix.shape[0]\n        strategy = np.ones(n_actions) / n_actions\n        \n        for iteration in range(max_iterations):\n            expected_utilities = np.dot(payoff_matrix, strategy)\n            \n            best_response = np.zeros(n_actions)\n            best_action = np.argmax(expected_utilities)\n            best_response[best_action] = 1.0\n            \n            alpha = 1.0 / (iteration + 1)\n            strategy = (1 - alpha) * strategy + alpha * best_response\n            \n            if iteration % 100 == 0:\n                exploitability = np.max(expected_utilities) - np.sum(strategy * expected_utilities)\n                if exploitability < 1e-6:\n                    break\n        \n        return strategy\n    \n    def _init_gpu_accelerator(self):\n        \"\"\"Initialise l'acc√©l√©rateur GPU/CPU\"\"\"\n        try:\n            from .gpu_accelerator import GPUAccelerator, AccelerationConfig\n            \n            config = AccelerationConfig(\n                gpu_enabled=self.gpu_enabled,\n                gpu_memory_limit=self.gpu_memory_limit,\n                cpu_threads=self.cpu_threads\n            )\n            \n            self.gpu_accelerator = GPUAccelerator(config)\n            self.logger.info(\"Acc√©l√©rateur GPU/CPU initialis√©\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur initialisation acc√©l√©rateur: {e}\")\n            self.gpu_accelerator = None\n    \n    def update_gpu_settings(self, gpu_enabled: bool, memory_limit: float):\n        \"\"\"Met √† jour les param√®tres GPU depuis l'interface\"\"\"\n        self.set_gpu_enabled(gpu_enabled, memory_limit)\n        \n        if self.gpu_accelerator:\n            self.gpu_accelerator.update_config(gpu_enabled, memory_limit)\n            self.logger.info(f\"Param√®tres GPU mis √† jour: enabled={gpu_enabled}, memory={memory_limit*100:.0f}%\")\n    \n    def get_acceleration_stats(self):\n        \"\"\"Retourne les statistiques d'acc√©l√©ration\"\"\"\n        if self.gpu_accelerator:\n            return self.gpu_accelerator.get_performance_stats()\n        return {}\n    \n    def init_trainer(self):\n        \"\"\"Initialise l'entra√Æneur CFR (s√©par√© pour √©viter import circulaire)\"\"\"\n        try:\n            from .cfr_trainer import CFRTrainer\n            self.cfr_trainer = CFRTrainer(self)\n            \n            # Chargement automatique des mains historiques\n            self._load_historical_hands()\n            \n            # D√©marrage de l'entra√Ænement automatique\n            if self.auto_training_enabled and not self.training_target_reached:\n                self._start_auto_training()\n                \n            # D√©marrage de la g√©n√©ration continue\n            self._start_continuous_generation()\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur initialisation trainer: {e}\")\n    \n    def _load_historical_hands(self):\n        \"\"\"Charge automatiquement les mains historiques disponibles\"\"\"\n        try:\n            import os\n            hand_files = []\n            \n            # Recherche des fichiers de mains dans attached_assets\n            assets_dir = \"attached_assets\"\n            if os.path.exists(assets_dir):\n                for file in os.listdir(assets_dir):\n                    if file.startswith(\"All_Hands_part\") and file.endswith(\".txt\"):\n                        hand_files.append(os.path.join(assets_dir, file))\n            \n            if hand_files and self.cfr_trainer:\n                self.logger.info(f\"Chargement de {len(hand_files)} fichiers de mains...\")\n                total_loaded = self.cfr_trainer.load_historical_hands(hand_files)\n                self.logger.info(f\"Charg√© {total_loaded} mains historiques\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur chargement mains historiques: {e}\")\n    \n    def _start_auto_training(self):\n        \"\"\"D√©marre l'entra√Ænement automatique en arri√®re-plan\"\"\"\n        try:\n            if self.cfr_trainer:\n                # G√©n√©ration de dataset suppl√©mentaire si n√©cessaire\n                if len(self.cfr_trainer.training_hands) < 50000:\n                    self.logger.info(\"G√©n√©ration de mains suppl√©mentaires pour entra√Ænement...\")\n                    self.cfr_trainer.generate_training_dataset(200000)\n                \n                # D√©marrage entra√Ænement intensif\n                self.logger.info(\"D√©marrage entra√Ænement CFR automatique...\")\n                success = self.cfr_trainer.start_intensive_training(\n                    target_iterations=100000,\n                    target_convergence=0.01\n                )\n                \n                if success:\n                    self.logger.info(\"Entra√Ænement CFR d√©marr√© avec succ√®s\")\n                else:\n                    self.logger.warning(\"Impossible de d√©marrer l'entra√Ænement CFR\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur d√©marrage auto-training: {e}\")\n    \n    def _start_continuous_generation(self):\n        \"\"\"D√©marre la g√©n√©ration continue de mains en arri√®re-plan\"\"\"\n        try:\n            if self.cfr_trainer and self.cfr_trainer.continuous_generator:\n                self.cfr_trainer.start_continuous_generation()\n                self.logger.info(\"G√©n√©ration continue de mains activ√©e\")\n        except Exception as e:\n            self.logger.error(f\"Erreur g√©n√©ration continue: {e}\")\n    \n    def get_training_progress(self) -> Dict[str, Any]:\n        \"\"\"Retourne les informations de progression de l'entra√Ænement\"\"\"\n        if self.cfr_trainer:\n            stats = self.cfr_trainer.get_training_statistics()\n            return {\n                'training_active': stats['is_training'],\n                'iterations': stats['iterations'],\n                'target_iterations': stats['target_iterations'],\n                'progress_percent': stats['progress_percentage'],\n                'quality': stats['current_quality'],\n                'confidence': min(100, stats['current_quality'] * 100),\n                'convergence': stats['last_convergence'],\n                'training_hands': stats['training_hands'],\n                'info_sets': stats['info_sets_learned']\n            }\n        else:\n            return {\n                'training_active': False,\n                'iterations': self.iterations,\n                'target_iterations': 0,\n                'progress_percent': 0,\n                'quality': 0.0,\n                'confidence': 0,\n                'convergence': 1.0,\n                'training_hands': 0,\n                'info_sets': 0\n            }\n    \n    def get_recommendation(self, game_state) -> Dict[str, Any]:\n        \"\"\"Retourne une recommandation bas√©e sur CFR/Nash\"\"\"\n        try:\n            with self.calculation_lock:\n                # Conversion en √©tat poker\n                poker_state = self._convert_to_poker_state(game_state)\n                \n                # Calcul de l'information set\n                info_set = self._get_information_set(poker_state)\n                \n                # Obtention de la strat√©gie\n                strategy = self._get_strategy(info_set, poker_state)\n                \n                # Calcul des probabilit√©s de victoire\n                win_probability = self._calculate_win_probability(poker_state)\n                \n                # Calcul de la valeur esp√©r√©e pour chaque action\n                action_values = self._calculate_action_values(poker_state, strategy)\n                \n                # S√©lection de l'action optimale\n                best_action = max(action_values.items(), key=lambda x: x[1])\n                \n                # Calcul du niveau de risque\n                risk_level = self._calculate_risk_level(poker_state, best_action[0])\n                \n                # Calcul de confiance bas√© sur les m√©triques CFR r√©elles\n                confidence = self._calculate_cfr_confidence(info_set, strategy)\n                \n                # Construction de la recommandation\n                recommendation = {\n                    'action_type': best_action[0],\n                    'bet_size': self._get_bet_size(best_action[0], poker_state),\n                    'win_probability': win_probability,\n                    'expected_value': best_action[1],\n                    'risk_level': risk_level,\n                    'confidence': confidence,\n                    'reasoning': self._generate_reasoning(poker_state, best_action[0], strategy),\n                    'alternative_actions': self._get_alternative_actions(action_values),\n                    'timestamp': time.time()\n                }\n                \n                return recommendation\n                \n        except KeyError as e:\n            self.logger.error(f\"Erreur donn√©es manquantes pour recommandation: {e}\")\n            return self._get_default_recommendation()\n        except ValueError as e:\n            self.logger.error(f\"Erreur valeur invalide dans calcul CFR: {e}\")\n            return self._get_default_recommendation()\n        except ZeroDivisionError as e:\n            self.logger.error(f\"Erreur division par z√©ro dans calculs: {e}\")\n            return self._get_default_recommendation()\n        except Exception as e:\n            self.logger.error(f\"Erreur inattendue calcul recommandation: {e}\")\n            import traceback\n            self.logger.debug(f\"Traceback: {traceback.format_exc()}\")\n            return self._get_default_recommendation()\n    \n    def _convert_to_poker_state(self, game_state) -> PokerState:\n        \"\"\"Convertit l'√©tat de jeu en √©tat poker avec validation\"\"\"\n        try:\n            # Validation des donn√©es critiques\n            if not hasattr(game_state, 'hero_cards') or not game_state.hero_cards:\n                raise ValueError(\"Cartes h√©ros manquantes\")\n            \n            if not hasattr(game_state, 'pot_size') or game_state.pot_size < 0:\n                raise ValueError(\"Taille pot invalide\")\n            \n            if not hasattr(game_state, 'hero_stack') or game_state.hero_stack < 0:\n                raise ValueError(\"Stack h√©ros invalide\")\n            \n            # D√©termination de la street\n            board_count = len(game_state.board_cards) if game_state.board_cards else 0\n            if board_count == 0:\n                street = 0  # preflop\n            elif board_count == 3:\n                street = 1  # flop\n            elif board_count == 4:\n                street = 2  # turn\n            else:\n                street = 3  # river\n            \n            return PokerState(\n                street=street,\n                hero_cards=game_state.hero_cards,\n                board_cards=game_state.board_cards or [],\n                pot_size=float(game_state.pot_size),\n                hero_stack=float(game_state.hero_stack),\n                position=getattr(game_state, 'hero_position', 0),\n                num_players=getattr(game_state, 'players_count', 9),\n                current_bet=float(getattr(game_state, 'current_bet', 0)),\n                action_history=[],  # √Ä impl√©menter\n                table_type=getattr(game_state, 'table_type', 'cashgame')\n            )\n        except (AttributeError, TypeError, ValueError) as e:\n            self.logger.error(f\"Erreur conversion √©tat poker: {e}\")\n            # Retourner un √©tat par d√©faut plut√¥t que d'√©chouer\n            return self._get_default_poker_state()\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur conversion √©tat: {e}\")\n            return PokerState(0, (\"\", \"\"), [], 0, 0, 0, 9, 0, [], \"cashgame\")\n    \n    def _get_information_set(self, poker_state: PokerState) -> str:\n        \"\"\"Calcule l'information set pour CFR\"\"\"\n        try:\n            # Abstraction des cartes\n            card_bucket = self.card_abstraction.get_bucket(\n                poker_state.hero_cards, \n                poker_state.board_cards,\n                poker_state.street\n            )\n            \n            # √âtat abstrait du jeu\n            bet_history = \"_\".join(poker_state.action_history[-10:])  # Derni√®res 10 actions\n            \n            # SPR (Stack to Pot Ratio)\n            spr = poker_state.hero_stack / max(poker_state.pot_size, 1.0)\n            spr_bucket = min(int(spr), 20)  # Cap √† 20\n            \n            # Information set\n            info_set = f\"{poker_state.street}_{card_bucket}_{poker_state.position}_{spr_bucket}_{bet_history}\"\n            \n            return info_set\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur information set: {e}\")\n            return \"default_0_0_0_0_\"\n    \n    def _get_strategy(self, info_set: str, poker_state: PokerState) -> Dict[str, float]:\n        \"\"\"Calcule la strat√©gie pour un information set\"\"\"\n        try:\n            actions = self._get_available_actions(poker_state)\n            \n            if info_set not in self.regret_sum:\n                # Strat√©gie uniforme pour nouveau info_set\n                uniform_prob = 1.0 / len(actions)\n                return {action: uniform_prob for action in actions}\n            \n            # Calcul de la strat√©gie bas√©e sur les regrets\n            strategy = {}\n            regret_sum = 0.0\n            \n            for action in actions:\n                regret = max(0.0, self.regret_sum[info_set][action])\n                strategy[action] = regret\n                regret_sum += regret\n            \n            # Normalisation\n            if regret_sum > 0:\n                for action in actions:\n                    strategy[action] /= regret_sum\n            else:\n                # Strat√©gie uniforme si pas de regret positif\n                uniform_prob = 1.0 / len(actions)\n                strategy = {action: uniform_prob for action in actions}\n            \n            # Ajout d'exploration\n            for action in actions:\n                strategy[action] = (1.0 - self.exploration_rate) * strategy[action] + \\\n                                 self.exploration_rate / len(actions)\n            \n            return strategy\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur calcul strat√©gie: {e}\")\n            return {\"fold\": 0.3, \"call\": 0.4, \"raise\": 0.3}\n    \n    def _get_available_actions(self, poker_state: PokerState) -> List[str]:\n        \"\"\"Retourne les actions disponibles\"\"\"\n        try:\n            actions = []\n            \n            # Fold toujours disponible (sauf si check possible)\n            if poker_state.current_bet > 0:\n                actions.append(\"fold\")\n            \n            # Check/Call\n            if poker_state.current_bet == 0:\n                actions.append(\"check\")\n            else:\n                actions.append(\"call\")\n            \n            # Bet/Raise si stack suffisant\n            min_bet = max(poker_state.current_bet * 2, poker_state.pot_size * 0.25)\n            if poker_state.hero_stack > min_bet:\n                actions.extend([\"bet_small\", \"bet_medium\", \"bet_large\", \"bet_allin\"])\n            \n            return actions\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur actions disponibles: {e}\")\n            return [\"fold\", \"call\", \"raise\"]\n    \n    def _calculate_win_probability(self, poker_state: PokerState) -> float:\n        \"\"\"Calcule la probabilit√© de victoire\"\"\"\n        try:\n            # Cache check\n            cache_key = f\"{poker_state.hero_cards}_{poker_state.board_cards}_{poker_state.num_players}\"\n            if cache_key in self.equity_cache:\n                return self.equity_cache[cache_key]\n            \n            # Simulation Monte Carlo rapide\n            wins = 0\n            simulations = 1000  # R√©duit pour temps r√©el\n            \n            for _ in range(simulations):\n                # Simulation d'une main compl√®te\n                if self._simulate_hand(poker_state):\n                    wins += 1\n            \n            win_prob = wins / simulations\n            self.equity_cache[cache_key] = win_prob\n            \n            return win_prob\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur calcul probabilit√©: {e}\")\n            return 0.5  # Valeur par d√©faut\n    \n    def _simulate_hand(self, poker_state: PokerState) -> bool:\n        \"\"\"Simule une main compl√®te\"\"\"\n        try:\n            # Simulation simplifi√©e bas√©e sur la force des cartes\n            hero_strength = self._calculate_hand_strength(\n                poker_state.hero_cards, \n                poker_state.board_cards\n            )\n            \n            # Estimation de la force moyenne des adversaires\n            avg_opponent_strength = 0.4 + (0.1 * (9 - poker_state.num_players))\n            \n            return hero_strength > avg_opponent_strength\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur simulation main: {e}\")\n            return False\n    \n    def _calculate_hand_strength(self, hero_cards: Tuple[str, str], board_cards: List[str]) -> float:\n        \"\"\"Calcule la force de la main (0-1)\"\"\"\n        try:\n            if not hero_cards or hero_cards == (\"\", \"\"):\n                return 0.0\n            \n            # √âvaluation simplifi√©e bas√©e sur les cartes hautes\n            card_values = {'A': 14, 'K': 13, 'Q': 12, 'J': 11, 'T': 10}\n            \n            strength = 0.0\n            \n            # Force des cartes individuelles\n            for card in hero_cards:\n                if card and len(card) >= 2:\n                    rank = card[0]\n                    value = card_values.get(rank, int(rank) if rank.isdigit() else 5)\n                    strength += value / 14.0\n            \n            strength /= 2.0  # Moyenne des deux cartes\n            \n            # Bonus pour paires, couleurs, etc. (√† am√©liorer)\n            if hero_cards[0][0] == hero_cards[1][0]:  # Paire\n                strength += 0.2\n            \n            if hero_cards[0][1] == hero_cards[1][1]:  # Suited\n                strength += 0.05\n            \n            return min(strength, 1.0)\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur force main: {e}\")\n            return 0.0\n    \n    def _calculate_action_values(self, poker_state: PokerState, strategy: Dict[str, float]) -> Dict[str, float]:\n        \"\"\"Calcule les valeurs esp√©r√©es pour chaque action\"\"\"\n        try:\n            action_values = {}\n            \n            for action, probability in strategy.items():\n                # Calcul EV simplifi√© pour chaque action\n                if action == \"fold\":\n                    action_values[action] = 0.0\n                elif action in [\"check\", \"call\"]:\n                    win_prob = self._calculate_win_probability(poker_state)\n                    call_amount = poker_state.current_bet\n                    pot_odds = call_amount / (poker_state.pot_size + call_amount)\n                    action_values[action] = (win_prob - pot_odds) * poker_state.pot_size\n                else:  # bet/raise\n                    action_values[action] = self._calculate_bet_ev(poker_state, action)\n            \n            return action_values\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur valeurs actions: {e}\")\n            return {\"fold\": 0.0, \"call\": 0.0, \"raise\": 0.0}\n    \n    def _calculate_bet_ev(self, poker_state: PokerState, action: str) -> float:\n        \"\"\"Calcule l'EV d'un bet/raise\"\"\"\n        try:\n            win_prob = self._calculate_win_probability(poker_state)\n            \n            # Taille du bet selon l'action\n            bet_size_multipliers = {\n                \"bet_small\": 0.33,\n                \"bet_medium\": 0.66,\n                \"bet_large\": 1.0,\n                \"bet_allin\": min(poker_state.hero_stack / poker_state.pot_size, 3.0)\n            }\n            \n            multiplier = bet_size_multipliers.get(action, 0.66)\n            bet_amount = poker_state.pot_size * multiplier\n            \n            # Probabilit√© de fold des adversaires (estimation)\n            fold_prob = min(0.6 * multiplier, 0.8)\n            \n            # EV = (fold_prob * pot_actuel) + ((1-fold_prob) * win_prob * pot_final) - bet_amount\n            immediate_win = fold_prob * poker_state.pot_size\n            showdown_ev = (1 - fold_prob) * win_prob * (poker_state.pot_size + bet_amount * 2)\n            \n            total_ev = immediate_win + showdown_ev - bet_amount\n            \n            return total_ev\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur EV bet: {e}\")\n            return 0.0\n    \n    def _get_bet_size(self, action: str, poker_state: PokerState) -> float:\n        \"\"\"Retourne la taille du bet pour une action\"\"\"\n        try:\n            if action in [\"fold\", \"check\"]:\n                return 0.0\n            elif action == \"call\":\n                return poker_state.current_bet\n            elif action == \"bet_small\":\n                return poker_state.pot_size * 0.33\n            elif action == \"bet_medium\":\n                return poker_state.pot_size * 0.66\n            elif action == \"bet_large\":\n                return poker_state.pot_size * 1.0\n            elif action == \"bet_allin\":\n                return poker_state.hero_stack\n            else:\n                return poker_state.pot_size * 0.5\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur taille bet: {e}\")\n            return 0.0\n    \n    def _calculate_risk_level(self, poker_state: PokerState, action: str) -> float:\n        \"\"\"Calcule le niveau de risque (0-100)\"\"\"\n        try:\n            base_risk = 0.0\n            \n            if action == \"fold\":\n                base_risk = 0.0\n            elif action in [\"check\", \"call\"]:\n                base_risk = 30.0\n            elif action.startswith(\"bet\"):\n                bet_size = self._get_bet_size(action, poker_state)\n                risk_ratio = bet_size / poker_state.hero_stack\n                base_risk = 50.0 + (risk_ratio * 50.0)\n            \n            # Ajustements selon le contexte\n            if poker_state.table_type == \"tournament\":\n                base_risk *= 1.2  # Plus risqu√© en tournoi\n            \n            # Ajustement selon la position pour 9-max\n            if poker_state.position <= 2:  # UTG, UTG+1, MP1 (early position)\n                base_risk *= 1.15\n            elif poker_state.position == 6:  # Button\n                base_risk *= 0.9  # Moins risqu√© au button\n            elif poker_state.position == 7:  # Small Blind  \n                base_risk *= 1.1  # Plus risqu√© SB\n            elif poker_state.position == 8:  # Big Blind\n                base_risk *= 1.05  # L√©g√®rement plus risqu√© BB\n            \n            return min(base_risk, 100.0)\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur niveau risque: {e}\")\n            return 50.0\n    \n    def _calculate_cfr_confidence(self, info_set: str, strategy: Dict[str, float]) -> float:\n        \"\"\"Calcule la confiance bas√©e sur les m√©triques CFR r√©elles\"\"\"\n        try:\n            # Progression de l'entra√Ænement depuis les m√©triques CFR trainer\n            training_progress = self.get_training_progress()\n            \n            # Facteurs de confiance\n            iteration_factor = min(1.0, training_progress['iterations'] / 10000)  # Converge vers 1 √† 10k it√©rations\n            quality_factor = training_progress['quality']  # Qualit√© des strat√©gies\n            convergence_factor = max(0.0, 1.0 - training_progress['convergence'])  # Inverse de convergence\n            \n            # Facteur sp√©cifique √† cet information set\n            info_set_factor = 1.0\n            if info_set in self.strategy_sum and self.strategy_sum[info_set]:\n                # Plus l'info set a √©t√© vu, plus on a confiance\n                total_visits = sum(self.strategy_sum[info_set].values())\n                info_set_factor = min(1.0, total_visits / 100)  # Converge √† 100 visites\n            \n            # Facteur de coh√©rence de la strat√©gie\n            strategy_coherence = self._calculate_strategy_coherence(strategy)\n            \n            # Calcul de confiance combin√© (0-100%)\n            base_confidence = (\n                iteration_factor * 0.3 +      # 30% bas√© sur nombre d'it√©rations\n                quality_factor * 0.25 +       # 25% bas√© sur qualit√© g√©n√©rale\n                convergence_factor * 0.25 +   # 25% bas√© sur convergence\n                info_set_factor * 0.15 +      # 15% bas√© sur exp√©rience de cette situation\n                strategy_coherence * 0.05     # 5% bas√© sur coh√©rence de strat√©gie\n            )\n            \n            confidence_percent = min(100, max(0, base_confidence * 100))\n            \n            # Bonus pour entra√Ænement intensif actif\n            if training_progress['training_active']:\n                confidence_percent = min(100, confidence_percent + 5)\n            \n            return confidence_percent\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur calcul confiance CFR: {e}\")\n            # Fallback sur ancien calcul de confiance\n            return self._calculate_confidence_fallback(strategy)\n    \n    def _calculate_strategy_coherence(self, strategy: Dict[str, float]) -> float:\n        \"\"\"Calcule la coh√©rence d'une strat√©gie (moins al√©atoire = plus coh√©rent)\"\"\"\n        if not strategy or len(strategy) <= 1:\n            return 1.0\n        \n        # Calcul de l'entropie normalis√©e\n        entropy = 0.0\n        for prob in strategy.values():\n            if prob > 0:\n                entropy -= prob * np.log2(prob)\n        \n        max_entropy = np.log2(len(strategy))\n        if max_entropy == 0:\n            return 1.0\n        \n        # Coh√©rence = inverse de l'entropie normalis√©e\n        coherence = 1.0 - (entropy / max_entropy)\n        return max(0.0, min(1.0, coherence))\n    \n    def _calculate_confidence_fallback(self, strategy: Dict[str, float]) -> float:\n        \"\"\"Calcule la confiance dans la strat√©gie\"\"\"\n        try:\n            # Entropie comme mesure de confiance (invers√©e)\n            entropy = 0.0\n            for prob in strategy.values():\n                if prob > 0:\n                    entropy -= prob * math.log2(prob)\n            \n            # Normalisation (max entropy pour 3 actions = log2(3) ‚âà 1.58)\n            max_entropy = math.log2(len(strategy))\n            normalized_entropy = entropy / max_entropy if max_entropy > 0 else 0\n            \n            # Confiance = 1 - entropy normalis√©e\n            confidence = (1.0 - normalized_entropy) * 100.0\n            \n            return confidence\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur confiance: {e}\")\n            return 50.0\n    \n    def _generate_reasoning(self, poker_state: PokerState, action: str, strategy: Dict[str, float]) -> str:\n        \"\"\"G√©n√®re une explication de la recommandation\"\"\"\n        try:\n            reasoning_parts = []\n            \n            # Analyse de la main\n            hand_strength = self._calculate_hand_strength(poker_state.hero_cards, poker_state.board_cards)\n            if hand_strength > 0.7:\n                reasoning_parts.append(\"Main forte\")\n            elif hand_strength > 0.4:\n                reasoning_parts.append(\"Main moyenne\")\n            else:\n                reasoning_parts.append(\"Main faible\")\n            \n            # Analyse de position pour 9-max (0-8)\n            # 0=UTG, 1=UTG+1, 2=MP1, 3=MP2, 4=MP3, 5=CO, 6=BTN, 7=SB, 8=BB\n            if poker_state.position <= 2:  # UTG, UTG+1, MP1\n                reasoning_parts.append(\"position pr√©coce\")\n            elif poker_state.position <= 5:  # MP2, MP3, CO\n                reasoning_parts.append(\"position milieu\") \n            elif poker_state.position == 6:  # BTN\n                reasoning_parts.append(\"button\")\n            elif poker_state.position == 7:  # SB\n                reasoning_parts.append(\"small blind\")\n            else:  # BB\n                reasoning_parts.append(\"big blind\")\n            \n            # Analyse du pot\n            spr = poker_state.hero_stack / max(poker_state.pot_size, 1.0)\n            if spr < 5:\n                reasoning_parts.append(\"SPR faible\")\n            elif spr > 15:\n                reasoning_parts.append(\"SPR √©lev√©\")\n            \n            # Construction du message\n            base_msg = f\"Recommandation {action} bas√©e sur: {', '.join(reasoning_parts)}\"\n            \n            return base_msg\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur g√©n√©ration raisonnement: {e}\")\n            return f\"Recommandation {action} bas√©e sur l'analyse CFR\"\n    \n    def _get_alternative_actions(self, action_values: Dict[str, float]) -> List[Dict[str, Any]]:\n        \"\"\"Retourne les actions alternatives\"\"\"\n        try:\n            sorted_actions = sorted(action_values.items(), key=lambda x: x[1], reverse=True)\n            \n            alternatives = []\n            for i, (action, value) in enumerate(sorted_actions[1:3]):  # Top 2 alternatives\n                alternatives.append({\n                    'action': action,\n                    'expected_value': value,\n                    'rank': i + 2\n                })\n            \n            return alternatives\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur actions alternatives: {e}\")\n            return []\n    \n    def _get_default_recommendation(self) -> Dict[str, Any]:\n        \"\"\"Retourne une recommandation par d√©faut en cas d'erreur\"\"\"\n        return {\n            'action_type': 'check',\n            'bet_size': 0.0,\n            'win_probability': 50.0,\n            'expected_value': 0.0,\n            'risk_level': 30.0,\n            'confidence': 25.0,\n            'reasoning': 'Recommandation de s√©curit√© (erreur de calcul)',\n            'alternative_actions': [],\n            'timestamp': time.time()\n        }\n    \n    def _get_default_poker_state(self) -> 'PokerState':\n        \"\"\"Retourne un √©tat poker par d√©faut en cas d'erreur\"\"\"\n        from ..utils.data_structures import PokerState\n        return PokerState(\n            street=0,  # preflop\n            hero_cards=(\"Ah\", \"Kh\"),  # Cartes par d√©faut\n            board_cards=[],\n            pot_size=100.0,\n            hero_stack=1000.0,\n            position=0,\n            num_players=9,\n            current_bet=0.0,\n            action_history=[],\n            table_type='cashgame'\n        )\n    \n    def update_settings(self, settings: Dict[str, Any]):\n        \"\"\"Met √† jour les param√®tres CFR\"\"\"\n        try:\n            if 'cfr_iterations' in settings:\n                self.iterations = settings['cfr_iterations']\n            \n            if 'exploration_rate' in settings:\n                self.exploration_rate = settings['exploration_rate']\n            \n            if 'deep_cfr_enabled' in settings:\n                self.deep_cfr_enabled = settings['deep_cfr_enabled']\n            \n            # Support GPU dynamique\n            if 'gpu_enabled' in settings:\n                self.gpu_enabled = settings['gpu_enabled']\n                self.config.gpu_enabled = settings['gpu_enabled']\n                \n                # Mettre √† jour l'acc√©l√©rateur GPU\n                if hasattr(self, 'accelerator') and self.accelerator:\n                    gpu_memory = settings.get('gpu_memory_limit', 80) / 100.0\n                    self.accelerator.update_config(self.gpu_enabled, gpu_memory)\n                \n                if not self.gpu_enabled:\n                    self.logger.info(\"Utilisation CPU forc√©e\")\n                else:\n                    self.logger.info(\"GPU activ√© pour acc√©l√©ration\")\n            \n            self.logger.info(\"Param√®tres CFR mis √† jour\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur mise √† jour param√®tres: {e}\")\n    \n    def start_background_training(self):\n        \"\"\"D√©marre l'entra√Ænement CFR en arri√®re-plan\"\"\"\n        if not self.is_running:\n            self.is_running = True\n            self.background_thread = threading.Thread(target=self._training_loop, daemon=True)\n            self.background_thread.start()\n            self.logger.info(\"Entra√Ænement CFR d√©marr√© en arri√®re-plan\")\n    \n    def stop_background_training(self):\n        \"\"\"Arr√™te l'entra√Ænement en arri√®re-plan\"\"\"\n        self.is_running = False\n        if self.background_thread:\n            self.background_thread.join(timeout=1.0)\n        self.logger.info(\"Entra√Ænement CFR arr√™t√©\")\n    \n    def _training_loop(self):\n        \"\"\"Boucle d'entra√Ænement CFR continu\"\"\"\n        while self.is_running:\n            try:\n                # Mise √† jour CFR+ (version simplifi√©e)\n                self._update_regrets()\n                time.sleep(0.1)  # 100ms entre les mises √† jour\n                \n            except Exception as e:\n                self.logger.error(f\"Erreur boucle entra√Ænement: {e}\")\n                time.sleep(1.0)\n    \n    def _update_regrets(self):\n        \"\"\"Met √† jour les regrets CFR+ (impl√©mentation simplifi√©e)\"\"\"\n        try:\n            # Ici on devrait faire une travers√©e CFR compl√®te\n            # Pour l'instant, on fait une mise √† jour l√©g√®re\n            self.iterations += 1\n            self.iterations_count = self.iterations  # Synchronisation\n            \n            # D√©croissance des regrets anciens\n            if self.iterations % 100 == 0:\n                for info_set in self.regret_sum:\n                    for action in self.regret_sum[info_set]:\n                        self.regret_sum[info_set][action] *= self.discount_factor\n                        \n        except Exception as e:\n            self.logger.error(f\"Erreur mise √† jour regrets: {e}\")\n\nclass CardAbstraction:\n    \"\"\"Abstraction des cartes pour CFR\"\"\"\n    \n    def __init__(self):\n        self.buckets = 64  # Nombre de buckets\n        \n    def get_bucket(self, hero_cards: Tuple[str, str], board_cards: List[str], street: int) -> int:\n        \"\"\"Retourne le bucket d'abstraction pour les cartes\"\"\"\n        try:\n            # Impl√©mentation simplifi√©e\n            # En pratique, on utiliserait k-means sur les √©quit√©s\n            \n            if not hero_cards or hero_cards == (\"\", \"\"):\n                return 0\n            \n            # Hash simple bas√© sur les cartes\n            card_hash = hash(str(hero_cards) + str(board_cards))\n            return abs(card_hash) % self.buckets\n            \n        except Exception as e:\n            return 0\n\nclass ActionAbstraction:\n    \"\"\"Abstraction des actions pour CFR\"\"\"\n    \n    def __init__(self):\n        self.bet_sizes = [0.25, 0.5, 0.75, 1.0, 1.5, 2.0]  # Multiples du pot\n        \n    def get_abstract_action(self, action: str, bet_size: float, pot_size: float) -> str:\n        \"\"\"Convertit une action r√©elle en action abstraite\"\"\"\n        try:\n            if action in [\"fold\", \"check\", \"call\"]:\n                return action\n            \n            # Abstraction des bet sizes\n            if pot_size > 0:\n                ratio = bet_size / pot_size\n                closest_size = min(self.bet_sizes, key=lambda x: abs(x - ratio))\n                return f\"bet_{closest_size}\"\n            \n            return \"bet_0.5\"\n            \n        except Exception as e:\n            return action","size_bytes":44295},"src/config/__init__.py":{"content":"# Config module","size_bytes":15},"src/config/settings.py":{"content":"\"\"\"\nGestion des param√®tres de RTPA Studio\n\"\"\"\n\nimport yaml\nimport os\nfrom pathlib import Path\nfrom typing import Dict, Any\nfrom dataclasses import dataclass, field\n\nfrom ..utils.logger import get_logger\n\n@dataclass\nclass Settings:\n    \"\"\"Param√®tres de configuration de RTPA Studio\"\"\"\n    \n    # Param√®tres g√©n√©raux\n    language: str = \"fr\"  # fr ou en\n    risk_percentage: float = 50.0  # Pourcentage de risque par d√©faut\n    manual_risk_override: bool = False\n    \n    # Param√®tres OCR\n    ocr_enabled: bool = True\n    ocr_interval_ms: int = 100\n    ocr_confidence_threshold: float = 0.8\n    screen_region: Dict[str, int] = field(default_factory=lambda: {\"x\": 0, \"y\": 0, \"width\": 1920, \"height\": 1080})\n    \n    # Param√®tres CFR/Nash\n    cfr_iterations: int = 1000\n    cfr_sampling_enabled: bool = True\n    nash_calculation_interval_ms: int = 50\n    abstraction_buckets: int = 64\n    \n    # Param√®tres de performance\n    cpu_usage_limit: float = 80.0  # Pourcentage max CPU\n    ram_usage_limit: float = 70.0  # Pourcentage max RAM\n    gpu_enabled: bool = True\n    gpu_memory_limit: float = 80.0  # Pourcentage max GPU\n    auto_resource_management: bool = True\n    \n    # Param√®tres de jeu\n    default_table_type: str = \"cashgame\"  # cashgame ou tournament\n    max_players: int = 9\n    target_hands_per_100: int = 65  # Objectif de mains gagn√©es\n    auto_hand_target: bool = True\n    \n    # Param√®tres d'affichage\n    show_probabilities: bool = True\n    show_recommendations: bool = True\n    show_statistics: bool = True\n    theme: str = \"dark\"  # dark ou light\n    \n    # Fichier de configuration\n    config_file: Path = field(default_factory=lambda: Path(\"config/settings.yaml\"))\n    \n    def __post_init__(self):\n        self.logger = get_logger(__name__)\n        self.load_from_file()\n    \n    def load_from_file(self):\n        \"\"\"Charge les param√®tres depuis le fichier YAML\"\"\"\n        try:\n            if self.config_file.exists():\n                with open(self.config_file, 'r', encoding='utf-8') as f:\n                    config_data = yaml.safe_load(f)\n                \n                if config_data:\n                    for key, value in config_data.items():\n                        if hasattr(self, key):\n                            setattr(self, key, value)\n                \n                self.logger.info(f\"Param√®tres charg√©s depuis {self.config_file}\")\n            else:\n                self.logger.info(\"Fichier de configuration non trouv√©, utilisation des valeurs par d√©faut\")\n                self.save_to_file()  # Cr√©er le fichier avec les valeurs par d√©faut\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur lors du chargement des param√®tres: {e}\")\n    \n    def save_to_file(self):\n        \"\"\"Sauvegarde les param√®tres dans le fichier YAML\"\"\"\n        try:\n            # Cr√©er le dossier config s'il n'existe pas\n            self.config_file.parent.mkdir(parents=True, exist_ok=True)\n            \n            # Convertir en dictionnaire\n            config_data = {}\n            for key, value in self.__dict__.items():\n                if not key.startswith('_') and key not in ['logger', 'config_file']:\n                    config_data[key] = value\n            \n            with open(self.config_file, 'w', encoding='utf-8') as f:\n                yaml.safe_dump(config_data, f, default_flow_style=False, allow_unicode=True)\n            \n            self.logger.info(f\"Param√®tres sauvegard√©s dans {self.config_file}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur lors de la sauvegarde des param√®tres: {e}\")\n    \n    def update(self, new_settings: Dict[str, Any]):\n        \"\"\"Met √† jour les param√®tres\"\"\"\n        updated = False\n        for key, value in new_settings.items():\n            if hasattr(self, key):\n                setattr(self, key, value)\n                updated = True\n                self.logger.info(f\"Param√®tre mis √† jour: {key} = {value}\")\n        \n        if updated:\n            self.save_to_file()\n    \n    def reset_to_defaults(self):\n        \"\"\"Remet les param√®tres aux valeurs par d√©faut\"\"\"\n        default_settings = Settings()\n        for key, value in default_settings.__dict__.items():\n            if not key.startswith('_') and key not in ['logger', 'config_file']:\n                setattr(self, key, value)\n        \n        self.save_to_file()\n        self.logger.info(\"Param√®tres remis aux valeurs par d√©faut\")\n    \n    def get_display_settings(self) -> Dict[str, Any]:\n        \"\"\"Retourne les param√®tres d'affichage\"\"\"\n        return {\n            'language': self.language,\n            'theme': self.theme,\n            'show_probabilities': self.show_probabilities,\n            'show_recommendations': self.show_recommendations,\n            'show_statistics': self.show_statistics\n        }\n    \n    def get_performance_settings(self) -> Dict[str, Any]:\n        \"\"\"Retourne les param√®tres de performance\"\"\"\n        return {\n            'cpu_usage_limit': self.cpu_usage_limit,\n            'ram_usage_limit': self.ram_usage_limit,\n            'gpu_enabled': self.gpu_enabled,\n            'gpu_memory_limit': self.gpu_memory_limit,\n            'auto_resource_management': self.auto_resource_management\n        }","size_bytes":5274},"src/core/__init__.py":{"content":"# Core module","size_bytes":13},"src/core/app_manager.py":{"content":"\"\"\"\nGestionnaire principal de l'application RTPA Studio\n\"\"\"\n\nimport threading\nimport time\nfrom typing import Dict, Any, Optional\nfrom dataclasses import dataclass\nimport yaml\n\nfrom ..database.memory_db import MemoryDatabase\nimport os\n# Force mode headless pour Replit\nif os.getenv('REPLIT_ENVIRONMENT') or not (os.getenv('DISPLAY') and os.name != 'nt'):\n    from ..ocr.screen_capture_headless import ScreenCaptureHeadless as ScreenCapture\nelse:\n    try:\n        from ..ocr.screen_capture import ScreenCapture\n    except Exception:\n        from ..ocr.screen_capture_headless import ScreenCaptureHeadless as ScreenCapture\nfrom ..algorithms.cfr_engine import CFREngine\nfrom ..utils.logger import get_logger\nfrom ..config.settings import Settings\nfrom ..utils.platform_detector import PlatformDetector\n\n@dataclass\nclass GameState:\n    \"\"\"√âtat actuel du jeu\"\"\"\n    table_type: str = \"cashgame\"  # cashgame ou tournament\n    players_count: int = 9\n    hero_position: int = 0\n    hero_cards: tuple = ()\n    board_cards: tuple = ()\n    pot_size: float = 0.0\n    hero_stack: float = 0.0\n    small_blind: float = 0.0\n    big_blind: float = 0.0\n    current_bet: float = 0.0\n    action_to_hero: bool = False\n    ante: float = 0.0\n    tournament_level: int = 1\n    rebuys_available: int = 0\n\nclass RTAPStudioManager:\n    \"\"\"Gestionnaire principal de RTPA Studio\"\"\"\n    \n    def __init__(self):\n        self.logger = get_logger(__name__)\n        self.settings = Settings()\n        self.database = MemoryDatabase()\n        self.screen_capture = ScreenCapture()\n        self.cfr_engine = CFREngine()\n        self.platform_detector = PlatformDetector()\n        \n        # Initialisation de l'entra√Ænement CFR automatique\n        self._init_cfr_training()\n        \n        self.game_state = GameState()\n        self.running = False\n        self.analysis_thread = None\n        self.auto_mode = True  # Mode automatique activ√©\n        self.current_status = \"waiting\"  # waiting, active, paused\n        self.status_callbacks = []\n        \n        # Configuration du d√©tecteur de plateformes\n        self.platform_detector.set_status_callback(self._on_platform_status_change)\n        self.ocr_thread = None\n        \n        # R√©f√©rence √† la GUI pour les callbacks de statut\n        self.gui_window = None\n        \n        # Statistiques\n        self.hands_played = 0\n        self.hands_won = 0\n        self.win_rate = 0.0\n        self.expected_win_rate = 0.65  # Taux normal d'un joueur pro\n        \n        self.logger.info(\"RTPA Studio Manager initialis√© avec entra√Ænement CFR automatique\")\n    \n    def set_gui_window(self, gui_window):\n        \"\"\"D√©finit la r√©f√©rence √† la fen√™tre GUI pour les callbacks de statut\"\"\"\n        self.gui_window = gui_window\n    \n    def _init_cfr_training(self):\n        \"\"\"Initialise l'entra√Ænement CFR automatique\"\"\"\n        try:\n            # Initialisation du trainer CFR avec d√©lai pour √©viter probl√®mes import\n            import threading\n            init_thread = threading.Thread(target=self._delayed_cfr_init, daemon=True)\n            init_thread.start()\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur initialisation CFR training: {e}\")\n    \n    def _delayed_cfr_init(self):\n        \"\"\"Initialisation diff√©r√©e du CFR pour √©viter conflits\"\"\"\n        try:\n            time.sleep(2)  # Petit d√©lai pour s'assurer que tout est charg√©\n            self.cfr_engine.init_trainer()\n            self.logger.info(\"Entra√Ænement CFR automatique initialis√©\")\n        except Exception as e:\n            self.logger.error(f\"Erreur initialisation diff√©r√©e CFR: {e}\")\n        \n        # D√©marrer la surveillance automatique des plateformes\n        self.platform_detector.start_monitoring()\n    \n    def start(self):\n        \"\"\"D√©marre le syst√®me d'analyse en temps r√©el\"\"\"\n        if self.running:\n            return\n            \n        self.running = True\n        self.logger.info(\"D√©marrage du syst√®me d'analyse temps r√©el\")\n        \n        # D√©marrage des threads d'analyse\n        self.ocr_thread = threading.Thread(target=self._ocr_loop, daemon=True)\n        self.analysis_thread = threading.Thread(target=self._analysis_loop, daemon=True)\n        \n        self.ocr_thread.start()\n        self.analysis_thread.start()\n    \n    def stop(self):\n        \"\"\"Arr√™te le syst√®me d'analyse\"\"\"\n        self.running = False\n        self.logger.info(\"Arr√™t du syst√®me d'analyse\")\n    \n    def _ocr_loop(self):\n        \"\"\"Boucle de capture et d'analyse OCR\"\"\"\n        while self.running:\n            try:\n                # Capture et analyse de l'√©cran\n                game_data = self.screen_capture.capture_and_analyze()\n                if game_data:\n                    self._update_game_state(game_data)\n                \n                time.sleep(0.05)  # 50ms entre les captures pour r√©activit√© maximale\n                \n            except Exception as e:\n                self.logger.error(f\"Erreur dans la boucle OCR: {e}\")\n                time.sleep(1)\n    \n    def _analysis_loop(self):\n        \"\"\"Boucle de calcul CFR/Nash en continu\"\"\"\n        while self.running:\n            try:\n                if self.game_state.action_to_hero:\n                    # Calcul des recommandations\n                    recommendation = self.cfr_engine.get_recommendation(self.game_state)\n                    self._update_recommendation(recommendation)\n                \n                time.sleep(0.025)  # 25ms entre les calculs pour temps r√©el\n                \n            except Exception as e:\n                self.logger.error(f\"Erreur dans la boucle d'analyse: {e}\")\n                time.sleep(1)\n    \n    def _update_game_state(self, game_data: Dict[str, Any]):\n        \"\"\"Met √† jour l'√©tat du jeu avec les donn√©es OCR\"\"\"\n        # Extraction et mise √† jour des donn√©es\n        for key, value in game_data.items():\n            if hasattr(self.game_state, key):\n                setattr(self.game_state, key, value)\n        \n        # Sauvegarde en base m√©moire\n        self.database.store_game_state(self.game_state)\n    \n    def _update_recommendation(self, recommendation: Dict[str, Any]):\n        \"\"\"Met √† jour les recommandations de jeu\"\"\"\n        self.database.store_recommendation(recommendation)\n    \n    def get_current_state(self) -> GameState:\n        \"\"\"Retourne l'√©tat actuel du jeu\"\"\"\n        return self.game_state\n    \n    def get_recommendation(self) -> Optional[Dict[str, Any]]:\n        \"\"\"Retourne la derni√®re recommandation\"\"\"\n        return self.database.get_latest_recommendation()\n    \n    def get_statistics(self) -> Dict[str, float]:\n        \"\"\"Retourne les statistiques de performance\"\"\"\n        return {\n            'hands_played': self.hands_played,\n            'hands_won': self.hands_won,\n            'win_rate': self.win_rate,\n            'expected_win_rate': self.expected_win_rate,\n            'performance_ratio': self.win_rate / self.expected_win_rate if self.expected_win_rate > 0 else 0\n        }\n    \n    def update_settings(self, new_settings: Dict[str, Any]):\n        \"\"\"Met √† jour les param√®tres\"\"\"\n        self.settings.update(new_settings)\n        self.cfr_engine.update_settings(new_settings)\n        \n        # Mise √† jour des param√®tres GPU si modifi√©s\n        if 'gpu_enabled' in new_settings or 'gpu_memory_limit' in new_settings:\n            gpu_enabled = new_settings.get('gpu_enabled', getattr(self.settings, 'gpu_enabled', False))\n            gpu_memory = new_settings.get('gpu_memory_limit', getattr(self.settings, 'gpu_memory_limit', 0.8))\n            \n            if hasattr(self.cfr_engine, 'update_gpu_settings'):\n                self.cfr_engine.update_gpu_settings(gpu_enabled, gpu_memory / 100.0)\n                self.logger.info(f\"Param√®tres GPU mis √† jour: enabled={gpu_enabled}, memory={gpu_memory}%\")\n    \n    def manual_override(self, risk_percentage: float):\n        \"\"\"Override manuel du pourcentage de risque\"\"\"\n        self.settings.risk_percentage = risk_percentage\n        self.settings.manual_risk_override = True\n        self.logger.info(f\"Override manuel du risque: {risk_percentage}%\")\n    \n    def add_status_callback(self, callback):\n        \"\"\"Ajoute un callback pour les changements d'√©tat\"\"\"\n        self.status_callbacks.append(callback)\n    \n    def _notify_status_change(self, status, details=None):\n        \"\"\"Notifie les callbacks des changements d'√©tat avec gestion robuste\"\"\"\n        self.current_status = status\n        failed_callbacks = []\n        \n        for i, callback in enumerate(self.status_callbacks):\n            try:\n                if callable(callback):\n                    callback(status, details)\n                else:\n                    self.logger.warning(f\"Callback {i} n'est pas callable\")\n                    failed_callbacks.append(i)\n            except TypeError as e:\n                self.logger.error(f\"Erreur type callback {i}: {e}\")\n                failed_callbacks.append(i)\n            except Exception as e:\n                self.logger.error(f\"Erreur callback {i}: {e}\")\n                import traceback\n                self.logger.debug(f\"Traceback callback: {traceback.format_exc()}\")\n                failed_callbacks.append(i)\n        \n        # Nettoyer les callbacks d√©faillants\n        if failed_callbacks:\n            self.logger.info(f\"Suppression de {len(failed_callbacks)} callbacks d√©faillants\")\n            for i in reversed(failed_callbacks):\n                self.status_callbacks.pop(i)\n    \n    def _on_platform_status_change(self, event_type, data):\n        \"\"\"G√®re les changements de statut des plateformes avec validation\"\"\"\n        try:\n            if not isinstance(event_type, str):\n                self.logger.warning(f\"Type d'√©v√©nement invalide: {type(event_type)}\")\n                return\n            \n            if event_type == 'platform_detected':\n                self.logger.info(f\"Plateforme d√©tect√©e: {data}\")\n                # Notifier la GUI\n                if self.gui_window:\n                    self.gui_window.on_platform_detected(data)\n                if not self.running and hasattr(self, '_auto_start'):\n                    self._auto_start()\n            \n            elif event_type == 'platform_closed':\n                self.logger.info(f\"Plateforme ferm√©e: {data}\")\n                # Notifier la GUI si aucune plateforme n'est active\n                if (hasattr(self, 'platform_detector') and \n                    hasattr(self.platform_detector, 'is_any_platform_active') and\n                    not self.platform_detector.is_any_platform_active()):\n                    if self.gui_window:\n                        self.gui_window.on_platform_closed()\n                    self._auto_stop()\n            \n            elif event_type == 'status':\n                if data == 'active' and not self.running:\n                    if self.gui_window:\n                        self.gui_window.update_connection_status(\"active\")\n                    self._auto_start()\n                elif data == 'waiting' and self.running:\n                    if self.gui_window:\n                        self.gui_window.update_connection_status(\"waiting\")\n                    self._auto_stop()\n                    \n        except Exception as e:\n            self.logger.error(f\"Erreur gestion changement statut plateforme: {e}\")\n            import traceback\n            self.logger.debug(f\"Traceback: {traceback.format_exc()}\")\n    \n    def _auto_start(self):\n        \"\"\"D√©marrage automatique de l'analyse\"\"\"\n        if self.running or not self.auto_mode:\n            return\n        \n        self.running = True\n        self.logger.info(\"D√©marrage automatique du syst√®me d'analyse\")\n        \n        # D√©marrage des threads d'analyse\n        self.ocr_thread = threading.Thread(target=self._ocr_loop, daemon=True)\n        self.analysis_thread = threading.Thread(target=self._analysis_loop, daemon=True)\n        \n        self.ocr_thread.start()\n        self.analysis_thread.start()\n        \n        platform = self.platform_detector.get_primary_platform()\n        self._notify_status_change('active', {'platform': platform})\n    \n    def _auto_stop(self):\n        \"\"\"Arr√™t automatique de l'analyse\"\"\"\n        if not self.running:\n            return\n        \n        self.running = False\n        self.logger.info(\"Arr√™t automatique - Aucune plateforme d√©tect√©e\")\n        self._notify_status_change('waiting')\n    \n    def get_system_status(self):\n        \"\"\"Retourne l'√©tat actuel du syst√®me\"\"\"\n        platforms = self.platform_detector.get_detected_platforms()\n        return {\n            'status': self.current_status,\n            'running': self.running,\n            'auto_mode': self.auto_mode,\n            'platforms': platforms,\n            'primary_platform': self.platform_detector.get_primary_platform()\n        }\n\n    def get_display_data(self) -> Dict[str, Any]:\n        \"\"\"Retourne les donn√©es pour l'affichage GUI avec joueurs complets\"\"\"\n        try:\n            # R√©cup√©ration de l'√©tat actuel du jeu\n            current_state = self.get_current_state()\n            recommendation = self.get_recommendation()\n            statistics = self.get_statistics()\n            \n            # R√©cup√©ration des donn√©es joueurs depuis l'OCR  \n            ocr_data = self.screen_capture.capture_and_analyze() if hasattr(self.screen_capture, 'capture_and_analyze') else {}\n            players_at_table = ocr_data.get('players_at_table', []) if ocr_data else []\n            \n            return {\n                'hero_cards': list(current_state.hero_cards) if current_state.hero_cards else [],\n                'board_cards': current_state.board_cards,\n                'pot': current_state.pot_size,\n                'hero_stack': current_state.hero_stack,\n                'small_blind': current_state.small_blind,\n                'big_blind': current_state.big_blind,\n                'antes': getattr(current_state, 'ante', 0.0),\n                'table_type': current_state.table_type,\n                'hero_position': current_state.hero_position,\n                'recommendation': recommendation,\n                'statistics': statistics,\n                'active_players': getattr(current_state, 'active_players', 8),\n                'total_players': getattr(current_state, 'total_players', 9),\n                'players_info': players_at_table  # Liste compl√®te des joueurs avec positions\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur r√©cup√©ration donn√©es affichage: {e}\")\n            return {}","size_bytes":14599},"src/database/__init__.py":{"content":"# Database module","size_bytes":17},"src/database/memory_db.py":{"content":"\"\"\"\nBase de donn√©es en m√©moire pour RTPA Studio\nOptimis√©e pour les performances temps r√©el\n\"\"\"\n\nimport sqlite3\nimport threading\nimport time\nfrom typing import Dict, List, Any, Optional\nfrom collections import deque\nimport json\n\nfrom ..utils.logger import get_logger\n\nclass MemoryDatabase:\n    \"\"\"Base de donn√©es en m√©moire haute performance\"\"\"\n    \n    def __init__(self, max_history=10000):\n        self.logger = get_logger(__name__)\n        self.max_history = max_history\n        self.lock = threading.RLock()\n        \n        # Stockage en m√©moire\n        self.game_states = deque(maxlen=max_history)\n        self.recommendations = deque(maxlen=max_history)\n        self.hand_history = deque(maxlen=max_history)\n        self.statistics = {}\n        \n        # Index pour recherche rapide\n        self.index_by_timestamp = {}\n        self.index_by_hand_id = {}\n        \n        # Base SQLite pour persistance optionnelle\n        self.conn = sqlite3.connect(':memory:', check_same_thread=False)\n        self._init_tables()\n        \n        self.logger.info(\"Base de donn√©es m√©moire initialis√©e\")\n    \n    def _init_tables(self):\n        \"\"\"Initialise les tables SQLite\"\"\"\n        cursor = self.conn.cursor()\n        \n        # Table des √©tats de jeu\n        cursor.execute('''\n            CREATE TABLE game_states (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                timestamp REAL,\n                table_type TEXT,\n                players_count INTEGER,\n                hero_position INTEGER,\n                hero_cards TEXT,\n                board_cards TEXT,\n                pot_size REAL,\n                hero_stack REAL,\n                small_blind REAL,\n                big_blind REAL,\n                current_bet REAL,\n                action_to_hero INTEGER,\n                ante REAL,\n                tournament_level INTEGER,\n                rebuys_available INTEGER,\n                data_json TEXT\n            )\n        ''')\n        \n        # Table des recommandations\n        cursor.execute('''\n            CREATE TABLE recommendations (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                timestamp REAL,\n                game_state_id INTEGER,\n                action_type TEXT,\n                bet_size REAL,\n                win_probability REAL,\n                expected_value REAL,\n                risk_level REAL,\n                confidence REAL,\n                reasoning TEXT,\n                data_json TEXT,\n                FOREIGN KEY (game_state_id) REFERENCES game_states (id)\n            )\n        ''')\n        \n        # Table des statistiques\n        cursor.execute('''\n            CREATE TABLE statistics (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                timestamp REAL,\n                hands_played INTEGER,\n                hands_won INTEGER,\n                win_rate REAL,\n                total_profit REAL,\n                hourly_rate REAL,\n                bb_per_100 REAL,\n                data_json TEXT\n            )\n        ''')\n        \n        self.conn.commit()\n    \n    def store_game_state(self, game_state):\n        \"\"\"Stocke un √©tat de jeu\"\"\"\n        with self.lock:\n            timestamp = time.time()\n            \n            # Protection contre donn√©es corrompues\n            if game_state.hero_cards is None:\n                game_state.hero_cards = (\"\", \"\")\n            if game_state.board_cards is None:\n                game_state.board_cards = []\n            \n            # Stockage en m√©moire\n            state_data = {\n                'timestamp': timestamp,\n                'game_state': game_state,\n                'id': len(self.game_states)\n            }\n            self.game_states.append(state_data)\n            self.index_by_timestamp[timestamp] = len(self.game_states) - 1\n            \n            # Pr√©paration des donn√©es pour JSON (s√©rialisation compatible)\n            state_json = {\n                'timestamp': timestamp,\n                'table_type': game_state.table_type,\n                'players_count': game_state.players_count,\n                'hero_position': game_state.hero_position,\n                'hero_cards': list(game_state.hero_cards),\n                'board_cards': list(game_state.board_cards),\n                'pot_size': game_state.pot_size,\n                'hero_stack': game_state.hero_stack,\n                'small_blind': game_state.small_blind,\n                'big_blind': game_state.big_blind,\n                'current_bet': game_state.current_bet,\n                'action_to_hero': game_state.action_to_hero,\n                'ante': game_state.ante,\n                'tournament_level': game_state.tournament_level,\n                'rebuys_available': game_state.rebuys_available\n            }\n            \n            # Stockage SQLite pour persistance\n            cursor = self.conn.cursor()\n            cursor.execute('''\n                INSERT INTO game_states (\n                    timestamp, table_type, players_count, hero_position,\n                    hero_cards, board_cards, pot_size, hero_stack,\n                    small_blind, big_blind, current_bet, action_to_hero,\n                    ante, tournament_level, rebuys_available, data_json\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n            ''', (\n                timestamp, game_state.table_type, game_state.players_count,\n                game_state.hero_position, str(game_state.hero_cards),\n                str(game_state.board_cards), game_state.pot_size,\n                game_state.hero_stack, game_state.small_blind,\n                game_state.big_blind, game_state.current_bet,\n                int(game_state.action_to_hero), game_state.ante,\n                game_state.tournament_level, game_state.rebuys_available,\n                json.dumps(state_json)\n            ))\n            self.conn.commit()\n            \n            return True\n    \n    def store_recommendation(self, recommendation: Dict[str, Any], game_state=None):\n        \"\"\"Stocke une recommandation\"\"\"\n        with self.lock:\n            timestamp = time.time()\n            \n            # Stockage en m√©moire\n            rec_data = {\n                'timestamp': timestamp,\n                'recommendation': recommendation\n            }\n            self.recommendations.append(rec_data)\n            \n            # Stockage SQLite\n            cursor = self.conn.cursor()\n            cursor.execute('''\n                INSERT INTO recommendations (\n                    timestamp, action_type, bet_size, win_probability,\n                    expected_value, risk_level, confidence, reasoning, data_json\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n            ''', (\n                timestamp,\n                recommendation.get('action_type', ''),\n                recommendation.get('bet_size', 0.0),\n                recommendation.get('win_probability', 0.0),\n                recommendation.get('expected_value', 0.0),\n                recommendation.get('risk_level', 0.0),\n                recommendation.get('confidence', 0.0),\n                recommendation.get('reasoning', ''),\n                json.dumps(recommendation)\n            ))\n            self.conn.commit()\n    \n    def get_latest_recommendation(self) -> Optional[Dict[str, Any]]:\n        \"\"\"Retourne la derni√®re recommandation\"\"\"\n        with self.lock:\n            if self.recommendations:\n                return self.recommendations[-1]['recommendation']\n            return None\n    \n    def get_latest_game_state(self):\n        \"\"\"Retourne le dernier √©tat de jeu\"\"\"\n        with self.lock:\n            if self.game_states:\n                return self.game_states[-1]['game_state']\n            return None\n    \n    def get_history(self, limit=100) -> List[Dict[str, Any]]:\n        \"\"\"Retourne l'historique r√©cent\"\"\"\n        with self.lock:\n            history = []\n            for i, state_data in enumerate(list(self.game_states)[-limit:]):\n                rec_data = None\n                if i < len(self.recommendations):\n                    rec_data = self.recommendations[i]\n                \n                history.append({\n                    'game_state': state_data,\n                    'recommendation': rec_data\n                })\n            \n            return history\n    \n    def update_statistics(self, stats: Dict[str, Any]):\n        \"\"\"Met √† jour les statistiques\"\"\"\n        with self.lock:\n            self.statistics.update(stats)\n            \n            # Stockage SQLite\n            cursor = self.conn.cursor()\n            cursor.execute('''\n                INSERT INTO statistics (\n                    timestamp, hands_played, hands_won, win_rate,\n                    total_profit, hourly_rate, bb_per_100, data_json\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n            ''', (\n                time.time(),\n                stats.get('hands_played', 0),\n                stats.get('hands_won', 0),\n                stats.get('win_rate', 0.0),\n                stats.get('total_profit', 0.0),\n                stats.get('hourly_rate', 0.0),\n                stats.get('bb_per_100', 0.0),\n                json.dumps(stats)\n            ))\n            self.conn.commit()\n    \n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"Retourne les statistiques actuelles\"\"\"\n        with self.lock:\n            return self.statistics.copy()\n    \n    def clear_history(self):\n        \"\"\"Efface l'historique\"\"\"\n        with self.lock:\n            self.game_states.clear()\n            self.recommendations.clear()\n            self.hand_history.clear()\n            self.index_by_timestamp.clear()\n            self.index_by_hand_id.clear()\n            \n            # Effacement SQLite\n            cursor = self.conn.cursor()\n            cursor.execute('DELETE FROM game_states')\n            cursor.execute('DELETE FROM recommendations')\n            cursor.execute('DELETE FROM statistics')\n            self.conn.commit()\n            \n            self.logger.info(\"Historique effac√©\")\n    \n    def export_complete_data(self, filename: str, cfr_engine=None):\n        \"\"\"Exporte toutes les donn√©es incluant CFR et Nash\"\"\"\n        with self.lock:\n            export_data = {\n                'metadata': {\n                    'version': '1.0',\n                    'export_timestamp': time.time(),\n                    'rtpa_version': 'RTPA Studio v1.0'\n                },\n                'game_data': {\n                    'game_states': [state for state in self.game_states],\n                    'recommendations': [rec for rec in self.recommendations],\n                    'statistics': self.statistics\n                },\n                'cfr_data': {},\n                'settings': {}\n            }\n            \n            # Export des donn√©es CFR si moteur fourni\n            if cfr_engine:\n                try:\n                    export_data['cfr_data'] = {\n                        'regret_sum': dict(cfr_engine.regret_sum),\n                        'strategy_sum': dict(cfr_engine.strategy_sum),\n                        'iterations_count': getattr(cfr_engine, 'iterations_count', 0),\n                        'total_training_time': getattr(cfr_engine, 'total_training_time', 0.0)\n                    }\n                    self.logger.info(\"Donn√©es CFR ajout√©es √† l'export\")\n                except Exception as e:\n                    self.logger.warning(f\"Impossible d'exporter les donn√©es CFR: {e}\")\n            \n            # Export SQLite complet\n            try:\n                cursor = self.conn.cursor()\n                \n                # Toutes les tables\n                tables_data = {}\n                for table_name in ['game_states', 'recommendations', 'statistics']:\n                    cursor.execute(f'SELECT * FROM {table_name}')\n                    rows = cursor.fetchall()\n                    cursor.execute(f'PRAGMA table_info({table_name})')\n                    columns = [col[1] for col in cursor.fetchall()]\n                    \n                    tables_data[table_name] = {\n                        'columns': columns,\n                        'rows': rows\n                    }\n                \n                export_data['sql_backup'] = tables_data\n                self.logger.info(\"Sauvegarde SQL ajout√©e √† l'export\")\n                \n            except Exception as e:\n                self.logger.warning(f\"Erreur export SQL: {e}\")\n            \n            # √âcriture du fichier\n            try:\n                with open(filename, 'w', encoding='utf-8') as f:\n                    json.dump(export_data, f, indent=2, ensure_ascii=False, default=str)\n                \n                self.logger.info(f\"Export complet r√©ussi vers {filename}\")\n                return True\n                \n            except Exception as e:\n                self.logger.error(f\"Erreur √©criture fichier: {e}\")\n                return False\n    \n    def import_complete_data(self, filename: str, cfr_engine=None):\n        \"\"\"Importe toutes les donn√©es incluant CFR et Nash\"\"\"\n        try:\n            with open(filename, 'r', encoding='utf-8') as f:\n                import_data = json.load(f)\n            \n            with self.lock:\n                # V√©rification version\n                if 'metadata' not in import_data:\n                    self.logger.warning(\"Fichier d'import ancien format\")\n                    return self._import_legacy_format(import_data, cfr_engine)\n                \n                # Import des donn√©es de jeu\n                if 'game_data' in import_data:\n                    game_data = import_data['game_data']\n                    \n                    # Clear et import game states\n                    self.game_states.clear()\n                    for state_data in game_data.get('game_states', []):\n                        self.game_states.append(state_data)\n                    \n                    # Clear et import recommendations\n                    self.recommendations.clear()\n                    for rec_data in game_data.get('recommendations', []):\n                        self.recommendations.append(rec_data)\n                    \n                    # Import statistics\n                    if 'statistics' in game_data:\n                        self.statistics.update(game_data['statistics'])\n                    \n                    self.logger.info(\"Donn√©es de jeu import√©es\")\n                \n                # Import des donn√©es CFR\n                if 'cfr_data' in import_data and cfr_engine:\n                    try:\n                        cfr_data = import_data['cfr_data']\n                        \n                        # Restauration regret_sum et strategy_sum\n                        if 'regret_sum' in cfr_data:\n                            cfr_engine.regret_sum.clear()\n                            for info_set, actions in cfr_data['regret_sum'].items():\n                                cfr_engine.regret_sum[info_set].update(actions)\n                        \n                        if 'strategy_sum' in cfr_data:\n                            cfr_engine.strategy_sum.clear()\n                            for info_set, actions in cfr_data['strategy_sum'].items():\n                                cfr_engine.strategy_sum[info_set].update(actions)\n                        \n                        # Restauration m√©tadonn√©es CFR\n                        if hasattr(cfr_engine, 'iterations_count'):\n                            cfr_engine.iterations_count = cfr_data.get('iterations_count', 0)\n                        if hasattr(cfr_engine, 'total_training_time'):\n                            cfr_engine.total_training_time = cfr_data.get('total_training_time', 0.0)\n                        \n                        self.logger.info(\"Donn√©es CFR restaur√©es avec succ√®s\")\n                        \n                    except Exception as e:\n                        self.logger.error(f\"Erreur import CFR: {e}\")\n                \n                # Reconstruction des index\n                self._rebuild_indexes()\n                \n                self.logger.info(f\"Import complet r√©ussi depuis {filename}\")\n                return True\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur import fichier {filename}: {e}\")\n            return False\n    \n    def _import_legacy_format(self, data, cfr_engine):\n        \"\"\"Import ancien format pour compatibilit√©\"\"\"\n        try:\n            # Ancien format direct\n            if 'game_states' in data:\n                self.game_states.clear()\n                for state_data in data['game_states']:\n                    self.game_states.append(state_data)\n            \n            if 'recommendations' in data:\n                self.recommendations.clear()\n                for rec_data in data['recommendations']:\n                    self.recommendations.append(rec_data)\n            \n            if 'statistics' in data:\n                self.statistics.update(data['statistics'])\n            \n            self._rebuild_indexes()\n            self.logger.info(\"Import legacy r√©ussi\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur import legacy: {e}\")\n            return False\n    \n    def _rebuild_indexes(self):\n        \"\"\"Reconstruit les index apr√®s import\"\"\"\n        self.index_by_timestamp.clear()\n        self.index_by_hand_id.clear()\n        \n        for i, state_data in enumerate(self.game_states):\n            if 'timestamp' in state_data:\n                self.index_by_timestamp[state_data['timestamp']] = i\n    \n    def export_data(self, filename: str):\n        \"\"\"Exporte les donn√©es vers un fichier (legacy)\"\"\"\n        return self.export_complete_data(filename)\n    \n    def close(self):\n        \"\"\"Ferme la base de donn√©es\"\"\"\n        self.conn.close()\n        self.logger.info(\"Base de donn√©es ferm√©e\")","size_bytes":17855},"src/gui/__init__.py":{"content":"# GUI module","size_bytes":12},"src/gui/main_window.py":{"content":"\"\"\"\nInterface graphique principale de RTPA Studio\nInterface moderne et √©l√©gante avec CustomTkinter\n\"\"\"\n\nimport customtkinter as ctk\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport threading\nimport time\nfrom typing import Dict, Any, Optional\nimport json\nimport os\n\nfrom ..utils.logger import get_logger\n\n# Configuration CustomTkinter\nctk.set_appearance_mode(\"dark\")\nctk.set_default_color_theme(\"blue\")\n\nclass RTAPMainWindow:\n    \"\"\"Fen√™tre principale de RTPA Studio\"\"\"\n    \n    def __init__(self, app_manager):\n        self.logger = get_logger(__name__)\n        self.app_manager = app_manager\n        \n        # Chargement des informations de version\n        self.version_info = self._load_version_info()\n        \n        # Configuration de la fen√™tre principale\n        self.root = ctk.CTk()\n        title = f\"RTPA Studio v{self.version_info['version']} - Real-Time Poker Analysis\"\n        self.root.title(title)\n        self.root.geometry(\"1400x900\")\n        self.root.minsize(1200, 800)\n        \n        # Configuration du logo et ic√¥ne\n        try:\n            # Utiliser le logo comme ic√¥ne si disponible\n            self.root.iconbitmap(\"attached_assets/RTPA_Studio_icon_1757250204909.ico\")\n        except:\n            # Fallback si l'ic√¥ne n'est pas trouv√©e\n            pass\n        \n        # Variables de l'interface\n        self.language = tk.StringVar(value=\"fr\")\n        self.is_running = False\n        self.update_thread = None\n        self.system_status = \"waiting\"  # waiting, active, paused\n        \n        # Callback pour les changements d'√©tat automatiques\n        self.app_manager.add_status_callback(self._on_system_status_change)\n        \n        # Configuration multilingue\n        self.translations = {\n            \"fr\": {\n                \"title\": \"RTPA Studio - Analyse Poker Temps R√©el\",\n                \"start\": \"D√©marrer\",\n                \"stop\": \"Arr√™ter\",\n                \"settings\": \"Param√®tres\",\n                \"statistics\": \"Statistiques\",\n                \"game_state\": \"√âtat du Jeu\",\n                \"recommendations\": \"Recommandations\",\n                \"hero_cards\": \"Cartes H√©ros:\",\n                \"board_cards\": \"Board:\",\n                \"pot_size\": \"Pot:\",\n                \"stack\": \"Stack:\",\n                \"win_probability\": \"Probabilit√© de Victoire:\",\n                \"action\": \"Action Recommand√©e:\",\n                \"risk_level\": \"Niveau de Risque:\",\n                \"hands_played\": \"Mains Jou√©es:\",\n                \"hands_won\": \"Mains Gagn√©es:\",\n                \"win_rate\": \"Taux de Victoire:\",\n                \"expected_rate\": \"Taux Attendu:\",\n                \"performance\": \"Performance:\",\n                \"table_type\": \"Type de Table:\",\n                \"cashgame\": \"Cash Game\",\n                \"tournament\": \"Tournoi\",\n                \"language\": \"Langue:\",\n                \"risk_override\": \"Override Risque (%):\",\n                \"auto_risk\": \"Risque Automatique\",\n                \"gpu_enabled\": \"GPU Activ√©\",\n                \"resource_management\": \"Gestion Auto Ressources\"\n            },\n            \"en\": {\n                \"title\": \"RTPA Studio - Real-Time Poker Analysis\",\n                \"start\": \"Start\",\n                \"stop\": \"Stop\",\n                \"settings\": \"Settings\",\n                \"statistics\": \"Statistics\",\n                \"game_state\": \"Game State\",\n                \"recommendations\": \"Recommendations\",\n                \"hero_cards\": \"Hero Cards:\",\n                \"board_cards\": \"Board:\",\n                \"pot_size\": \"Pot:\",\n                \"stack\": \"Stack:\",\n                \"win_probability\": \"Win Probability:\",\n                \"action\": \"Recommended Action:\",\n                \"risk_level\": \"Risk Level:\",\n                \"hands_played\": \"Hands Played:\",\n                \"hands_won\": \"Hands Won:\",\n                \"win_rate\": \"Win Rate:\",\n                \"expected_rate\": \"Expected Rate:\",\n                \"performance\": \"Performance:\",\n                \"table_type\": \"Table Type:\",\n                \"cashgame\": \"Cash Game\",\n                \"tournament\": \"Tournament\",\n                \"language\": \"Language:\",\n                \"risk_override\": \"Risk Override (%):\",\n                \"auto_risk\": \"Auto Risk\",\n                \"gpu_enabled\": \"GPU Enabled\",\n                \"resource_management\": \"Auto Resource Management\"\n            }\n        }\n        \n        self.create_widgets()\n        self.setup_layout()\n        self.start_update_loop()\n        \n        self.logger.info(\"Interface graphique initialis√©e\")\n    \n    def create_widgets(self):\n        \"\"\"Cr√©ation des widgets de l'interface\"\"\"\n        \n        # Frame principal\n        self.main_frame = ctk.CTkFrame(self.root)\n        \n        # En-t√™te avec logo et indicateur d'√©tat\n        self.header_frame = ctk.CTkFrame(self.main_frame)\n        \n        # Logo RTPA Studio\n        try:\n            from PIL import Image\n            logo_image = Image.open(\"attached_assets/RTPA_Studio_logo_1757250204909.png\")\n            logo_image = logo_image.resize((200, 60), Image.Resampling.LANCZOS)\n            self.logo_ctk = ctk.CTkImage(light_image=logo_image, dark_image=logo_image, size=(200, 60))\n            self.logo_label = ctk.CTkLabel(self.header_frame, image=self.logo_ctk, text=\"\")\n        except:\n            # Fallback texte si logo non trouv√©\n            self.logo_label = ctk.CTkLabel(\n                self.header_frame,\n                text=\"üéØ RTPA STUDIO\",\n                font=ctk.CTkFont(size=20, weight=\"bold\")\n            )\n        \n\n        # Indicateur d'√©tat automatique (haut droite)\n        self.status_indicator = ctk.CTkFrame(self.header_frame)\n        self.status_icon = ctk.CTkLabel(\n            self.status_indicator,\n            text=\"‚è∏Ô∏è\",\n            font=ctk.CTkFont(size=20)\n        )\n        self.status_text = ctk.CTkLabel(\n            self.status_indicator,\n            text=\"En attente de plateforme poker\",\n            font=ctk.CTkFont(size=12, weight=\"bold\"),\n            text_color=\"orange\"\n        )\n        self.platform_label = ctk.CTkLabel(\n            self.status_indicator,\n            text=\"Aucune plateforme d√©tect√©e\",\n            font=ctk.CTkFont(size=10),\n            text_color=\"gray\"\n        )\n        \n        # Frame de contenu principal (3 colonnes)\n        self.content_frame = ctk.CTkFrame(self.main_frame)\n        \n        # Colonne 1: √âtat du jeu\n        self.game_state_frame = ctk.CTkFrame(self.content_frame)\n        self.game_state_title = ctk.CTkLabel(\n            self.game_state_frame,\n            text=\"‚ñ∂ \" + self.get_text(\"game_state\"),\n            font=ctk.CTkFont(size=16, weight=\"bold\")\n        )\n        \n        # Widgets √©tat du jeu\n        self.hero_cards_label = ctk.CTkLabel(self.game_state_frame, text=\"‚ô† \" + self.get_text(\"hero_cards\"))\n        self.hero_cards_value = ctk.CTkLabel(self.game_state_frame, text=\"-- --\", font=ctk.CTkFont(size=14, weight=\"bold\"))\n        \n        self.board_cards_label = ctk.CTkLabel(self.game_state_frame, text=\"‚ô¶ \" + self.get_text(\"board_cards\"))\n        self.board_cards_value = ctk.CTkLabel(self.game_state_frame, text=\"-- -- -- -- --\", font=ctk.CTkFont(size=14, weight=\"bold\"))\n        \n        self.pot_size_label = ctk.CTkLabel(self.game_state_frame, text=\"‚óè \" + self.get_text(\"pot_size\"))\n        self.pot_size_value = ctk.CTkLabel(self.game_state_frame, text=\"0.00‚Ç¨\", font=ctk.CTkFont(size=14, weight=\"bold\"))\n        \n        self.stack_label = ctk.CTkLabel(self.game_state_frame, text=\"‚ñ† \" + self.get_text(\"stack\"))\n        self.stack_value = ctk.CTkLabel(self.game_state_frame, text=\"0.00‚Ç¨\", font=ctk.CTkFont(size=14, weight=\"bold\"))\n        \n        # Colonne 2: Recommandations\n        self.recommendations_frame = ctk.CTkFrame(self.content_frame)\n        self.recommendations_title = ctk.CTkLabel(\n            self.recommendations_frame,\n            text=\"‚ñ∂ \" + self.get_text(\"recommendations\"),\n            font=ctk.CTkFont(size=16, weight=\"bold\")\n        )\n        \n        # Widgets recommandations\n        self.win_prob_label = ctk.CTkLabel(self.recommendations_frame, text=\"‚ñ≤ \" + self.get_text(\"win_probability\"))\n        self.win_prob_value = ctk.CTkLabel(self.recommendations_frame, text=\"50.0%\", font=ctk.CTkFont(size=20, weight=\"bold\"), text_color=\"yellow\")\n        \n        self.action_label = ctk.CTkLabel(self.recommendations_frame, text=\"‚ñ∫ \" + self.get_text(\"action\"))\n        self.action_value = ctk.CTkLabel(self.recommendations_frame, text=\"Check\", font=ctk.CTkFont(size=18, weight=\"bold\"), text_color=\"green\")\n        \n        self.risk_label = ctk.CTkLabel(self.recommendations_frame, text=\"‚ñº \" + self.get_text(\"risk_level\"))\n        self.risk_value = ctk.CTkLabel(self.recommendations_frame, text=\"30%\", font=ctk.CTkFont(size=16, weight=\"bold\"))\n        \n        # Barre de progression pour probabilit√© de victoire\n        self.win_prob_progress = ctk.CTkProgressBar(self.recommendations_frame, width=300)\n        self.win_prob_progress.set(0.5)\n        \n        # Colonne 3: Param√®tres et Statistiques\n        self.settings_frame = ctk.CTkFrame(self.content_frame)\n        \n        # Onglets\n        self.tabview = ctk.CTkTabview(self.settings_frame)\n        self.stats_tab = self.tabview.add(self.get_text(\"statistics\"))\n        self.settings_tab = self.tabview.add(self.get_text(\"settings\"))\n        self.version_tab = self.tabview.add(\"Version\")\n        \n        # Statistiques\n        self.hands_played_label = ctk.CTkLabel(self.stats_tab, text=\"‚ô† \" + self.get_text(\"hands_played\"))\n        self.hands_played_value = ctk.CTkLabel(self.stats_tab, text=\"0\", font=ctk.CTkFont(size=14, weight=\"bold\"))\n        \n        self.hands_won_label = ctk.CTkLabel(self.stats_tab, text=\"‚ñ≤ \" + self.get_text(\"hands_won\"))\n        self.hands_won_value = ctk.CTkLabel(self.stats_tab, text=\"0\", font=ctk.CTkFont(size=14, weight=\"bold\"))\n        \n        self.win_rate_label = ctk.CTkLabel(self.stats_tab, text=\"‚ñ∫ \" + self.get_text(\"win_rate\"))\n        self.win_rate_value = ctk.CTkLabel(self.stats_tab, text=\"0.0%\", font=ctk.CTkFont(size=14, weight=\"bold\"))\n        \n        self.expected_rate_label = ctk.CTkLabel(self.stats_tab, text=\"‚óè \" + self.get_text(\"expected_rate\"))\n        self.expected_rate_value = ctk.CTkLabel(self.stats_tab, text=\"65.0%\", font=ctk.CTkFont(size=14, weight=\"bold\"), text_color=\"blue\")\n        \n        self.performance_label = ctk.CTkLabel(self.stats_tab, text=\"‚ñ† \" + self.get_text(\"performance\"))\n        self.performance_value = ctk.CTkLabel(self.stats_tab, text=\"0.0%\", font=ctk.CTkFont(size=14, weight=\"bold\"))\n        \n        # Graphique de performance\n        self.performance_progress = ctk.CTkProgressBar(self.stats_tab, width=200)\n        self.performance_progress.set(0.0)\n        \n        # Param√®tres\n        self.language_label = ctk.CTkLabel(self.settings_tab, text=self.get_text(\"language\"))\n        self.language_combo = ctk.CTkComboBox(\n            self.settings_tab,\n            values=[\"Fran√ßais\", \"English\"],\n            command=self.change_language,\n            width=150\n        )\n        \n        self.table_type_label = ctk.CTkLabel(self.settings_tab, text=self.get_text(\"table_type\"))\n        self.table_type_combo = ctk.CTkComboBox(\n            self.settings_tab,\n            values=[self.get_text(\"cashgame\"), self.get_text(\"tournament\")],\n            command=self.change_table_type,\n            width=150\n        )\n        \n        self.risk_override_label = ctk.CTkLabel(self.settings_tab, text=self.get_text(\"risk_override\"))\n        self.risk_slider = ctk.CTkSlider(\n            self.settings_tab,\n            from_=0,\n            to=100,\n            number_of_steps=100,\n            command=self.update_risk_override,\n            width=200\n        )\n        self.risk_slider.set(50)\n        self.risk_value_label = ctk.CTkLabel(self.settings_tab, text=\"50%\")\n        \n        self.auto_risk_check = ctk.CTkCheckBox(\n            self.settings_tab,\n            text=self.get_text(\"auto_risk\"),\n            command=self.toggle_auto_risk\n        )\n        self.auto_risk_check.select()\n        \n        self.gpu_check = ctk.CTkCheckBox(\n            self.settings_tab,\n            text=self.get_text(\"gpu_enabled\"),\n            command=self.toggle_gpu\n        )\n        self.gpu_check.select()\n        \n        self.resource_mgmt_check = ctk.CTkCheckBox(\n            self.settings_tab,\n            text=self.get_text(\"resource_management\"),\n            command=self.toggle_resource_management\n        )\n        self.resource_mgmt_check.select()\n    \n    def setup_layout(self):\n        \"\"\"Organisation des widgets\"\"\"\n        \n        # Frame principal\n        self.main_frame.pack(fill=\"both\", expand=True, padx=10, pady=10)\n        \n        # En-t√™te avec logo et status\n        self.header_frame.pack(fill=\"x\", pady=(0, 10))\n        self.logo_label.pack(side=\"left\", padx=(10, 0))\n        \n        # Indicateur d'√©tat √† droite\n        self.status_indicator.pack(side=\"right\", padx=(0, 10))\n        self.status_icon.pack(side=\"left\", padx=(10, 5))\n        \n        # Textes de status en colonne\n        status_text_frame = ctk.CTkFrame(self.status_indicator, fg_color=\"transparent\")\n        status_text_frame.pack(side=\"left\", padx=(0, 10))\n        self.status_text.pack(anchor=\"w\")\n        self.platform_label.pack(anchor=\"w\")\n        \n        \n        \n        \n        # Contenu onglet Version (dans le tabview principal)\n        self.version_current_label = ctk.CTkLabel(\n            self.version_tab,\n            text=f\"Version Actuelle: {self.version_info['version']}\",\n            font=ctk.CTkFont(size=14, weight=\"bold\"),\n            text_color=\"cyan\"\n        )\n        self.version_current_label.pack(pady=(10, 5))\n        \n        self.version_date_label = ctk.CTkLabel(\n            self.version_tab,\n            text=f\"Derni√®re MAJ: {self.version_info['last_update']}\",\n            font=ctk.CTkFont(size=12),\n            text_color=\"gray\"\n        )\n        self.version_date_label.pack(pady=2)\n        \n        self.version_build_label = ctk.CTkLabel(\n            self.version_tab,\n            text=f\"Build: {self.version_info['build']}\",\n            font=ctk.CTkFont(size=12),\n            text_color=\"gray\"\n        )\n        self.version_build_label.pack(pady=2)\n        \n        self.version_status_label = ctk.CTkLabel(\n            self.version_tab,\n            text=\"Status: \" + self.version_info['status'].title(),\n            font=ctk.CTkFont(size=12),\n            text_color=\"green\"\n        )\n        self.version_status_label.pack(pady=2)\n        \n        # Boutons de mise √† jour\n        self.check_update_button = ctk.CTkButton(\n            self.version_tab,\n            text=\"üîÑ V√©rifier les mises √† jour\",\n            command=self.check_for_updates,\n            font=ctk.CTkFont(size=12)\n        )\n        self.check_update_button.pack(pady=(15, 5))\n        \n        self.update_button = ctk.CTkButton(\n            self.version_tab,\n            text=\"‚¨áÔ∏è Mettre √† jour\",\n            command=self.perform_update,\n            font=ctk.CTkFont(size=12),\n            state=\"disabled\"\n        )\n        self.update_button.pack(pady=5)\n        \n        # Zone de statut des mises √† jour\n        self.update_status_frame = ctk.CTkFrame(self.version_tab)\n        self.update_status_frame.pack(fill=\"x\", pady=(10, 5))\n        \n        self.update_status_label = ctk.CTkLabel(\n            self.update_status_frame,\n            text=\"Pr√™t pour v√©rification\",\n            font=ctk.CTkFont(size=10),\n            text_color=\"gray\"\n        )\n        self.update_status_label.pack(pady=5)\n        \n\n        # Frame de contenu (3 colonnes)\n        self.content_frame.pack(fill=\"both\", expand=True)\n        \n        # Colonne 1: √âtat du jeu\n        self.game_state_frame.pack(side=\"left\", fill=\"both\", expand=True, padx=(0, 5))\n        self.game_state_title.pack(pady=10)\n        \n        # Layout √©tat du jeu\n        game_widgets = [\n            (self.hero_cards_label, self.hero_cards_value),\n            (self.board_cards_label, self.board_cards_value),\n            (self.pot_size_label, self.pot_size_value),\n            (self.stack_label, self.stack_value)\n        ]\n        \n        for label, value in game_widgets:\n            frame = ctk.CTkFrame(self.game_state_frame)\n            frame.pack(fill=\"x\", padx=10, pady=5)\n            label.pack(anchor=\"w\", padx=10, pady=(5, 0))\n            value.pack(anchor=\"w\", padx=10, pady=(0, 5))\n        \n        # Colonne 2: Recommandations\n        self.recommendations_frame.pack(side=\"left\", fill=\"both\", expand=True, padx=5)\n        self.recommendations_title.pack(pady=10)\n        \n        # Layout recommandations\n        rec_frame = ctk.CTkFrame(self.recommendations_frame)\n        rec_frame.pack(fill=\"x\", padx=10, pady=10)\n        \n        self.win_prob_label.pack(pady=(10, 0))\n        self.win_prob_value.pack(pady=5)\n        self.win_prob_progress.pack(pady=10)\n        \n        self.action_label.pack(pady=(10, 0))\n        self.action_value.pack(pady=5)\n        \n        self.risk_label.pack(pady=(10, 0))\n        self.risk_value.pack(pady=(0, 10))\n        \n        # Colonne 3: Param√®tres et Stats\n        self.settings_frame.pack(side=\"left\", fill=\"both\", expand=True, padx=(5, 0))\n        self.tabview.pack(fill=\"both\", expand=True, padx=10, pady=10)\n        \n        # Layout statistiques\n        stats_widgets = [\n            (self.hands_played_label, self.hands_played_value),\n            (self.hands_won_label, self.hands_won_value),\n            (self.win_rate_label, self.win_rate_value),\n            (self.expected_rate_label, self.expected_rate_value),\n            (self.performance_label, self.performance_value)\n        ]\n        \n        for label, value in stats_widgets:\n            frame = ctk.CTkFrame(self.stats_tab)\n            frame.pack(fill=\"x\", padx=5, pady=3)\n            label.pack(anchor=\"w\", padx=5, pady=(3, 0))\n            value.pack(anchor=\"w\", padx=5, pady=(0, 3))\n        \n        self.performance_progress.pack(pady=10)\n        \n        # Layout param√®tres\n        settings_widgets = [\n            (self.language_label, self.language_combo),\n            (self.table_type_label, self.table_type_combo),\n            (self.risk_override_label, None)\n        ]\n        \n        for label, widget in settings_widgets:\n            frame = ctk.CTkFrame(self.settings_tab)\n            frame.pack(fill=\"x\", padx=5, pady=5)\n            label.pack(anchor=\"w\", padx=5, pady=3)\n            if widget:\n                widget.pack(anchor=\"w\", padx=5, pady=3)\n        \n        # Slider de risque avec label\n        risk_frame = ctk.CTkFrame(self.settings_tab)\n        risk_frame.pack(fill=\"x\", padx=5, pady=5)\n        self.risk_slider.pack(padx=5, pady=3)\n        self.risk_value_label.pack(padx=5, pady=3)\n        \n        # Checkboxes\n        checkboxes = [self.auto_risk_check, self.gpu_check, self.resource_mgmt_check]\n        for checkbox in checkboxes:\n            checkbox.pack(anchor=\"w\", padx=10, pady=5)\n    \n    def get_text(self, key: str) -> str:\n        \"\"\"R√©cup√®re le texte traduit\"\"\"\n        lang = self.language.get()\n        return self.translations.get(lang, {}).get(key, key)\n    \n    def change_language(self, selection: str):\n        \"\"\"Change la langue de l'interface\"\"\"\n        lang = \"fr\" if selection == \"Fran√ßais\" else \"en\"\n        self.language.set(lang)\n        self.update_interface_language()\n    \n    def update_interface_language(self):\n        \"\"\"Met √† jour tous les textes de l'interface\"\"\"\n        self.root.title(self.get_text(\"title\"))\n        \n        # Mise √† jour des textes de l'interface\n        # Les boutons ont √©t√© remplac√©s par l'indicateur automatique\n        pass\n    \n    def check_for_updates(self):\n        \"\"\"V√©rifie les mises √† jour disponibles sur GitHub\"\"\"\n        try:\n            self.update_status_label.configure(text=\"V√©rification en cours...\", text_color=\"orange\")\n            self.check_update_button.configure(state=\"disabled\")\n            \n            # Utilisation d'un thread pour √©viter de bloquer l'interface\n            import threading\n            thread = threading.Thread(target=self._check_github_updates, daemon=True)\n            thread.start()\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur v√©rification mises √† jour: {e}\")\n            self.update_status_label.configure(text=\"Erreur lors de la v√©rification\", text_color=\"red\")\n            self.check_update_button.configure(state=\"normal\")\n\n    def _check_github_updates(self):\n        \"\"\"V√©rifie les mises √† jour sur GitHub (thread s√©par√©)\"\"\"\n        try:\n            import requests\n            import json\n            from packaging import version\n            \n            # V√©rification de mise √† jour d√©sactiv√©e temporairement\n            # Le d√©p√¥t GitHub n'est pas encore configur√©\n            self.root.after(0, lambda: self.update_status_label.configure(\n                text=\"V√©rification des mises √† jour non disponible\", text_color=\"orange\"\n            ))\n            self.root.after(0, lambda: self.check_update_button.configure(state=\"normal\"))\n            return\n            \n            # R√©cup√©ration des releases GitHub (d√©sactiv√©)\n            url = \"https://api.github.com/repos/MDS-AnGe/RTPA_Studio/releases/latest\"\n            response = requests.get(url, timeout=10)\n            \n            if response.status_code == 200:\n                release_data = response.json()\n                latest_version = release_data['tag_name'].lstrip('v')\n                current_version = self.version_info['version']\n                \n                # Comparaison des versions\n                if version.parse(latest_version) > version.parse(current_version):\n                    # Mise √† jour disponible\n                    self.root.after(0, lambda: self._update_ui_new_version_available(latest_version, release_data))\n                else:\n                    # D√©j√† √† jour\n                    self.root.after(0, lambda: self.update_status_label.configure(\n                        text=\"Vous avez la derni√®re version\", text_color=\"green\"\n                    ))\n                    self.root.after(0, lambda: self.check_update_button.configure(state=\"normal\"))\n            else:\n                self.root.after(0, lambda: self.update_status_label.configure(\n                    text=\"Impossible de v√©rifier les mises √† jour\", text_color=\"red\"\n                ))\n                self.root.after(0, lambda: self.check_update_button.configure(state=\"normal\"))\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur GitHub API: {e}\")\n            self.root.after(0, lambda: self.update_status_label.configure(\n                text=\"Erreur de connexion\", text_color=\"red\"\n            ))\n            self.root.after(0, lambda: self.check_update_button.configure(state=\"normal\"))\n\n    def _update_ui_new_version_available(self, latest_version, release_data):\n        \"\"\"Met √† jour l'interface quand une nouvelle version est disponible\"\"\"\n        self.update_status_label.configure(\n            text=f\"Nouvelle version disponible: v{latest_version}\", \n            text_color=\"cyan\"\n        )\n        self.update_button.configure(state=\"normal\")\n        self.check_update_button.configure(state=\"normal\")\n        \n        # Stocker les donn√©es de release pour la mise √† jour\n        self.latest_release_data = release_data\n\n    def perform_update(self):\n        \"\"\"Lance la mise √† jour du logiciel\"\"\"\n        try:\n            from tkinter import messagebox\n            \n            # Confirmation avec l'utilisateur\n            result = messagebox.askyesno(\n                \"Confirmation de mise √† jour\",\n                \"La mise √† jour va red√©marrer l'application.\\n\\n\"\n                \"Vos donn√©es (base de donn√©es et entra√Ænements CFR) seront pr√©serv√©es.\\n\\n\"\n                \"Continuer ?\",\n                icon='question'\n            )\n            \n            if result:\n                self.update_status_label.configure(text=\"Pr√©paration de la mise √† jour...\", text_color=\"orange\")\n                self.update_button.configure(state=\"disabled\")\n                \n                # Lance la mise √† jour en arri√®re-plan\n                import threading\n                thread = threading.Thread(target=self._perform_git_update, daemon=True)\n                thread.start()\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur lors de la mise √† jour: {e}\")\n            self.update_status_label.configure(text=\"Erreur de mise √† jour\", text_color=\"red\")\n\n    def _perform_git_update(self):\n        \"\"\"Effectue la mise √† jour Git (thread s√©par√©)\"\"\"\n        try:\n            import subprocess\n            import os\n            import shutil\n            import time\n            \n            self.root.after(0, lambda: self.update_status_label.configure(\n                text=\"Sauvegarde en cours...\", text_color=\"orange\"\n            ))\n            \n            # Sauvegarde des donn√©es importantes\n            backup_files = []\n            important_dirs = ['database/', 'config/', 'attached_assets/']\n            \n            for dir_name in important_dirs:\n                if os.path.exists(dir_name):\n                    backup_name = f\"{dir_name.rstrip('/')}_backup_{int(time.time())}\"\n                    shutil.copytree(dir_name, backup_name)\n                    backup_files.append(backup_name)\n                    self.logger.info(f\"Sauvegarde cr√©√©e: {backup_name}\")\n            \n            # Sauvegarde du fichier version.json\n            if os.path.exists('version.json'):\n                shutil.copy2('version.json', 'version_backup.json')\n                backup_files.append('version_backup.json')\n            \n            self.root.after(0, lambda: self.update_status_label.configure(\n                text=\"T√©l√©chargement des mises √† jour...\", text_color=\"orange\"\n            ))\n            \n            # Mise √† jour Git\n            result = subprocess.run(['git', 'pull', 'origin', 'main'], \n                                  capture_output=True, text=True, cwd='.')\n            \n            if result.returncode == 0:\n                self.root.after(0, lambda: self.update_status_label.configure(\n                    text=\"Mise √† jour r√©ussie! Red√©marrage...\", text_color=\"green\"\n                ))\n                \n                # Restauration des donn√©es utilisateur\n                for backup in backup_files:\n                    if backup.endswith('_backup.json'):\n                        continue  # Garde la nouvelle version\n                    original = backup.replace(f'_backup_{int(time.time())}', '').replace('_backup', '')\n                    if os.path.exists(backup) and not backup.endswith('.json'):\n                        if os.path.exists(original):\n                            shutil.rmtree(original)\n                        shutil.move(backup, original)\n                        self.logger.info(f\"Donn√©es restaur√©es: {original}\")\n                \n                # Attendre un peu puis red√©marrer\n                time.sleep(2)\n                self.root.after(0, self._restart_application)\n                \n            else:\n                self.root.after(0, lambda: self.update_status_label.configure(\n                    text=\"Erreur lors de la mise √† jour\", text_color=\"red\"\n                ))\n                self.logger.error(f\"Erreur Git: {result.stderr}\")\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur mise √† jour Git: {e}\")\n            self.root.after(0, lambda: self.update_status_label.configure(\n                text=\"Erreur de mise √† jour\", text_color=\"red\"\n            ))\n\n    def _restart_application(self):\n        \"\"\"Red√©marre l'application apr√®s mise √† jour\"\"\"\n        try:\n            import sys\n            import subprocess\n            \n            # Fermeture propre\n            if hasattr(self.app_manager, 'cleanup'):\n                self.app_manager.cleanup()\n            \n            # Red√©marrage\n            subprocess.Popen([sys.executable] + sys.argv)\n            self.root.quit()\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur red√©marrage: {e}\")\n\n    def _update_system_info(self):\n        \"\"\"Met √† jour les informations syst√®me dans le panel\"\"\"\n        try:\n            import psutil\n            \n            # CPU usage - v√©rification d'existence du label\n            if hasattr(self, 'cpu_label'):\n                cpu_percent = psutil.cpu_percent(interval=None)\n                self.cpu_label.configure(text=f\"CPU: {cpu_percent:.1f}%\")\n            \n            # Memory usage - v√©rification d'existence du label\n            if hasattr(self, 'memory_label'):\n                memory = psutil.virtual_memory()\n                memory_percent = memory.percent\n                memory_gb = memory.used / (1024**3)\n                self.memory_label.configure(text=f\"RAM: {memory_gb:.1f}GB ({memory_percent:.1f}%)\")\n            \n            # CFR Status - v√©rification d'existence du label\n            if hasattr(self, 'cfr_status_label'):\n                if hasattr(self.app_manager, 'cfr_engine') and self.app_manager.cfr_engine:\n                    if hasattr(self.app_manager.cfr_engine, 'training_active') and self.app_manager.cfr_engine.training_active:\n                        self.cfr_status_label.configure(text=\"CFR: Entra√Ænement actif\", text_color=\"green\")\n                    else:\n                        self.cfr_status_label.configure(text=\"CFR: Pr√™t\", text_color=\"cyan\")\n                else:\n                    self.cfr_status_label.configure(text=\"CFR: Initialisation...\", text_color=\"orange\")\n                \n        except Exception as e:\n            self.logger.warning(f\"Erreur mise √† jour infos syst√®me: {e}\")\n\n    def _load_version_info(self):\n        \"\"\"Charge les informations de version depuis le fichier version.json\"\"\"\n        try:\n            version_file = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'version.json')\n            if os.path.exists(version_file):\n                with open(version_file, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n        except Exception as e:\n            self.logger.warning(f\"Impossible de charger version.json: {e}\")\n        \n        # Valeurs par d√©faut si le fichier n'est pas trouv√©\n        return {\n            \"version\": \"1.0.0\",\n            \"release_date\": \"2025-09-07\",\n            \"last_update\": \"2025-09-07\",\n            \"build\": \"1000\",\n            \"status\": \"stable\"\n        }\n\n    def _on_system_status_change(self, status, details):\n        \"\"\"Callback appel√© lors des changements d'√©tat du syst√®me\"\"\"\n        try:\n            self.system_status = status\n            \n            # Mise √† jour de l'indicateur visuel\n            if status == \"active\":\n                self.status_icon.configure(text=\"‚ñ∂Ô∏è\")\n                self.status_text.configure(text=\"Analyse en cours\", text_color=\"green\")\n                if details and 'platform' in details:\n                    platform_name = details['platform'] or \"Inconnue\"\n                    platform_info = self.app_manager.platform_detector.supported_platforms.get(\n                        platform_name, {'name': platform_name}\n                    )\n                    self.platform_label.configure(\n                        text=f\"Plateforme: {platform_info['name']}\", \n                        text_color=\"lightgreen\"\n                    )\n                \n            elif status == \"waiting\":\n                self.status_icon.configure(text=\"‚è∏Ô∏è\")\n                self.status_text.configure(text=\"En attente de plateforme poker\", text_color=\"orange\")\n                self.platform_label.configure(text=\"Aucune plateforme d√©tect√©e\", text_color=\"gray\")\n            \n            elif status == \"paused\":\n                self.status_icon.configure(text=\"‚è∏Ô∏è\")\n                self.status_text.configure(text=\"En pause\", text_color=\"yellow\")\n                self.platform_label.configure(text=\"Plateforme ferm√©e\", text_color=\"gray\")\n            \n            self.logger.info(f\"√âtat syst√®me mis √† jour: {status}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur mise √† jour status: {e}\")\n    \n    def update_interface(self):\n        \"\"\"Met √† jour l'interface avec les derni√®res donn√©es\"\"\"\n        try:\n            # R√©cup√©ration de l'√©tat du jeu\n            game_state = self.app_manager.get_current_state()\n            if game_state:\n                # Mise √† jour √©tat du jeu\n                if game_state.hero_cards and game_state.hero_cards != (\"\", \"\"):\n                    self.hero_cards_value.configure(text=f\"{game_state.hero_cards[0]} {game_state.hero_cards[1]}\")\n                \n                if game_state.board_cards:\n                    board_text = \" \".join(game_state.board_cards[:5])\n                    self.board_cards_value.configure(text=board_text or \"-- -- -- -- --\")\n                \n                # Utiliser le formatage appropri√© selon le type de table\n                table_type = getattr(game_state, 'table_type', 'cashgame')\n                if table_type == \"tournament\":\n                    self.pot_size_value.configure(text=f\"{game_state.pot_size:.0f}\")\n                    self.stack_value.configure(text=f\"{game_state.hero_stack:.0f}\")\n                else:\n                    self.pot_size_value.configure(text=f\"{game_state.pot_size:.2f}‚Ç¨\")\n                    self.stack_value.configure(text=f\"{game_state.hero_stack:.2f}‚Ç¨\")\n            \n            # R√©cup√©ration des recommandations\n            recommendation = self.app_manager.get_recommendation()\n            if recommendation:\n                win_prob = recommendation.get('win_probability', 50.0)\n                self.win_prob_value.configure(text=f\"{win_prob:.1f}%\")\n                self.win_prob_progress.set(win_prob / 100.0)\n                \n                action = recommendation.get('action_type', 'check')\n                self.action_value.configure(text=action.title())\n                \n                # Couleur selon l'action\n                action_colors = {\n                    'fold': 'red',\n                    'check': 'yellow',\n                    'call': 'yellow',\n                    'bet': 'green',\n                    'raise': 'green',\n                    'bet_small': 'orange',\n                    'bet_medium': 'orange',\n                    'bet_large': 'green',\n                    'bet_allin': 'red'\n                }\n                color = action_colors.get(action, 'white')\n                self.action_value.configure(text_color=color)\n                \n                risk = recommendation.get('risk_level', 50.0)\n                self.risk_value.configure(text=f\"{risk:.0f}%\")\n            \n            # R√©cup√©ration des statistiques\n            stats = self.app_manager.get_statistics()\n            if stats:\n                self.hands_played_value.configure(text=str(stats.get('hands_played', 0)))\n                self.hands_won_value.configure(text=str(stats.get('hands_won', 0)))\n                \n                win_rate = stats.get('win_rate', 0.0)\n                self.win_rate_value.configure(text=f\"{win_rate:.1f}%\")\n                \n                performance_ratio = stats.get('performance_ratio', 0.0)\n                self.performance_value.configure(text=f\"{performance_ratio:.1f}%\")\n                self.performance_progress.set(min(performance_ratio / 100.0, 1.0))\n            \n            # Mise √† jour des informations syst√®me dans le panel\n            self._update_system_info()\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur mise √† jour interface: {e}\")\n    \n    def change_table_type(self, selection: str):\n        \"\"\"Change le type de table\"\"\"\n        try:\n            table_type = \"cashgame\" if \"Cash\" in selection else \"tournament\"\n            self.app_manager.update_settings({'table_type': table_type})\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur changement type table: {e}\")\n    \n    def update_risk_override(self, value: float):\n        \"\"\"Met √† jour le pourcentage de risque manuel\"\"\"\n        try:\n            risk_percent = int(value)\n            self.risk_value_label.configure(text=f\"{risk_percent}%\")\n            \n            if not self.auto_risk_check.get():\n                self.app_manager.manual_override(risk_percent)\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur mise √† jour risque: {e}\")\n    \n    def toggle_auto_risk(self):\n        \"\"\"Active/d√©sactive la gestion automatique du risque\"\"\"\n        try:\n            auto_risk = self.auto_risk_check.get()\n            self.app_manager.update_settings({'manual_risk_override': not auto_risk})\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur toggle auto risque: {e}\")\n    \n    def toggle_gpu(self):\n        \"\"\"Active/d√©sactive le GPU\"\"\"\n        try:\n            gpu_enabled = self.gpu_check.get()\n            self.app_manager.update_settings({'gpu_enabled': gpu_enabled})\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur toggle GPU: {e}\")\n    \n    def toggle_resource_management(self):\n        \"\"\"Active/d√©sactive la gestion automatique des ressources\"\"\"\n        try:\n            auto_mgmt = self.resource_mgmt_check.get()\n            self.app_manager.update_settings({'auto_resource_management': auto_mgmt})\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur toggle gestion ressources: {e}\")\n    \n    def start_update_loop(self):\n        \"\"\"D√©marre la boucle de mise √† jour de l'interface\"\"\"\n        def update_loop():\n            while self.is_running:\n                try:\n                    if self.is_running and hasattr(self, 'root') and self.root:\n                        self.root.after(0, self.update_interface)\n                    time.sleep(0.5)  # Mise √† jour toutes les 500ms\n                    \n                except Exception as e:\n                    self.logger.error(f\"Erreur boucle mise √† jour: {e}\")\n                    time.sleep(1)\n                    \n            # Sortie propre du thread quand is_running devient False\n        \n        self.update_thread = threading.Thread(target=update_loop, daemon=True)\n        self.update_thread.start()\n    \n    def run(self):\n        \"\"\"Lance l'interface graphique\"\"\"\n        try:\n            self.logger.info(\"Lancement de l'interface graphique\")\n            self.root.protocol(\"WM_DELETE_WINDOW\", self.on_closing)\n            self.root.mainloop()\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur interface graphique: {e}\")\n    \n    def on_closing(self):\n        \"\"\"Gestion de la fermeture de l'application\"\"\"\n        try:\n            if self.is_running:\n                if hasattr(self, 'is_running') and self.is_running:\n                    self.is_running = False\n            \n            self.root.quit()\n            self.root.destroy()\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur fermeture: {e}\")\n        finally:\n            exit(0)\n\n# Alias pour compatibilit√©\nMainWindow = RTAPMainWindow","size_bytes":39407},"src/gui/rtpa_gui.py":{"content":"\"\"\"\nInterface graphique de RTPA Studio\nUtilise CustomTkinter pour une interface moderne\n\"\"\"\n\nimport tkinter as tk\nimport tkinter.ttk as ttk\nimport customtkinter as ctk\nimport threading\nimport time\nimport sys\nimport os\nfrom typing import Dict, Any, Optional, List\n\n# Configuration CustomTkinter\nctk.set_appearance_mode(\"dark\")\nctk.set_default_color_theme(\"blue\")\n\nclass RTAPGUIWindow:\n    \"\"\"Interface graphique principale de RTPA Studio\"\"\"\n    \n    def __init__(self, app_manager):\n        \"\"\"Initialise l'interface graphique\"\"\"\n        self.app_manager = app_manager\n        self.running = False\n        self.update_thread = None\n        \n        # Variables pour le stockage des √©l√©ments GUI\n        self.players_list_frame = None\n        self.active_players_count = None\n        self.hero_name_label = None\n        self.hero_stack_label = None\n        self.hero_position_label = None\n        \n        # Fen√™tre principale\n        self.root = ctk.CTk()\n        self.root.title(\"RTPA Studio - Real-Time Poker Assistant\")\n        self.root.geometry(\"1400x900\")\n        self.root.minsize(1200, 800)\n        \n        # Configuration Windows sp√©cifique pour le gestionnaire des t√¢ches\n        if sys.platform == \"win32\":\n            try:\n                import ctypes\n                from ctypes import wintypes\n                \n                # Obtenir le handle de la fen√™tre\n                def get_hwnd():\n                    def callback(hwnd, pid):\n                        if ctypes.windll.user32.GetWindowThreadProcessId(hwnd, ctypes.byref(wintypes.DWORD())) == os.getpid():\n                            return hwnd\n                        return True\n                    \n                    return ctypes.windll.user32.EnumWindows(callback, 0)\n                \n                # D√©finir l'ic√¥ne et le titre de l'application\n                self.root.after(100, self._set_windows_properties)\n                \n            except ImportError:\n                pass\n            except Exception:\n                pass\n        \n        # Variables de contr√¥le pour les sliders\n        self.cpu_limit = None\n        self.ram_limit = None\n        self.cpu_value_label = None\n        self.ram_value_label = None\n        \n        # Interface utilisateur\n        self.create_interface()\n        \n        # Configuration de l'√©v√©nement de fermeture\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.on_closing)\n    \n    def _set_windows_properties(self):\n        \"\"\"Configure les propri√©t√©s Windows pour une meilleure identification\"\"\"\n        if sys.platform == \"win32\":\n            try:\n                import ctypes\n                from ctypes import wintypes\n                \n                # Essayer de d√©finir le nom de classe de la fen√™tre\n                hwnd = self.root.winfo_id()\n                if hwnd:\n                    # D√©finir le titre de la fen√™tre pour le gestionnaire des t√¢ches\n                    ctypes.windll.user32.SetWindowTextW(hwnd, \"RTPA Studio\")\n                    \n            except Exception as e:\n                pass  # Ignorer les erreurs de configuration Windows\n    \n    def create_interface(self):\n        \"\"\"Cr√©e tous les √©l√©ments de l'interface\"\"\"\n        \n        # Container principal pour l'affichage structur√©\n        self.main_frame = ctk.CTkFrame(self.root)\n        self.main_frame.pack(fill='both', expand=True, padx=10, pady=10)\n        \n        # Frame de contr√¥le compact en haut\n        self.controls_frame = ctk.CTkFrame(self.main_frame, height=80)\n        self.controls_frame.pack(fill='x', pady=(0, 10))\n        \n        # Ligne 1: Statut principal - Plus compact\n        self.status_label = ctk.CTkLabel(\n            self.controls_frame,\n            text=\"üéØ Real-Time Poker Assistant (CFR/Nash)\",\n            font=ctk.CTkFont(size=20, weight=\"bold\")\n        )\n        self.status_label.pack(pady=(10, 2))\n        \n        # Ligne 2: Activit√© du syst√®me - Espacement ultra-r√©duit\n        self.activity_status_label = ctk.CTkLabel(\n            self.controls_frame,\n            text=\"Surveillance active\",\n            font=ctk.CTkFont(size=13),\n            text_color=\"#666666\"  # Gris plus fonc√© pour meilleure lisibilit√©\n        )\n        self.activity_status_label.pack(pady=(1, 0))\n        \n        # Ligne 3: Temps restant CFR - Coll√© √† la ligne pr√©c√©dente\n        self.cfr_time_label = ctk.CTkLabel(\n            self.controls_frame,\n            text=\"\",\n            font=ctk.CTkFont(size=11, weight=\"bold\"),\n            text_color=\"black\"  # Noir pour meilleure lisibilit√©\n        )\n        self.cfr_time_label.pack(pady=(1, 3))\n        \n        # Notebook avec onglets\n        self.notebook = ttk.Notebook(self.main_frame)\n        self.notebook.pack(fill='both', expand=True)\n        \n        # Onglet 1: Tableau de Bord (principal)\n        self.dashboard_tab = ttk.Frame(self.notebook)\n        self.notebook.add(self.dashboard_tab, text=\"üìä Tableau de Bord\")\n        self.create_dashboard_tab()\n        \n        # Onglet 2: Options\n        self.options_tab = ttk.Frame(self.notebook)\n        self.notebook.add(self.options_tab, text=\"‚öôÔ∏è Options\")\n        self.create_options_tab()\n        \n        # Onglet 3: Param√®tres\n        self.settings_tab = ttk.Frame(self.notebook)\n        self.notebook.add(self.settings_tab, text=\"üîß Param√®tres\")\n        self.create_settings_tab()\n        \n        # Onglet 4: Performance\n        self.performance_tab = ttk.Frame(self.notebook)\n        self.notebook.add(self.performance_tab, text=\"‚ö° Performance\")\n        self.create_performance_tab()\n        \n        # Onglet 5: Version (dernier √† droite)\n        self.version_tab = ttk.Frame(self.notebook)\n        self.notebook.add(self.version_tab, text=\"üìå Version\")\n        self.create_version_tab()\n        \n        # Charger les param√®tres sauvegard√©s apr√®s cr√©ation des √©l√©ments\n        self.load_saved_settings()\n    \n    def create_dashboard_tab(self):\n        \"\"\"Cr√©ation de l'onglet Tableau de Bord complet (√©tat du jeu + recommandations + statistiques)\"\"\"\n        \n        # Frame principal optimis√© (plus compact)\n        main_container = ttk.Frame(self.dashboard_tab)\n        main_container.pack(fill='both', expand=True, padx=10, pady=10)\n        \n        # SECTION 1: CARTES (Main et Board c√¥te √† c√¥te)\n        cards_container = ttk.Frame(main_container)\n        cards_container.pack(fill='x', pady=(0, 10))\n        \n        # Section Main (compacte, √† gauche)\n        hero_frame = ttk.LabelFrame(cards_container, text=\"üÇ° Main\", style='Card.TFrame')\n        hero_frame.pack(side='left', padx=(0, 10), fill='y')\n        \n        self.hero_cards_frame = tk.Frame(hero_frame, bg='#dbdbdb')\n        self.hero_cards_frame.pack(padx=8, pady=10)\n        \n        # Cartes visuelles Main\n        self.hero_card1_frame = tk.Frame(\n            self.hero_cards_frame, \n            bg='#dbdbdb', relief='raised', bd=2, width=90, height=120\n        )\n        self.hero_card1_frame.pack(side='left', padx=5)\n        self.hero_card1_frame.pack_propagate(False)\n        \n        self.hero_card1 = tk.Label(\n            self.hero_card1_frame, text=\"üÇ†\", font=('Arial', 28, 'bold'),\n            fg='#5a5a5a', bg='#dbdbdb', anchor='center'\n        )\n        self.hero_card1.pack(expand=True, fill='both')\n        \n        self.hero_card2_frame = tk.Frame(\n            self.hero_cards_frame, \n            bg='#dbdbdb', relief='raised', bd=2, width=90, height=120\n        )\n        self.hero_card2_frame.pack(side='left', padx=5)\n        self.hero_card2_frame.pack_propagate(False)\n        \n        self.hero_card2 = tk.Label(\n            self.hero_card2_frame, text=\"üÇ†\", font=('Arial', 28, 'bold'),\n            fg='#5a5a5a', bg='#dbdbdb', anchor='center'\n        )\n        self.hero_card2.pack(expand=True, fill='both')\n        \n        # Section Board (compacte, au milieu)\n        board_frame = ttk.LabelFrame(cards_container, text=\"üÉè Board\", style='Card.TFrame')\n        board_frame.pack(side='left', padx=(0, 10), fill='both', expand=True)\n        \n        # Layout horizontal pour les 5 cartes du board\n        self.board_cards_frame = tk.Frame(board_frame, bg='#dbdbdb')\n        self.board_cards_frame.pack(padx=8, pady=10)\n        \n        # Cr√©er 5 cartes du board (plus petites que les cartes main)\n        self.board_cards = []\n        for i in range(5):\n            card_frame = tk.Frame(\n                self.board_cards_frame, \n                bg='#dbdbdb', relief='raised', bd=2, width=70, height=95\n            )\n            card_frame.pack(side='left', padx=3)\n            card_frame.pack_propagate(False)\n            \n            card_label = tk.Label(\n                card_frame, text=\"üÇ†\", font=('Arial', 20, 'bold'),\n                fg='#5a5a5a', bg='#dbdbdb', anchor='center'\n            )\n            card_label.pack(expand=True, fill='both')\n            self.board_cards.append(card_label)\n        \n        # SECTION 2: LAYOUT PRINCIPAL AVEC COLONNES\n        columns_container = ttk.Frame(main_container)\n        columns_container.pack(fill='both', expand=True)\n        \n        # Colonne gauche: Informations principales\n        left_column = ttk.Frame(columns_container)\n        left_column.pack(side='left', fill='both', expand=True, padx=(0, 10))\n        \n        # SECTION 2A: INFORMATIONS DE TABLE\n        table_info_frame = ttk.LabelFrame(left_column, text=\"üí∞ POT ACTUEL\", style='Card.TFrame')\n        table_info_frame.pack(fill='x', pady=(0, 10))\n        \n        # Pot size centr√© et gros\n        self.pot_value = tk.Label(table_info_frame, text=\"0.0\", font=('Arial', 32, 'bold'),\n                                 fg='#00b300', bg='#f0f0f0')\n        self.pot_value.pack(pady=15)\n        \n        # Infos compl√©mentaires en ligne\n        info_line = tk.Frame(table_info_frame, bg='#f0f0f0')\n        info_line.pack(fill='x', padx=15, pady=(0, 15))\n        \n        tk.Label(info_line, text=\"Blinds:\", font=('Arial', 9), bg='#f0f0f0').pack(side='left')\n        self.blinds_label = tk.Label(info_line, text=\"0.00‚Ç¨ / 0.00‚Ç¨\", font=('Arial', 9, 'bold'), \n                                    bg='#f0f0f0', fg='#666')\n        self.blinds_label.pack(side='left', padx=(5, 20))\n        \n        tk.Label(info_line, text=\"Antes:\", font=('Arial', 9), bg='#f0f0f0').pack(side='left')\n        self.antes_label = tk.Label(info_line, text=\"0.00‚Ç¨\", font=('Arial', 9, 'bold'), \n                                   bg='#f0f0f0', fg='#666')\n        self.antes_label.pack(side='left', padx=(5, 20))\n        \n        # Type de jeu √† droite\n        type_frame = tk.Frame(info_line, bg='#f0f0f0')\n        type_frame.pack(side='right')\n        self.game_type_label = tk.Label(type_frame, text=\"cashgame\", font=('Arial', 9, 'italic'), \n                                       bg='#f0f0f0', fg='#666')\n        self.game_type_label.pack()\n        \n        # SECTION 2B: RECOMMANDATION\n        rec_frame = ttk.LabelFrame(left_column, text=\"üéØ RECOMMANDATION\", style='Card.TFrame')\n        rec_frame.pack(fill='x', pady=(0, 10))\n        \n        # Action recommand√©e en gros\n        self.action_label = tk.Label(rec_frame, text=\"---\", font=('Arial', 24, 'bold'),\n                                    fg='#ff6600', bg='#f0f0f0')\n        self.action_label.pack(pady=(10, 5))\n        \n        # D√©tails recommandation en ligne\n        rec_details = tk.Frame(rec_frame, bg='#f0f0f0')\n        rec_details.pack(fill='x', padx=15, pady=(0, 15))\n        \n        # Probabilit√© de victoire et taille de mise\n        left_rec = tk.Frame(rec_details, bg='#f0f0f0')\n        left_rec.pack(side='left')\n        \n        tk.Label(left_rec, text=\"Victoire:\", font=('Arial', 10), bg='#f0f0f0').pack(anchor='w')\n        self.win_prob_label = tk.Label(left_rec, text=\"--\", font=('Arial', 10, 'bold'), \n                                      fg='#00b300', bg='#f0f0f0')\n        self.win_prob_label.pack(anchor='w')\n        \n        # Niveau de risque au centre\n        center_rec = tk.Frame(rec_details, bg='#f0f0f0')\n        center_rec.pack(side='left', padx=30)\n        \n        tk.Label(center_rec, text=\"Risque:\", font=('Arial', 10), bg='#f0f0f0').pack(anchor='w')\n        self.risk_label = tk.Label(center_rec, text=\"--\", font=('Arial', 10, 'bold'), \n                                  fg='#ff3300', bg='#f0f0f0')\n        self.risk_label.pack(anchor='w')\n        \n        # Confiance √† droite\n        right_rec = tk.Frame(rec_details, bg='#f0f0f0')\n        right_rec.pack(side='right')\n        \n        tk.Label(right_rec, text=\"Confiance:\", font=('Arial', 10), bg='#f0f0f0').pack(anchor='w')\n        self.confidence_label = tk.Label(right_rec, text=\"--\", font=('Arial', 10, 'bold'), \n                                        fg='#0066ff', bg='#f0f0f0')\n        self.confidence_label.pack(anchor='w')\n        \n        # Raisonnement (s√©par√© et plus visible)\n        reasoning_frame = tk.Frame(rec_frame, bg='#f8f8f8', relief='sunken', bd=1)\n        reasoning_frame.pack(fill='x', padx=15, pady=(5, 15))\n        \n        tk.Label(reasoning_frame, text=\"üí≠ Raisonnement:\", font=('Arial', 9, 'bold'),\n                bg='#f8f8f8').pack(anchor='w', padx=8, pady=(5, 2))\n        \n        self.reasoning_label = tk.Label(reasoning_frame, text=\"En attente d'analyse...\", \n                                      font=('Arial', 9), bg='#f8f8f8', fg='#444', \n                                      wraplength=400, justify='left')\n        self.reasoning_label.pack(anchor='w', padx=8, pady=(0, 8))\n        \n        # Colonne droite: Informations joueurs\n        right_column = ttk.Frame(columns_container)\n        right_column.pack(side='right', fill='y', padx=(0, 0))\n        \n        # SECTION 4A: MES INFORMATIONS\n        hero_info_frame = ttk.LabelFrame(right_column, text=\"üë§ MOI\", style='Card.TFrame')\n        hero_info_frame.pack(fill='x', pady=(0, 10))\n        \n        # Pseudo\n        pseudo_frame = tk.Frame(hero_info_frame, bg='#f0f0f0')\n        pseudo_frame.pack(fill='x', padx=10, pady=5)\n        tk.Label(pseudo_frame, text=\"Pseudo:\", font=('Arial', 10), bg='#f0f0f0').pack(side='left')\n        self.hero_name_label = tk.Label(pseudo_frame, text=\"---\", font=('Arial', 10, 'bold'), \n                                       bg='#f0f0f0')\n        self.hero_name_label.pack(side='left', padx=(10, 0))\n        \n        # Stack\n        stack_frame = tk.Frame(hero_info_frame, bg='#f0f0f0')\n        stack_frame.pack(fill='x', padx=10, pady=5)\n        tk.Label(stack_frame, text=\"Mon Stack:\", font=('Arial', 10), bg='#f0f0f0').pack(side='left')\n        self.hero_stack_label = tk.Label(stack_frame, text=\"0.00‚Ç¨\", font=('Arial', 10, 'bold'), \n                                        bg='#f0f0f0')\n        self.hero_stack_label.pack(side='left', padx=(10, 0))\n        \n        # Position\n        pos_frame = tk.Frame(hero_info_frame, bg='#f0f0f0')\n        pos_frame.pack(fill='x', padx=10, pady=5)\n        tk.Label(pos_frame, text=\"Position:\", font=('Arial', 10), bg='#f0f0f0').pack(side='left')\n        self.hero_position_label = tk.Label(pos_frame, text=\"---\", font=('Arial', 10, 'bold'), \n                                           bg='#f0f0f0')\n        self.hero_position_label.pack(side='left', padx=(10, 0))\n        \n        # SECTION 4B: AUTRES JOUEURS ACTIFS\n        players_frame = ttk.LabelFrame(right_column, text=\"üë• AUTRES JOUEURS\", style='Card.TFrame')\n        players_frame.pack(fill='both', expand=True, pady=(0, 10))\n        \n        # Compteur de joueurs actifs en haut\n        players_header = tk.Frame(players_frame, bg='#f0f0f0')\n        players_header.pack(fill='x', padx=5, pady=5)\n        \n        tk.Label(players_header, text=\"Actifs:\", font=('Arial', 10, 'bold'), bg='#f0f0f0').pack(side='left')\n        self.active_players_count = tk.Label(players_header, text=\"0/9\", font=('Arial', 10, 'bold'), \n                                            fg='#00b300', bg='#f0f0f0')\n        self.active_players_count.pack(side='left', padx=(5, 0))\n        \n        # Frame simple pour la liste des joueurs (sans scroll)\n        self.players_list_frame = tk.Frame(players_frame, bg='#f0f0f0')\n        self.players_list_frame.pack(fill='both', expand=True, padx=5, pady=(0, 10))\n        \n        # Cr√©er la liste des joueurs (vide par d√©faut)\n        self.create_players_display()\n        \n        # SECTION 4C: STATISTIQUES\n        stats_frame = ttk.LabelFrame(right_column, text=\"üìä STATISTIQUES\", style='Card.TFrame')\n        stats_frame.pack(fill='x')\n        \n        # Ligne 1: Taux de victoire\n        win_rate_frame = tk.Frame(stats_frame, bg='#f0f0f0')\n        win_rate_frame.pack(fill='x', padx=10, pady=2)\n        tk.Label(win_rate_frame, text=\"TAUX DE VICTOIRE\", font=('Arial', 8, 'bold'), bg='#f0f0f0').pack()\n        self.win_rate_value = tk.Label(win_rate_frame, text=\"0.0%\", font=('Arial', 12, 'bold'), \n                                      fg='#00b300', bg='#f0f0f0')\n        self.win_rate_value.pack()\n        \n        # Ligne 2: Mains\n        hands_frame = tk.Frame(stats_frame, bg='#f0f0f0')\n        hands_frame.pack(fill='x', padx=10, pady=2)\n        \n        played_frame = tk.Frame(hands_frame, bg='#f0f0f0')\n        played_frame.pack(side='left', fill='x', expand=True)\n        tk.Label(played_frame, text=\"üéÆ Jou√©es\", font=('Arial', 8), bg='#f0f0f0').pack()\n        self.hands_played = tk.Label(played_frame, text=\"0\", font=('Arial', 10, 'bold'), bg='#f0f0f0')\n        self.hands_played.pack()\n        \n        won_frame = tk.Frame(hands_frame, bg='#f0f0f0')\n        won_frame.pack(side='right', fill='x', expand=True)\n        tk.Label(won_frame, text=\"‚úÖ Gagn√©es\", font=('Arial', 8), bg='#f0f0f0').pack()\n        self.hands_won = tk.Label(won_frame, text=\"0\", font=('Arial', 10, 'bold'), fg='#00b300', bg='#f0f0f0')\n        self.hands_won.pack()\n        \n        # Ligne 3: Performance vs attendu\n        perf_frame = tk.Frame(stats_frame, bg='#f0f0f0')\n        perf_frame.pack(fill='x', padx=10, pady=(2, 10))\n        \n        expected_frame = tk.Frame(perf_frame, bg='#f0f0f0')\n        expected_frame.pack(side='left', fill='x', expand=True)\n        tk.Label(expected_frame, text=\"üéØ Attendu\", font=('Arial', 8), bg='#f0f0f0').pack()\n        self.expected_rate = tk.Label(expected_frame, text=\"0.7%\", font=('Arial', 10, 'bold'), \n                                     fg='#666', bg='#f0f0f0')\n        self.expected_rate.pack()\n        \n        performance_frame = tk.Frame(perf_frame, bg='#f0f0f0')\n        performance_frame.pack(side='right', fill='x', expand=True)\n        tk.Label(performance_frame, text=\"üìà Performance\", font=('Arial', 8), bg='#f0f0f0').pack()\n        self.performance_value = tk.Label(performance_frame, text=\"0.0%\", font=('Arial', 10, 'bold'), \n                                         fg='#0066ff', bg='#f0f0f0')\n        self.performance_value.pack()\n    \n    def create_options_tab(self):\n        \"\"\"Cr√©ation de l'onglet Options avec contr√¥les avanc√©s\"\"\"\n        \n        # Container principal\n        options_container = ctk.CTkScrollableFrame(self.options_tab)\n        options_container.pack(fill='both', expand=True, padx=20, pady=20)\n        \n        # === SECTION CFR ===\n        cfr_frame = ctk.CTkFrame(options_container)\n        cfr_frame.pack(fill='x', pady=(0, 20))\n        \n        ctk.CTkLabel(cfr_frame, text=\"üß† Param√®tres CFR\", font=ctk.CTkFont(size=16, weight=\"bold\")).pack(pady=(15, 10))\n        \n        # It√©rations CFR\n        iter_frame = ctk.CTkFrame(cfr_frame)\n        iter_frame.pack(fill='x', padx=20, pady=(0, 10))\n        \n        ctk.CTkLabel(iter_frame, text=\"It√©rations CFR:\", font=ctk.CTkFont(weight=\"bold\")).pack(side='left', padx=(10, 20))\n        self.cfr_iterations = ctk.CTkSlider(iter_frame, from_=1000, to=100000, command=self.update_cfr_iterations)\n        self.cfr_iterations.pack(side='left', padx=10, fill='x', expand=True)\n        self.cfr_iterations.set(10000)\n        \n        self.cfr_iter_label = ctk.CTkLabel(iter_frame, text=\"10000\", font=ctk.CTkFont(weight=\"bold\"))\n        self.cfr_iter_label.pack(side='left', padx=10)\n        \n        # Description\n        ctk.CTkLabel(iter_frame, text=\"Plus d'it√©rations = meilleure pr√©cision mais plus lent\", \n                    font=ctk.CTkFont(size=10), text_color=\"gray\").pack(side='right', padx=10)\n        \n        # Sampling CFR\n        sampling_frame = ctk.CTkFrame(cfr_frame)\n        sampling_frame.pack(fill='x', padx=20, pady=(0, 15))\n        \n        self.cfr_sampling = ctk.CTkCheckBox(sampling_frame, text=\"Sampling CFR (plus rapide)\", \n                                           command=self.toggle_cfr_sampling)\n        self.cfr_sampling.pack(side='left', padx=20, pady=15)\n        self.cfr_sampling.select()  # Activ√© par d√©faut\n        \n        # === SECTION OCR ===\n        ocr_frame = ctk.CTkFrame(options_container)\n        ocr_frame.pack(fill='x', pady=(0, 20))\n        \n        ctk.CTkLabel(ocr_frame, text=\"üëÅÔ∏è Param√®tres OCR\", font=ctk.CTkFont(size=16, weight=\"bold\")).pack(pady=(15, 10))\n        \n        # Intervalle OCR\n        ocr_interval_frame = ctk.CTkFrame(ocr_frame)\n        ocr_interval_frame.pack(fill='x', padx=20, pady=(0, 10))\n        \n        ctk.CTkLabel(ocr_interval_frame, text=\"Intervalle capture:\", font=ctk.CTkFont(weight=\"bold\")).pack(side='left', padx=(10, 20))\n        self.ocr_interval = ctk.CTkSlider(ocr_interval_frame, from_=50, to=500, command=self.update_ocr_interval)\n        self.ocr_interval.pack(side='left', padx=10, fill='x', expand=True)\n        self.ocr_interval.set(100)\n        \n        self.ocr_interval_label = ctk.CTkLabel(ocr_interval_frame, text=\"100ms\", font=ctk.CTkFont(weight=\"bold\"))\n        self.ocr_interval_label.pack(side='left', padx=10)\n        \n        # Confiance OCR\n        confidence_frame = ctk.CTkFrame(ocr_frame)\n        confidence_frame.pack(fill='x', padx=20, pady=(0, 15))\n        \n        ctk.CTkLabel(confidence_frame, text=\"Confiance minimale:\", font=ctk.CTkFont(weight=\"bold\")).pack(side='left', padx=(10, 20))\n        self.ocr_confidence = ctk.CTkSlider(confidence_frame, from_=0.1, to=1.0, command=self.update_ocr_confidence)\n        self.ocr_confidence.pack(side='left', padx=10, fill='x', expand=True)\n        self.ocr_confidence.set(0.8)\n        \n        self.ocr_confidence_label = ctk.CTkLabel(confidence_frame, text=\"80%\", font=ctk.CTkFont(weight=\"bold\"))\n        self.ocr_confidence_label.pack(side='left', padx=10)\n        \n        # === SECTION INTERFACE ===\n        ui_frame = ctk.CTkFrame(options_container)\n        ui_frame.pack(fill='x', pady=(0, 20))\n        \n        ctk.CTkLabel(ui_frame, text=\"üñ•Ô∏è Interface utilisateur\", font=ctk.CTkFont(size=16, weight=\"bold\")).pack(pady=(15, 10))\n        \n        # Langue\n        lang_frame = ctk.CTkFrame(ui_frame)\n        lang_frame.pack(fill='x', padx=20, pady=(0, 10))\n        \n        ctk.CTkLabel(lang_frame, text=\"Langue:\", font=ctk.CTkFont(weight=\"bold\")).pack(side='left', padx=(10, 20))\n        self.language_combo = ctk.CTkComboBox(lang_frame, values=[\"Fran√ßais\", \"English\"], \n                                             command=self.change_language)\n        self.language_combo.pack(side='left', padx=10)\n        self.language_combo.set(\"Fran√ßais\")\n        \n        # Checkboxes d'affichage\n        checkboxes_frame = ctk.CTkFrame(ui_frame)\n        checkboxes_frame.pack(fill='x', padx=20, pady=(0, 15))\n        \n        self.show_probabilities = ctk.CTkCheckBox(checkboxes_frame, text=\"Afficher probabilit√©s\")\n        self.show_probabilities.pack(side='left', padx=20, pady=10)\n        self.show_probabilities.select()\n        \n        self.show_recommendations = ctk.CTkCheckBox(checkboxes_frame, text=\"Afficher recommandations\")\n        self.show_recommendations.pack(side='left', padx=20, pady=10)\n        self.show_recommendations.select()\n        \n        self.show_statistics = ctk.CTkCheckBox(checkboxes_frame, text=\"Afficher statistiques\")\n        self.show_statistics.pack(side='left', padx=20, pady=10)\n        self.show_statistics.select()\n        \n        # === SECTION JEU ===\n        game_frame = ctk.CTkFrame(options_container)\n        game_frame.pack(fill='x')\n        \n        ctk.CTkLabel(game_frame, text=\"üé∞ Param√®tres de jeu\", font=ctk.CTkFont(size=16, weight=\"bold\")).pack(pady=(15, 10))\n        \n        # Type de table par d√©faut\n        table_type_frame = ctk.CTkFrame(game_frame)\n        table_type_frame.pack(fill='x', padx=20, pady=(0, 10))\n        \n        ctk.CTkLabel(table_type_frame, text=\"Type de table:\", font=ctk.CTkFont(weight=\"bold\")).pack(side='left', padx=(10, 20))\n        self.table_type_combo = ctk.CTkComboBox(table_type_frame, values=[\"Cash Game\", \"Tournament\"], \n                                               command=self.change_table_type)\n        self.table_type_combo.pack(side='left', padx=10)\n        self.table_type_combo.set(\"Cash Game\")\n        \n        # Objectif de mains\n        target_frame = ctk.CTkFrame(game_frame)\n        target_frame.pack(fill='x', padx=20, pady=(0, 15))\n        \n        ctk.CTkLabel(target_frame, text=\"Objectif mains/100:\", font=ctk.CTkFont(weight=\"bold\")).pack(side='left', padx=(10, 20))\n        self.target_hands = ctk.CTkSlider(target_frame, from_=50, to=80, command=self.update_target_hands)\n        self.target_hands.pack(side='left', padx=10, fill='x', expand=True)\n        self.target_hands.set(65)\n        \n        self.target_hands_label = ctk.CTkLabel(target_frame, text=\"65\", font=ctk.CTkFont(weight=\"bold\"))\n        self.target_hands_label.pack(side='left', padx=10)\n\n    def create_settings_tab(self):\n        \"\"\"Cr√©ation de l'onglet Param√®tres avec gestion des ressources\"\"\"\n        \n        # Container principal avec scroll\n        settings_container = ctk.CTkScrollableFrame(self.settings_tab)\n        settings_container.pack(fill='both', expand=True, padx=20, pady=20)\n        \n        # === SECTION RESSOURCES ===\n        resource_frame = ctk.CTkFrame(settings_container)\n        resource_frame.pack(fill='x', pady=(0, 20))\n        \n        ctk.CTkLabel(resource_frame, text=\"‚ö° Gestion des ressources\", font=ctk.CTkFont(size=18, weight=\"bold\")).pack(pady=(20, 15))\n        \n        # Limite CPU\n        cpu_frame = ctk.CTkFrame(resource_frame)\n        cpu_frame.pack(fill='x', padx=20, pady=(0, 10))\n        \n        ctk.CTkLabel(cpu_frame, text=\"Limite CPU:\", font=ctk.CTkFont(weight=\"bold\")).pack(side='left', padx=(10, 20))\n        self.cpu_limit = ctk.CTkSlider(cpu_frame, from_=10, to=100, command=self.update_cpu_value)\n        self.cpu_limit.pack(side='left', padx=10, fill='x', expand=True)\n        self.cpu_limit.set(80)\n        \n        # Affichage valeur\n        self.cpu_value_label = ctk.CTkLabel(cpu_frame, text=\"80%\", font=ctk.CTkFont(weight=\"bold\"))\n        self.cpu_value_label.pack(side='left', padx=10)\n        \n        # Description\n        ctk.CTkLabel(cpu_frame, text=\"Limite d'usage CPU pour pr√©server les performances\", \n                    font=ctk.CTkFont(size=10), text_color=\"gray\").pack(side='right', padx=10)\n        \n        # Limite RAM\n        ram_frame = ctk.CTkFrame(resource_frame)\n        ram_frame.pack(fill='x', padx=20, pady=(0, 15))\n        \n        ctk.CTkLabel(ram_frame, text=\"Limite RAM:\", font=ctk.CTkFont(weight=\"bold\")).pack(side='left', padx=(10, 20))\n        self.ram_limit = ctk.CTkSlider(ram_frame, from_=1, to=16, command=self.update_ram_value)\n        self.ram_limit.pack(side='left', padx=10, fill='x', expand=True)\n        self.ram_limit.set(8)\n        \n        # Affichage valeur\n        self.ram_value_label = ctk.CTkLabel(ram_frame, text=\"8.0 GB\", font=ctk.CTkFont(weight=\"bold\"))\n        self.ram_value_label.pack(side='left', padx=10)\n        \n        # Description\n        ctk.CTkLabel(ram_frame, text=\"Limite m√©moire pour les calculs CFR et donn√©es\", \n                    font=ctk.CTkFont(size=10), text_color=\"gray\").pack(side='right', padx=10)\n        \n        # === SECTION GPU ===\n        gpu_frame = ctk.CTkFrame(settings_container)\n        gpu_frame.pack(fill='x', pady=(0, 20))\n        \n        ctk.CTkLabel(gpu_frame, text=\"üéÆ Param√®tres GPU\", font=ctk.CTkFont(size=18, weight=\"bold\")).pack(pady=(20, 15))\n        \n        # Activation GPU\n        gpu_enable_frame = ctk.CTkFrame(gpu_frame)\n        gpu_enable_frame.pack(fill='x', padx=20, pady=(0, 10))\n        \n        self.gpu_enabled = ctk.CTkCheckBox(gpu_enable_frame, text=\"Activer l'acc√©l√©ration GPU\", \n                                          command=self.toggle_gpu)\n        self.gpu_enabled.pack(side='left', padx=20, pady=15)\n        \n        # Limite m√©moire GPU\n        gpu_mem_frame = ctk.CTkFrame(gpu_frame)\n        gpu_mem_frame.pack(fill='x', padx=20, pady=(0, 15))\n        \n        ctk.CTkLabel(gpu_mem_frame, text=\"Limite m√©moire GPU:\", font=ctk.CTkFont(weight=\"bold\")).pack(side='left', padx=(10, 20))\n        self.gpu_memory = ctk.CTkSlider(gpu_mem_frame, from_=20, to=95, command=self.update_gpu_memory)\n        self.gpu_memory.pack(side='left', padx=10, fill='x', expand=True)\n        self.gpu_memory.set(80)\n        \n        self.gpu_mem_label = ctk.CTkLabel(gpu_mem_frame, text=\"80%\", font=ctk.CTkFont(weight=\"bold\"))\n        self.gpu_mem_label.pack(side='left', padx=10)\n        \n        # === SECTION AVANC√â ===\n        advanced_frame = ctk.CTkFrame(settings_container)\n        advanced_frame.pack(fill='x')\n        \n        ctk.CTkLabel(advanced_frame, text=\"üîß Param√®tres avanc√©s\", font=ctk.CTkFont(size=18, weight=\"bold\")).pack(pady=(20, 15))\n        \n        # Gestion automatique des ressources\n        auto_mgmt_frame = ctk.CTkFrame(advanced_frame)\n        auto_mgmt_frame.pack(fill='x', padx=20, pady=(0, 10))\n        \n        self.auto_resource_mgmt = ctk.CTkCheckBox(auto_mgmt_frame, text=\"Gestion automatique des ressources\", \n                                                 command=self.toggle_auto_resource_mgmt)\n        self.auto_resource_mgmt.pack(side='left', padx=20, pady=15)\n        self.auto_resource_mgmt.select()  # Activ√© par d√©faut\n        \n        # Vitesse de g√©n√©ration\n        gen_rate_frame = ctk.CTkFrame(advanced_frame)\n        gen_rate_frame.pack(fill='x', padx=20, pady=(0, 15))\n        \n        ctk.CTkLabel(gen_rate_frame, text=\"Vitesse g√©n√©ration:\", font=ctk.CTkFont(weight=\"bold\")).pack(side='left', padx=(10, 20))\n        self.generation_rate = ctk.CTkSlider(gen_rate_frame, from_=1, to=10, command=self.update_generation_rate)\n        self.generation_rate.pack(side='left', padx=10, fill='x', expand=True)\n        self.generation_rate.set(7)\n        \n        self.gen_rate_label = ctk.CTkLabel(gen_rate_frame, text=\"7 (Rapide)\", font=ctk.CTkFont(weight=\"bold\"))\n        self.gen_rate_label.pack(side='left', padx=10)\n\n    def create_performance_tab(self):\n        \"\"\"Cr√©ation de l'onglet Performance avec m√©triques syst√®me\"\"\"\n        \n        # Container principal\n        perf_container = ctk.CTkFrame(self.performance_tab)\n        perf_container.pack(fill='both', expand=True, padx=20, pady=20)\n        \n        ctk.CTkLabel(perf_container, text=\"‚ö° Monitoring des performances\", \n                    font=ctk.CTkFont(size=20, weight=\"bold\")).pack(pady=(20, 15))\n        \n        # Notice PyTorch\n        notice_frame = ctk.CTkFrame(perf_container)\n        notice_frame.pack(fill='x', pady=(0, 20))\n        \n        ctk.CTkLabel(notice_frame, text=\"‚ÑπÔ∏è Information importante\", \n                    font=ctk.CTkFont(size=14, weight=\"bold\"), \n                    text_color=\"#1f538d\").pack(pady=(15, 5))\n        \n        ctk.CTkLabel(notice_frame, \n                    text=\"Le monitoring GPU avanc√© n√©cessite PyTorch install√©.\\nSans PyTorch, seules les m√©triques CPU et RAM basiques sont disponibles.\", \n                    font=ctk.CTkFont(size=12), \n                    text_color=\"gray\").pack(pady=(0, 15))\n        \n        # === M√âTRIQUES SYST√àME ===\n        system_frame = ctk.CTkFrame(perf_container)\n        system_frame.pack(fill='x', pady=(0, 20))\n        \n        ctk.CTkLabel(system_frame, text=\"üíª Syst√®me\", font=ctk.CTkFont(size=16, weight=\"bold\")).pack(pady=(15, 10))\n        \n        # M√©triques en grille\n        metrics_grid = ctk.CTkFrame(system_frame)\n        metrics_grid.pack(fill='x', padx=20, pady=(0, 20))\n        \n        # CPU\n        cpu_metric_frame = ctk.CTkFrame(metrics_grid)\n        cpu_metric_frame.pack(side='left', fill='x', expand=True, padx=(0, 10))\n        ctk.CTkLabel(cpu_metric_frame, text=\"CPU\", font=ctk.CTkFont(weight=\"bold\")).pack(pady=5)\n        self.cpu_usage_label = ctk.CTkLabel(cpu_metric_frame, text=\"0%\", font=ctk.CTkFont(size=16, weight=\"bold\"))\n        self.cpu_usage_label.pack(pady=5)\n        \n        # RAM\n        ram_metric_frame = ctk.CTkFrame(metrics_grid)\n        ram_metric_frame.pack(side='left', fill='x', expand=True, padx=5)\n        ctk.CTkLabel(ram_metric_frame, text=\"RAM\", font=ctk.CTkFont(weight=\"bold\")).pack(pady=5)\n        self.ram_usage_label = ctk.CTkLabel(ram_metric_frame, text=\"0 GB\", font=ctk.CTkFont(size=16, weight=\"bold\"))\n        self.ram_usage_label.pack(pady=5)\n        \n        # GPU (si disponible avec PyTorch)\n        gpu_metric_frame = ctk.CTkFrame(metrics_grid)\n        gpu_metric_frame.pack(side='right', fill='x', expand=True, padx=(10, 0))\n        ctk.CTkLabel(gpu_metric_frame, text=\"GPU*\", font=ctk.CTkFont(weight=\"bold\")).pack(pady=5)\n        self.gpu_usage_label = ctk.CTkLabel(gpu_metric_frame, text=\"N/A\", font=ctk.CTkFont(size=16, weight=\"bold\"))\n        self.gpu_usage_label.pack(pady=5)\n        \n        # Note pour GPU\n        ctk.CTkLabel(gpu_metric_frame, text=\"*PyTorch requis\", \n                    font=ctk.CTkFont(size=8), text_color=\"gray\").pack()\n        \n        # === M√âTRIQUES CFR ===\n        cfr_metrics_frame = ctk.CTkFrame(perf_container)\n        cfr_metrics_frame.pack(fill='x', pady=(0, 20))\n        \n        ctk.CTkLabel(cfr_metrics_frame, text=\"üß† CFR Engine\", font=ctk.CTkFont(size=16, weight=\"bold\")).pack(pady=(15, 10))\n        \n        # M√©triques CFR en grille\n        cfr_grid = ctk.CTkFrame(cfr_metrics_frame)\n        cfr_grid.pack(fill='x', padx=20, pady=(0, 20))\n        \n        # It√©rations/sec\n        iter_metric_frame = ctk.CTkFrame(cfr_grid)\n        iter_metric_frame.pack(side='left', fill='x', expand=True, padx=(0, 10))\n        ctk.CTkLabel(iter_metric_frame, text=\"It√©rations/sec\", font=ctk.CTkFont(weight=\"bold\")).pack(pady=5)\n        self.iterations_sec_label = ctk.CTkLabel(iter_metric_frame, text=\"0\", font=ctk.CTkFont(size=16, weight=\"bold\"))\n        self.iterations_sec_label.pack(pady=5)\n        \n        # Convergence\n        conv_metric_frame = ctk.CTkFrame(cfr_grid)\n        conv_metric_frame.pack(side='left', fill='x', expand=True, padx=5)\n        ctk.CTkLabel(conv_metric_frame, text=\"Convergence\", font=ctk.CTkFont(weight=\"bold\")).pack(pady=5)\n        self.convergence_label = ctk.CTkLabel(conv_metric_frame, text=\"0%\", font=ctk.CTkFont(size=16, weight=\"bold\"))\n        self.convergence_label.pack(pady=5)\n        \n        # Qualit√©\n        quality_metric_frame = ctk.CTkFrame(cfr_grid)\n        quality_metric_frame.pack(side='right', fill='x', expand=True, padx=(10, 0))\n        ctk.CTkLabel(quality_metric_frame, text=\"Qualit√©\", font=ctk.CTkFont(weight=\"bold\")).pack(pady=5)\n        self.quality_label = ctk.CTkLabel(quality_metric_frame, text=\"0%\", font=ctk.CTkFont(size=16, weight=\"bold\"))\n        self.quality_label.pack(pady=5)\n        \n        # === M√âTRIQUES OCR ===\n        ocr_metrics_frame = ctk.CTkFrame(perf_container)\n        ocr_metrics_frame.pack(fill='x')\n        \n        ctk.CTkLabel(ocr_metrics_frame, text=\"üëÅÔ∏è OCR Engine\", font=ctk.CTkFont(size=16, weight=\"bold\")).pack(pady=(15, 10))\n        \n        # M√©triques OCR\n        ocr_grid = ctk.CTkFrame(ocr_metrics_frame)\n        ocr_grid.pack(fill='x', padx=20, pady=(0, 20))\n        \n        # Capture/sec\n        capture_metric_frame = ctk.CTkFrame(ocr_grid)\n        capture_metric_frame.pack(side='left', fill='x', expand=True, padx=(0, 10))\n        ctk.CTkLabel(capture_metric_frame, text=\"Captures/sec\", font=ctk.CTkFont(weight=\"bold\")).pack(pady=5)\n        self.captures_sec_label = ctk.CTkLabel(capture_metric_frame, text=\"0\", font=ctk.CTkFont(size=16, weight=\"bold\"))\n        self.captures_sec_label.pack(pady=5)\n        \n        # Confiance\n        ocr_conf_metric_frame = ctk.CTkFrame(ocr_grid)\n        ocr_conf_metric_frame.pack(side='left', fill='x', expand=True, padx=5)\n        ctk.CTkLabel(ocr_conf_metric_frame, text=\"Confiance moy.\", font=ctk.CTkFont(weight=\"bold\")).pack(pady=5)\n        self.ocr_confidence_label = ctk.CTkLabel(ocr_conf_metric_frame, text=\"0%\", font=ctk.CTkFont(size=16, weight=\"bold\"))\n        self.ocr_confidence_label.pack(pady=5)\n        \n        # Temps traitement\n        ocr_time_metric_frame = ctk.CTkFrame(ocr_grid)\n        ocr_time_metric_frame.pack(side='right', fill='x', expand=True, padx=(10, 0))\n        ctk.CTkLabel(ocr_time_metric_frame, text=\"Temps moy.\", font=ctk.CTkFont(weight=\"bold\")).pack(pady=5)\n        self.ocr_time_label = ctk.CTkLabel(ocr_time_metric_frame, text=\"0ms\", font=ctk.CTkFont(size=16, weight=\"bold\"))\n        self.ocr_time_label.pack(pady=5)\n\n    def create_version_tab(self):\n        \"\"\"Cr√©ation de l'onglet Version et About\"\"\"\n        \n        # Container principal\n        version_container = ctk.CTkFrame(self.version_tab)\n        version_container.pack(fill='both', expand=True, padx=40, pady=40)\n        \n        # Logo/titre principal\n        ctk.CTkLabel(version_container, text=\"üéØ RTPA Studio\", \n                    font=ctk.CTkFont(size=32, weight=\"bold\")).pack(pady=(40, 10))\n        \n        ctk.CTkLabel(version_container, text=\"Real-Time Poker Assistant\", \n                    font=ctk.CTkFont(size=18), text_color=\"gray\").pack(pady=(0, 20))\n        \n        # Informations de version\n        version_info_frame = ctk.CTkFrame(version_container)\n        version_info_frame.pack(pady=(20, 30))\n        \n        ctk.CTkLabel(version_info_frame, text=\"Version 1.0.0\", \n                    font=ctk.CTkFont(size=16, weight=\"bold\")).pack(pady=15)\n        ctk.CTkLabel(version_info_frame, text=\"Build 1000 - Version stable\", \n                    font=ctk.CTkFont(size=12), text_color=\"gray\").pack(pady=(0, 15))\n        \n        # Fonctionnalit√©s\n        features_frame = ctk.CTkFrame(version_container)\n        features_frame.pack(fill='x', pady=(20, 30))\n        \n        ctk.CTkLabel(features_frame, text=\"‚ú® Fonctionnalit√©s\", \n                    font=ctk.CTkFont(size=14, weight=\"bold\")).pack(pady=(15, 10))\n        \n        features = [\n            \"üß† Intelligence Artificielle CFR/Nash\",\n            \"üëÅÔ∏è OCR automatique en temps r√©el\",\n            \"‚ö° Acc√©l√©ration GPU avec CUDA\",\n            \"üìä Analyse avanc√©e de performance\",\n            \"üéØ Recommandations strat√©giques\",\n            \"üìà Statistiques d√©taill√©es\"\n        ]\n        \n        for feature in features:\n            ctk.CTkLabel(features_frame, text=feature, font=ctk.CTkFont(size=11)).pack(anchor='w', padx=20, pady=2)\n        \n        # Bouton mise √† jour\n        self.check_update_btn = ctk.CTkButton(version_container, \n                                             text=\"üîÑ V√©rifier les mises √† jour\",\n                                             command=self.check_for_updates,\n                                             width=200)\n        self.check_update_btn.pack(pady=(30, 10))\n        \n        # Status de mise √† jour\n        self.update_status_label = ctk.CTkLabel(version_container, text=\"\", \n                                               font=ctk.CTkFont(size=12))\n        self.update_status_label.pack(pady=5)\n        \n        # Copyright\n        ctk.CTkLabel(version_container, text=\"¬© 2025 RTPA Studio - Tous droits r√©serv√©s\", \n                    font=ctk.CTkFont(size=10), text_color=\"gray\").pack(side='bottom', pady=(30, 20))\n    \n    def update_hero_info(self, pseudo, stack, position):\n        \"\"\"Met √† jour les informations du joueur principal\"\"\"\n        self.hero_name_label.config(text=pseudo)\n        self.hero_stack_label.config(text=stack)\n        self.hero_position_label.config(text=position)\n    \n    def update_players_from_ocr(self, players_data, hero_data=None):\n        \"\"\"Met √† jour les informations des joueurs depuis l'OCR\"\"\"\n        # Mettre √† jour nos infos si fournies\n        if hero_data:\n            self.update_hero_info(hero_data.get('name', 'MonPseudo'), \n                                self.format_amount(float(hero_data.get('stack', '0').replace('‚Ç¨', '').replace(',', '.'))), \n                                hero_data.get('position', 'Unknown'))\n        \n        # Compter uniquement les joueurs r√©ellement d√©tect√©s par OCR\n        real_active_count = 0\n        if players_data:\n            real_active_count = sum(1 for p in players_data if p.get('status') == 'actif')\n        if hero_data and hero_data.get('detected_by_ocr', False) and hero_data.get('status') == 'actif':\n            real_active_count += 1\n        \n        self.active_players_count.config(text=f\"{real_active_count}/9\")\n        \n        # Afficher les joueurs uniquement avec les vraies donn√©es OCR\n        # Ne pas cr√©er de donn√©es factices - attendre les vraies donn√©es OCR\n        real_players = []\n        \n        # Ajouter les joueurs d√©tect√©s par OCR (s'il y en a)\n        if players_data and len(players_data) > 0:\n            real_players.extend(players_data)\n        \n        # Ajouter le h√©ros seulement s'il y a des vraies donn√©es OCR\n        if hero_data and hero_data.get('detected_by_ocr', False):\n            hero_player = {\n                'name': hero_data.get('name'),\n                'stack': hero_data.get('stack_numeric'),\n                'position': hero_data.get('position_index'),\n                'position_name': hero_data.get('position'),\n                'status': hero_data.get('status'),\n                'vpip': hero_data.get('vpip'),\n                'pfr': hero_data.get('pfr'),\n                'is_button': hero_data.get('position_index') == 6,\n                'is_sb': hero_data.get('position_index') == 7,\n                'is_bb': hero_data.get('position_index') == 8,\n                'is_hero': True\n            }\n            real_players.append(hero_player)\n        \n        self.create_players_display(real_players)\n    \n    def create_players_display(self, players_data=None):\n        \"\"\"Affichage des 9 positions fixes d'une table 9-max\"\"\"\n        \n        # Effacer l'affichage existant\n        for widget in self.players_list_frame.winfo_children():\n            widget.destroy()\n        \n        # D√©finir les 9 positions fixes d'une table 9-max\n        positions = [\n            {'name': 'UTG', 'index': 0},\n            {'name': 'UTG+1', 'index': 1}, \n            {'name': 'MP1', 'index': 2},\n            {'name': 'MP2', 'index': 3},\n            {'name': 'MP3', 'index': 4},\n            {'name': 'CO', 'index': 5},\n            {'name': 'BTN', 'index': 6},\n            {'name': 'SB', 'index': 7},\n            {'name': 'BB', 'index': 8}\n        ]\n        \n        # Cr√©er un dictionnaire des joueurs par position\n        players_by_position = {}\n        if players_data:\n            for player in players_data:\n                pos_index = player.get('position', 0)\n                players_by_position[pos_index] = player\n        \n        # Afficher chaque position (si√®ge vide ou occup√©)\n        for pos in positions:\n            player_frame = ttk.Frame(self.players_list_frame)\n            player_frame.pack(fill='x', pady=1, padx=2)\n            \n            main_line = ttk.Frame(player_frame)\n            main_line.pack(fill='x')\n            \n            # Position avec couleur et ic√¥ne selon le type\n            pos_text = pos['name']\n            position_icon = \"\"\n            text_color = '#ffffff'  # Couleur par d√©faut (blanc)\n            \n            if pos['index'] == 6:  # BTN (Button)\n                position_icon = \" üü¢\"\n                text_color = '#FFD700'  # Or\n            elif pos['index'] == 7:  # SB (Small Blind) \n                position_icon = \" üü°\"\n                text_color = '#FF6B35'  # Orange-rouge\n            elif pos['index'] == 8:  # BB (Big Blind)\n                position_icon = \" üîµ\"\n                text_color = '#FF1744'  # Rouge\n            else:\n                text_color = '#87CEEB'  # Bleu clair pour les autres positions\n            \n            # Appliquer la couleur avec tkinter au lieu de ttk pour supporter les couleurs\n            pos_label = tk.Label(main_line, text=f\"{pos_text}{position_icon}\", \n                               font=('Arial', 8, 'bold'),\n                               fg=text_color,\n                               bg='#2b2b2b')\n            pos_label.pack(side='left')\n            \n            # V√©rifier si la position est occup√©e\n            player = players_by_position.get(pos['index'])\n            \n            if player:\n                # Position occup√©e - afficher uniquement les vraies infos OCR\n                status_color = '#28a745' if player.get('status') == 'actif' else '#6c757d'\n                status_icon = \"‚óè\" if player.get('status') == 'actif' else \"‚óã\"\n                \n                # Statut (seulement si d√©tect√© par OCR)\n                ttk.Label(main_line, text=status_icon, font=('Arial', 8), \n                         foreground=status_color).pack(side='left', padx=(2, 3))\n                \n                # Nom (seulement si d√©tect√© par OCR) - en bleu et gras si c'est le h√©ros\n                if player.get('name'):\n                    name = player.get('name')[:8]\n                    if len(player.get('name', '')) > 8:\n                        name += \".\"\n                        \n                    is_hero = player.get('is_hero', False)\n                    font_weight = 'bold' if is_hero else 'normal'\n                    name_color = '#007bff' if is_hero else status_color\n                    ttk.Label(main_line, text=name, font=('Arial', 8, font_weight), \n                             foreground=name_color).pack(side='left')\n                    \n                    # Stats (seulement si disponibles et r√©elles)\n                    vpip = player.get('vpip')\n                    pfr = player.get('pfr')\n                    if vpip is not None and pfr is not None:\n                        stats_text = f\"{vpip}/{pfr}\"\n                        ttk.Label(main_line, text=stats_text, font=('Arial', 7), \n                                 foreground='#6c757d').pack(side='left', padx=(5, 0))\n                    \n                    # Stack (seulement si d√©tect√© par OCR)\n                    stack_value = player.get('stack')\n                    if stack_value is not None and stack_value > 0:\n                        if isinstance(stack_value, (int, float)):\n                            if stack_value >= 1000:\n                                stack_text = f\"{stack_value/1000:.1f}k\"\n                            else:\n                                stack_text = f\"{stack_value:.0f}\"\n                        else:\n                            stack_text = str(stack_value)\n                        \n                        ttk.Label(main_line, text=stack_text, font=('Arial', 7), \n                                 foreground=status_color).pack(side='right', padx=(5, 0))\n            else:\n                # Position vide - afficher seulement \"Si√®ge vide\" (pas de donn√©es factices)\n                ttk.Label(main_line, text=\"Si√®ge vide\", font=('Arial', 8, 'italic'), \n                         foreground='#999999').pack(side='left', padx=(5, 0))\n    \n    def setup_styles(self):\n        \"\"\"Configuration des styles pour l'interface\"\"\"\n        style = ttk.Style()\n        \n        # Style pour les cadres de cartes\n        style.configure('Card.TFrame', relief='ridge', borderwidth=2, background='#f0f0f0')\n    \n    def format_amount(self, amount):\n        \"\"\"Formate un montant en euros avec 2 d√©cimales\"\"\"\n        try:\n            return f\"{float(amount):.2f}‚Ç¨\"\n        except (ValueError, TypeError):\n            return \"0.00‚Ç¨\"\n    \n    # M√©thodes pour les menus (√† impl√©menter selon besoins)\n    def setup_menu_bar(self):\n        \"\"\"Configuration de la barre de menu\"\"\"\n        pass  # Impl√©mentation future si n√©cessaire\n    \n    def on_closing(self):\n        \"\"\"Gestion propre de la fermeture\"\"\"\n        self.running = False\n        if self.update_thread and self.update_thread.is_alive():\n            self.update_thread.join(timeout=1)\n        self.root.destroy()\n    \n    def run(self):\n        \"\"\"Lance l'interface graphique\"\"\"\n        self.running = True\n        self.start_gui_update_thread()\n        self.root.mainloop()\n    \n    def start_gui_update_thread(self):\n        \"\"\"D√©marre le thread de mise √† jour de l'interface\"\"\"\n        if self.update_thread and self.update_thread.is_alive():\n            return\n        \n        self.running = True\n        self.update_thread = threading.Thread(target=self._update_loop, daemon=True)\n        self.update_thread.start()\n    \n    def _update_loop(self):\n        \"\"\"Boucle de mise √† jour de l'interface avec stabilisation\"\"\"\n        last_data = None\n        update_pending = False\n        \n        while self.running:\n            try:\n                if self.app_manager and not update_pending:\n                    # R√©cup√©rer les donn√©es du gestionnaire (si la m√©thode existe)\n                    if hasattr(self.app_manager, 'get_display_data'):\n                        data = self.app_manager.get_display_data()\n                    else:\n                        # Donn√©es vides quand aucune partie n'est d√©tect√©e\n                        data = {\n                            'hero_cards': [],\n                            'board_cards': [],\n                            'pot': '0.00‚Ç¨',\n                            'stack': '0.00‚Ç¨',\n                            'action': '',\n                            'bet_size': '',\n                            'win_probability': '',\n                            'risk_level': '',\n                            'confidence': '',\n                            'reasoning': 'En attente d\\'analyse...',\n                            'players_info': []  # Aucun joueur affich√© quand pas de partie active\n                        }\n                    \n                    # Ne mettre √† jour que si les donn√©es ont chang√©\n                    if data != last_data:\n                        update_pending = True\n                        last_data = data.copy() if isinstance(data, dict) else data\n                        \n                        # Mettre √† jour dans le thread principal avec callback de fin\n                        def update_complete():\n                            nonlocal update_pending\n                            update_pending = False\n                        \n                        self.root.after(0, lambda: self._perform_stable_update(data, update_complete))\n                \n                time.sleep(1.5)  # Mise √† jour moins fr√©quente pour stabilit√©\n                \n            except Exception as e:\n                print(f\"Erreur dans la boucle de mise √† jour: {e}\")\n                update_pending = False\n                time.sleep(1)\n    \n    def _perform_stable_update(self, data, callback):\n        \"\"\"Effectue une mise √† jour stable et compl√®te des donn√©es\"\"\"\n        try:\n            # Mise √† jour compl√®te en une seule fois\n            self.update_display(data)\n            \n            # Mettre √† jour les joueurs si disponibles\n            if data.get('players_info'):\n                self.update_players_from_ocr(data['players_info'])\n            \n            # Forcer la mise √† jour graphique\n            self.root.update_idletasks()\n            \n        except Exception as e:\n            print(f\"Erreur mise √† jour stable: {e}\")\n        finally:\n            # Signaler que la mise √† jour est termin√©e\n            if callback:\n                callback()\n    \n    # ========================================\n    # FONCTIONS CALLBACK POUR LES PARAM√àTRES\n    # ========================================\n    \n    def update_cpu_value(self, value):\n        \"\"\"Met √† jour l'affichage de la valeur CPU et applique la limite\"\"\"\n        try:\n            cpu_value = int(float(value))\n            self.cpu_value_label.configure(text=f\"{cpu_value}%\")\n            \n            # Sauvegarder le param√®tre de mani√®re persistante\n            if hasattr(self, 'app_manager') and self.app_manager:\n                # Sauvegarder dans settings.yaml\n                self.app_manager.update_settings({'cpu_usage_limit': float(cpu_value)})\n                \n                if hasattr(self.app_manager, 'cfr_trainer') and self.app_manager.cfr_trainer:\n                    # Appliquer la limite CPU r√©elle (convertir pourcentage en d√©cimal)\n                    self.app_manager.cfr_trainer.configure_generation_resources(\n                        cpu_percent=cpu_value\n                    )\n                    print(f\"‚úÖ Limite CPU CFR appliqu√©e et sauvegard√©e: {cpu_value}%\")\n                    \n                    # V√©rifier que la limite est bien appliqu√©e\n                    if hasattr(self.app_manager.cfr_trainer, 'continuous_generator') and self.app_manager.cfr_trainer.continuous_generator:\n                        actual_limit = self.app_manager.cfr_trainer.continuous_generator.settings.cpu_usage_limit\n                        print(f\"üîç V√©rification: limite CPU active = {actual_limit*100:.1f}%\")\n        except Exception as e:\n            print(f\"Erreur mise √† jour CPU: {e}\")\n    \n    def update_ram_value(self, value):\n        \"\"\"Met √† jour l'affichage de la valeur RAM et applique la limite\"\"\"\n        try:\n            ram_value = float(value)\n            self.ram_value_label.configure(text=f\"{ram_value:.1f} GB\")\n            \n            # Sauvegarder le param√®tre de mani√®re persistante\n            if hasattr(self, 'app_manager') and self.app_manager:\n                # Convertir GB en pourcentage approximatif (pour 16GB total)\n                ram_percentage = (ram_value / 16.0) * 100\n                # Sauvegarder dans settings.yaml\n                self.app_manager.update_settings({'ram_usage_limit': ram_percentage})\n                \n                if hasattr(self.app_manager, 'cfr_trainer') and self.app_manager.cfr_trainer:\n                    # Appliquer la limite RAM r√©elle (convertir GB en MB)\n                    ram_mb = ram_value * 1024\n                    self.app_manager.cfr_trainer.configure_generation_resources(\n                        memory_mb=ram_mb\n                    )\n                    print(f\"‚úÖ Limite RAM CFR appliqu√©e et sauvegard√©e: {ram_value:.1f} GB\")\n                    \n                    # V√©rifier que la limite est bien appliqu√©e\n                    if hasattr(self.app_manager.cfr_trainer, 'continuous_generator') and self.app_manager.cfr_trainer.continuous_generator:\n                        actual_queue = self.app_manager.cfr_trainer.continuous_generator.settings.max_queue_size\n                        print(f\"üîç V√©rification: queue m√©moire active = {actual_queue} mains\")\n        except Exception as e:\n            print(f\"Erreur mise √† jour RAM: {e}\")\n    \n    def update_generation_rate(self, value):\n        \"\"\"Met √† jour l'affichage de la vitesse de g√©n√©ration et applique le changement\"\"\"\n        try:\n            rate_value = int(float(value))\n            rate_labels = {\n                1: \"1 (Tr√®s lent)\", 2: \"2 (Lent)\", 3: \"3 (Lent)\", \n                4: \"4 (Mod√©r√©)\", 5: \"5 (Moyen)\", 6: \"6 (Moyen)\",\n                7: \"7 (Rapide)\", 8: \"8 (Rapide)\", 9: \"9 (Tr√®s rapide)\", 10: \"10 (Maximum)\"\n            }\n            display_text = rate_labels.get(rate_value, f\"{rate_value}\")\n            self.gen_rate_label.configure(text=display_text)\n            \n            # Appliquer la vitesse de g√©n√©ration r√©elle\n            if hasattr(self, 'app_manager') and self.app_manager:\n                if hasattr(self.app_manager, 'cfr_trainer') and self.app_manager.cfr_trainer:\n                    # Convertir la valeur 1-10 en mains par seconde (1=1 main/s, 10=10 mains/s)\n                    hands_per_sec = rate_value\n                    self.app_manager.cfr_trainer.configure_generation_resources(\n                        generation_rate=hands_per_sec\n                    )\n                    print(f\"‚úÖ Vitesse g√©n√©ration appliqu√©e: {rate_value} ({display_text})\")\n        except Exception as e:\n            print(f\"Erreur mise √† jour vitesse: {e}\")\n    \n    def load_saved_settings(self):\n        \"\"\"Charge les param√®tres sauvegard√©s et met √† jour l'interface\"\"\"\n        try:\n            if hasattr(self, 'app_manager') and self.app_manager and hasattr(self.app_manager, 'settings'):\n                settings = self.app_manager.settings\n                \n                # Charger CPU (pourcentage direct)\n                if hasattr(self, 'cpu_limit') and self.cpu_limit:\n                    cpu_value = getattr(settings, 'cpu_usage_limit', 80.0)\n                    self.cpu_limit.set(cpu_value)\n                    if hasattr(self, 'cpu_value_label'):\n                        self.cpu_value_label.configure(text=f\"{int(cpu_value)}%\")\n                \n                # Charger RAM (convertir pourcentage en GB approximatif)\n                if hasattr(self, 'ram_limit') and self.ram_limit:\n                    ram_percentage = getattr(settings, 'ram_usage_limit', 70.0)\n                    # Convertir pourcentage en GB (assumant 16GB total)\n                    ram_gb = (ram_percentage / 100.0) * 16.0\n                    self.ram_limit.set(ram_gb)\n                    if hasattr(self, 'ram_value_label'):\n                        self.ram_value_label.configure(text=f\"{ram_gb:.1f} GB\")\n                \n                # Charger GPU\n                if hasattr(self, 'gpu_enabled') and self.gpu_enabled:\n                    gpu_enabled = getattr(settings, 'gpu_enabled', True)\n                    if gpu_enabled:\n                        self.gpu_enabled.select()\n                    else:\n                        self.gpu_enabled.deselect()\n                \n                # Charger m√©moire GPU\n                if hasattr(self, 'gpu_memory') and self.gpu_memory:\n                    gpu_memory = getattr(settings, 'gpu_memory_limit', 80.0)\n                    self.gpu_memory.set(gpu_memory)\n                    if hasattr(self, 'gpu_mem_label'):\n                        self.gpu_mem_label.configure(text=f\"{int(gpu_memory)}%\")\n                \n                print(\"‚úÖ Param√®tres charg√©s depuis settings.yaml\")\n                \n        except Exception as e:\n            print(f\"Erreur chargement param√®tres: {e}\")\n    \n    # Autres m√©thodes callback (√† impl√©menter selon besoins)\n    def update_cfr_iterations(self, value):\n        \"\"\"Met √† jour le nombre d'it√©rations CFR\"\"\"\n        iterations = int(float(value))\n        self.cfr_iter_label.configure(text=str(iterations))\n        if hasattr(self, 'app_manager') and self.app_manager:\n            self.app_manager.update_settings({'cfr_iterations': iterations})\n    \n    def toggle_cfr_sampling(self):\n        \"\"\"Active/d√©sactive le sampling CFR\"\"\"\n        sampling_enabled = self.cfr_sampling.get()\n        if hasattr(self, 'app_manager') and self.app_manager:\n            self.app_manager.update_settings({'cfr_sampling_enabled': sampling_enabled})\n    \n    def update_ocr_interval(self, value):\n        \"\"\"Met √† jour l'intervalle OCR\"\"\"\n        interval = int(float(value))\n        self.ocr_interval_label.configure(text=f\"{interval}ms\")\n        if hasattr(self, 'app_manager') and self.app_manager:\n            self.app_manager.update_settings({'ocr_interval_ms': interval})\n    \n    def update_ocr_confidence(self, value):\n        \"\"\"Met √† jour la confiance OCR\"\"\"\n        confidence = float(value)\n        self.ocr_confidence_label.configure(text=f\"{int(confidence*100)}%\")\n        if hasattr(self, 'app_manager') and self.app_manager:\n            self.app_manager.update_settings({'ocr_confidence_threshold': confidence})\n    \n    def change_language(self, selection):\n        \"\"\"Change la langue\"\"\"\n        lang = \"fr\" if selection == \"Fran√ßais\" else \"en\"\n        if hasattr(self, 'app_manager') and self.app_manager:\n            self.app_manager.update_settings({'language': lang})\n    \n    def change_table_type(self, selection):\n        \"\"\"Change le type de table\"\"\"\n        table_type = \"cashgame\" if selection == \"Cash Game\" else \"tournament\"\n        if hasattr(self, 'app_manager') and self.app_manager:\n            self.app_manager.update_settings({'default_table_type': table_type})\n    \n    def update_target_hands(self, value):\n        \"\"\"Met √† jour l'objectif de mains\"\"\"\n        target = int(float(value))\n        self.target_hands_label.configure(text=str(target))\n        if hasattr(self, 'app_manager') and self.app_manager:\n            self.app_manager.update_settings({'target_hands_per_100': target})\n    \n    def toggle_gpu(self):\n        \"\"\"Active/d√©sactive le GPU\"\"\"\n        gpu_enabled = self.gpu_enabled.get()\n        if hasattr(self, 'app_manager') and self.app_manager:\n            self.app_manager.update_settings({'gpu_enabled': gpu_enabled})\n    \n    def update_gpu_memory(self, value):\n        \"\"\"Met √† jour la limite m√©moire GPU\"\"\"\n        gpu_mem = int(float(value))\n        self.gpu_mem_label.configure(text=f\"{gpu_mem}%\")\n        if hasattr(self, 'app_manager') and self.app_manager:\n            self.app_manager.update_settings({'gpu_memory_limit': float(gpu_mem)})\n    \n    def toggle_auto_resource_mgmt(self):\n        \"\"\"Active/d√©sactive la gestion automatique des ressources\"\"\"\n        auto_mgmt = self.auto_resource_mgmt.get()\n        if hasattr(self, 'app_manager') and self.app_manager:\n            self.app_manager.update_settings({'auto_resource_management': auto_mgmt})\n    \n    def check_for_updates(self):\n        \"\"\"V√©rifie les mises √† jour\"\"\"\n        self.update_status_label.configure(text=\"V√©rification en cours...\", text_color=\"orange\")\n        self.check_update_btn.configure(state=\"disabled\")\n        \n        # Thread de v√©rification\n        import threading\n        thread = threading.Thread(target=self._check_github_updates, daemon=True)\n        thread.start()\n    \n    def _check_github_updates(self):\n        \"\"\"Thread pour v√©rifier GitHub - temporairement d√©sactiv√©\"\"\"\n        try:\n            # Fonctionnalit√© de mise √† jour d√©sactiv√©e temporairement\n            # Le d√©p√¥t GitHub n'est pas encore configur√© pour ce projet\n            self.root.after(0, lambda: self.update_status_label.configure(\n                text=\"V√©rification des mises √† jour non disponible\", text_color=\"orange\"\n            ))\n            self.root.after(0, lambda: self.check_update_btn.configure(state=\"normal\"))\n            \n        except Exception as e:\n            print(f\"Erreur syst√®me: {e}\")\n            self.root.after(0, lambda: self.update_status_label.configure(\n                text=\"Erreur syst√®me\", text_color=\"red\"\n            ))\n            self.root.after(0, lambda: self.check_update_btn.configure(state=\"normal\"))\n\n    def _get_current_version(self):\n        \"\"\"R√©cup√®re la version actuelle depuis version.json\"\"\"\n        try:\n            import os\n            import json\n            version_file = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'version.json')\n            if os.path.exists(version_file):\n                with open(version_file, 'r') as f:\n                    version_info = json.load(f)\n                    return version_info.get('version', '1.0.0')\n        except:\n            pass\n        return \"1.0.0\"\n    \n    def update_display(self, data):\n        \"\"\"Met √† jour l'affichage avec les donn√©es re√ßues\"\"\"\n        try:\n            # Mise √† jour des cartes h√©ros\n            if data.get('hero_cards') and len(data['hero_cards']) >= 2:\n                self.hero_card1.configure(text=self.card_to_symbol(data['hero_cards'][0]))\n                self.hero_card2.configure(text=self.card_to_symbol(data['hero_cards'][1]))\n            else:\n                self.hero_card1.configure(text=\"üÇ†\")\n                self.hero_card2.configure(text=\"üÇ†\")\n            \n            # Mise √† jour du board\n            if data.get('board_cards'):\n                for i, card in enumerate(data['board_cards'][:5]):\n                    if i < len(self.board_cards):\n                        if card:\n                            self.board_cards[i].configure(text=self.card_to_symbol(card))\n                        else:\n                            self.board_cards[i].configure(text=\"üÇ†\")\n                            \n            # Mise √† jour des informations de jeu\n            if data.get('pot'):\n                self.pot_value.configure(text=str(data['pot']))\n                \n            if data.get('action'):\n                self.action_label.configure(text=str(data['action']))\n                \n            if data.get('win_probability'):\n                self.win_prob_label.configure(text=str(data['win_probability']))\n                \n            if data.get('risk_level'):\n                self.risk_label.configure(text=str(data['risk_level']))\n                \n            if data.get('confidence'):\n                self.confidence_label.configure(text=str(data['confidence']))\n                \n            if data.get('reasoning'):\n                self.reasoning_label.configure(text=str(data['reasoning']))\n                \n        except Exception as e:\n            print(f\"Erreur mise √† jour affichage: {e}\")\n    \n    def card_to_symbol(self, card_str):\n        \"\"\"Convertit une carte string (ex: 'As', 'Kh') en symbole Unicode\"\"\"\n        if not card_str or len(card_str) != 2:\n            return \"üÇ†\"\n        \n        rank, suit = card_str[0], card_str[1]\n        \n        # Mapping des couleurs\n        suit_map = {\n            's': '‚ô†Ô∏è',  # Spades\n            'h': '‚ô•Ô∏è',  # Hearts  \n            'd': '‚ô¶Ô∏è',  # Diamonds\n            'c': '‚ô£Ô∏è'   # Clubs\n        }\n        \n        # Mapping des rangs\n        rank_map = {\n            'A': 'A', 'K': 'K', 'Q': 'Q', 'J': 'J',\n            'T': '10', '9': '9', '8': '8', '7': '7',\n            '6': '6', '5': '5', '4': '4', '3': '3', '2': '2'\n        }\n        \n        suit_symbol = suit_map.get(suit.lower(), '?')\n        rank_symbol = rank_map.get(rank.upper(), '?')\n        \n        return f\"{rank_symbol}{suit_symbol}\"","size_bytes":66527},"src/ocr/__init__.py":{"content":"# OCR module","size_bytes":12},"src/ocr/screen_capture.py":{"content":"\"\"\"\nSyst√®me de capture d'√©cran et OCR non-intrusif pour RTPA Studio\n\"\"\"\n\nimport cv2\nimport numpy as np\nimport pytesseract\nimport time\nfrom typing import Dict, Any, Optional, Tuple, List\nimport threading\nimport psutil\nimport mss\nimport re\nfrom PIL import Image\n\nfrom ..utils.logger import get_logger\n\nclass ScreenCapture:\n    \"\"\"Gestionnaire de capture d'√©cran et OCR optimis√©\"\"\"\n    \n    def __init__(self):\n        self.logger = get_logger(__name__)\n        self.sct = mss.mss()\n        \n        # Configuration OCR avanc√©e\n        self.tesseract_configs = {\n            'cards': r'--oem 3 --psm 8 -c tessedit_char_whitelist=AKQJT98765432shdc',\n            'numbers': r'--oem 3 --psm 8 -c tessedit_char_whitelist=0123456789$.,k',\n            'pot': r'--oem 3 --psm 7 -c tessedit_char_whitelist=0123456789$.,k ',\n            'default': r'--oem 3 --psm 6 -c tessedit_char_whitelist=0123456789AKQJ$.,/'\n        }\n        self.tesseract_config = self.tesseract_configs['default']\n        \n        # Zones d'int√©r√™t adaptatives pour diff√©rents clients poker\n        self.roi_presets = {\n            'pokerstars': {\n                'hero_cards': {'top': 580, 'left': 440, 'width': 140, 'height': 50},\n                'board_cards': {'top': 280, 'left': 350, 'width': 320, 'height': 60},\n                'pot_size': {'top': 220, 'left': 450, 'width': 120, 'height': 30},\n                'hero_stack': {'top': 650, 'left': 420, 'width': 100, 'height': 25},\n                'blinds': {'top': 180, 'left': 400, 'width': 150, 'height': 30},\n                'action_buttons': {'top': 600, 'left': 600, 'width': 300, 'height': 80}\n            },\n            'winamax': {\n                'hero_cards': {'top': 590, 'left': 460, 'width': 130, 'height': 45},\n                'board_cards': {'top': 290, 'left': 370, 'width': 300, 'height': 55},\n                'pot_size': {'top': 230, 'left': 470, 'width': 110, 'height': 28},\n                'hero_stack': {'top': 660, 'left': 440, 'width': 90, 'height': 23},\n                'blinds': {'top': 190, 'left': 420, 'width': 140, 'height': 28},\n                'action_buttons': {'top': 610, 'left': 620, 'width': 280, 'height': 75}\n            },\n            'pmu': {\n                'hero_cards': {'top': 575, 'left': 450, 'width': 135, 'height': 48},\n                'board_cards': {'top': 275, 'left': 360, 'width': 310, 'height': 58},\n                'pot_size': {'top': 215, 'left': 460, 'width': 115, 'height': 32},\n                'hero_stack': {'top': 645, 'left': 430, 'width': 95, 'height': 26},\n                'blinds': {'top': 175, 'left': 410, 'width': 145, 'height': 32},\n                'action_buttons': {'top': 595, 'left': 610, 'width': 290, 'height': 78}\n            }\n        }\n        self.current_client = 'pokerstars'  # Client par d√©faut\n        self.roi_zones = self.roi_presets[self.current_client]\n        \n        # Cache des derni√®res captures\n        self.last_capture = None\n        self.last_analysis = None\n        self.capture_lock = threading.Lock()\n        \n        self.logger.info(\"ScreenCapture initialis√©\")\n    \n    def capture_screen_region(self, region: Optional[Dict[str, int]] = None) -> Optional[np.ndarray]:\n        \"\"\"Capture une r√©gion sp√©cifique de l'√©cran\"\"\"\n        try:\n            if region is None:\n                # Capture √©cran complet\n                region = {'top': 0, 'left': 0, 'width': 1920, 'height': 1080}\n            \n            screenshot = self.sct.grab(region)\n            img = np.array(screenshot)\n            \n            # Conversion BGR (pour OpenCV)\n            img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)\n            \n            return img\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur capture √©cran: {e}\")\n            return None\n    \n    def auto_detect_poker_client(self, img: np.ndarray) -> str:\n        \"\"\"D√©tecte automatiquement le client poker utilis√©\"\"\"\n        try:\n            # Recherche de patterns sp√©cifiques aux clients\n            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n            \n            # PokerStars - recherche du logo ou pattern sp√©cifique\n            if self._detect_pattern(gray, \"PokerStars\") or self._detect_pattern(gray, \"Stars\"):\n                return 'pokerstars'\n            \n            # Winamax - recherche du logo ou couleurs sp√©cifiques\n            elif self._detect_pattern(gray, \"Winamax\") or self._detect_pattern(gray, \"Max\"):\n                return 'winamax'\n            \n            # PMU - recherche du logo\n            elif self._detect_pattern(gray, \"PMU\") or self._detect_pattern(gray, \"pmu\"):\n                return 'pmu'\n            \n            # Par d√©faut, utiliser PokerStars\n            return 'pokerstars'\n            \n        except Exception as e:\n            self.logger.warning(f\"Erreur d√©tection client: {e}\")\n            return 'pokerstars'\n    \n    def set_poker_client(self, client: str):\n        \"\"\"Configure les zones ROI pour un client poker sp√©cifique\"\"\"\n        if client in self.roi_presets:\n            self.current_client = client\n            self.roi_zones = self.roi_presets[client]\n            self.logger.info(f\"Client poker configur√©: {client}\")\n        else:\n            self.logger.warning(f\"Client poker non support√©: {client}\")\n    \n    def preprocess_image_advanced(self, img: np.ndarray, zone_type: str = 'default') -> np.ndarray:\n        \"\"\"Pr√©processing de l'image pour am√©liorer l'OCR\"\"\"\n        try:\n            # Conversion en niveaux de gris\n            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n            \n            # Am√©lioration du contraste\n            clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))\n            enhanced = clahe.apply(gray)\n            \n            # D√©bruitage\n            denoised = cv2.medianBlur(enhanced, 3)\n            \n            # Seuillage adaptatif selon le type de zone\n            if zone_type in ['cards', 'blinds']:\n                # Pour les cartes et blinds, seuillage plus agressif\n                thresh = cv2.threshold(denoised, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]\n            else:\n                # Seuillage adaptatif pour le reste\n                thresh = cv2.adaptiveThreshold(denoised, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, \n                                             cv2.THRESH_BINARY, 11, 2)\n            \n            # Redimensionnement pour am√©liorer l'OCR\n            scale_factor = 2\n            resized = cv2.resize(thresh, None, fx=scale_factor, fy=scale_factor, \n                               interpolation=cv2.INTER_CUBIC)\n            \n            return resized\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur pr√©processing: {e}\")\n            return img\n    \n    def extract_text_from_image(self, img: np.ndarray, zone_type: str = 'default') -> str:\n        \"\"\"Extraction de texte avec OCR optimis√©\"\"\"\n        try:\n            # Pr√©processing\n            processed_img = self.preprocess_image_advanced(img, zone_type)\n            \n            # Configuration OCR sp√©cialis√©e selon le type\n            config = self.tesseract_config  # Configuration par d√©faut\n            if zone_type == 'cards':\n                config = r'--oem 3 --psm 8 -c tessedit_char_whitelist=AKQJT98765432shdc'\n            elif zone_type == 'numbers':\n                config = r'--oem 3 --psm 8 -c tessedit_char_whitelist=0123456789$.,k'\n            \n            # OCR\n            text = pytesseract.image_to_string(processed_img, config=config)\n            return text.strip()\n            \n        except pytesseract.TesseractError as e:\n            self.logger.error(f\"Erreur Tesseract OCR: {e}\")\n            self.logger.debug(f\"Config OCR utilis√©e: {config if 'config' in locals() else 'non d√©finie'}\")\n            return \"\"\n        except cv2.error as e:\n            self.logger.error(f\"Erreur OpenCV: {e}\")\n            return \"\"\n        except Exception as e:\n            self.logger.error(f\"Erreur inattendue OCR: {e}\")\n            import traceback\n            self.logger.debug(f\"Traceback OCR: {traceback.format_exc()}\")\n            return \"\"\n    \n    def detect_poker_client(self, img: np.ndarray) -> str:\n        \"\"\"D√©tecte le client de poker utilis√©\"\"\"\n        try:\n            # Recherche de patterns sp√©cifiques aux clients\n            # PokerStars\n            if self._detect_pattern(img, \"PokerStars\"):\n                return \"pokerstars\"\n            \n            # Winamax\n            if self._detect_pattern(img, \"Winamax\"):\n                return \"winamax\"\n            \n            # Autres clients\n            return \"unknown\"\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur d√©tection client: {e}\")\n            return \"unknown\"\n    \n    def _detect_pattern(self, img: np.ndarray, pattern: str) -> bool:\n        \"\"\"D√©tecte un pattern sp√©cifique dans l'image\"\"\"\n        try:\n            text = pytesseract.image_to_string(img)\n            return pattern.lower() in text.lower()\n        except:\n            return False\n    \n    def parse_hero_cards(self, text: str) -> Tuple[str, str]:\n        \"\"\"Parse les cartes du h√©ros\"\"\"\n        try:\n            # Pattern pour cartes poker (ex: \"As Kh\", \"Td 9c\")\n            pattern = r'([AKQJT98765432])([shdc])\\s*([AKQJT98765432])([shdc])'\n            match = re.search(pattern, text.replace(' ', ''))\n            \n            if match:\n                card1 = f\"{match.group(1)}{match.group(2)}\"\n                card2 = f\"{match.group(3)}{match.group(4)}\"\n                return (card1, card2)\n            \n            return (\"\", \"\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur parse cartes h√©ros: {e}\")\n            return (\"\", \"\")\n    \n    def parse_board_cards(self, text: str) -> List[str]:\n        \"\"\"Parse les cartes du board\"\"\"\n        try:\n            cards = []\n            # Pattern pour cartes sur le board\n            pattern = r'([AKQJT98765432])([shdc])'\n            matches = re.findall(pattern, text.replace(' ', ''))\n            \n            for match in matches:\n                cards.append(f\"{match[0]}{match[1]}\")\n            \n            return cards[:5]  # Maximum 5 cartes\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur parse board: {e}\")\n            return []\n    \n    def parse_monetary_value(self, text: str) -> float:\n        \"\"\"Parse une valeur mon√©taire\"\"\"\n        try:\n            # Nettoyage du texte\n            cleaned = re.sub(r'[^\\d.,k]', '', text.lower())\n            \n            if 'k' in cleaned:\n                # Gestion des milliers (ex: \"1.5k\" = 1500)\n                number = float(cleaned.replace('k', '').replace(',', '.'))\n                return number * 1000\n            else:\n                # Valeur normale\n                return float(cleaned.replace(',', '.'))\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur parse valeur: {e}\")\n            return 0.0\n    \n    def analyze_game_state(self, img: np.ndarray) -> Dict[str, Any]:\n        \"\"\"Analyse compl√®te de l'√©tat du jeu\"\"\"\n        try:\n            game_data = {}\n            \n            # D√©tection du client poker\n            poker_client = self.detect_poker_client(img)\n            game_data['poker_client'] = poker_client\n            \n            # Analyse des diff√©rentes zones\n            for zone_name, zone_coords in self.roi_zones.items():\n                try:\n                    # Extraction de la zone\n                    zone_img = img[zone_coords['top']:zone_coords['top'] + zone_coords['height'],\n                                  zone_coords['left']:zone_coords['left'] + zone_coords['width']]\n                    \n                    if zone_img.size == 0:\n                        continue\n                    \n                            # OCR selon le type de zone\n                    if zone_name == 'hero_cards':\n                        text = self.extract_text_from_image(zone_img, 'cards')\n                        game_data['hero_cards'] = self.parse_hero_cards(text)\n                    \n                    elif zone_name == 'board_cards':\n                        text = self.extract_text_from_image(zone_img, 'cards')\n                        game_data['board_cards'] = self.parse_board_cards(text)\n                    \n                    elif zone_name in ['pot_size', 'hero_stack']:\n                        text = self.extract_text_from_image(zone_img, 'numbers')\n                        game_data[zone_name] = self.parse_monetary_value(text)\n                    \n                    elif zone_name == 'blinds':\n                        text = self.extract_text_from_image(zone_img, 'numbers')\n                        # Parse SB/BB\n                        blinds = self._parse_blinds(text)\n                        game_data.update(blinds)\n                    \n                    elif zone_name == 'action_buttons':\n                        text = self.extract_text_from_image(zone_img)\n                        game_data['action_to_hero'] = self._detect_action_buttons(text)\n                    \n                except Exception as e:\n                    self.logger.error(f\"Erreur analyse zone {zone_name}: {e}\")\n                    continue\n            \n            # Ajout de m√©tadonn√©es\n            game_data['timestamp'] = time.time()\n            game_data['confidence'] = self._calculate_confidence(game_data)\n            \n            return game_data\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur analyse √©tat jeu: {e}\")\n            return {}\n    \n    def _parse_blinds(self, text: str) -> Dict[str, float]:\n        \"\"\"Parse les blinds\"\"\"\n        try:\n            # Pattern pour blinds (ex: \"5/10\", \"0.5/1\")\n            pattern = r'(\\d+(?:\\.\\d+)?)[/\\s]+(\\d+(?:\\.\\d+)?)'\n            match = re.search(pattern, text)\n            \n            if match:\n                return {\n                    'small_blind': float(match.group(1)),\n                    'big_blind': float(match.group(2))\n                }\n            \n            return {'small_blind': 0.0, 'big_blind': 0.0}\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur parse blinds: {e}\")\n            return {'small_blind': 0.0, 'big_blind': 0.0}\n    \n    def _detect_action_buttons(self, text: str) -> bool:\n        \"\"\"D√©tecte si c'est au tour du h√©ros\"\"\"\n        action_keywords = ['fold', 'call', 'raise', 'bet', 'check', 'all-in']\n        text_lower = text.lower()\n        \n        return any(keyword in text_lower for keyword in action_keywords)\n    \n    def _calculate_confidence(self, game_data: Dict[str, Any]) -> float:\n        \"\"\"Calcule la confiance dans l'analyse\"\"\"\n        try:\n            confidence = 0.0\n            total_checks = 0\n            \n            # V√©rifications de coh√©rence\n            if game_data.get('hero_cards') and game_data['hero_cards'] != (\"\", \"\"):\n                confidence += 25\n            total_checks += 1\n            \n            if game_data.get('pot_size', 0) > 0:\n                confidence += 25\n            total_checks += 1\n            \n            if game_data.get('hero_stack', 0) > 0:\n                confidence += 25\n            total_checks += 1\n            \n            if game_data.get('small_blind', 0) > 0 and game_data.get('big_blind', 0) > 0:\n                confidence += 25\n            total_checks += 1\n            \n            return confidence / total_checks if total_checks > 0 else 0.0\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur calcul confiance: {e}\")\n            return 0.0\n    \n    def capture_and_analyze(self) -> Optional[Dict[str, Any]]:\n        \"\"\"Capture et analyse en une seule op√©ration\"\"\"\n        try:\n            with self.capture_lock:\n                # Capture de l'√©cran\n                img = self.capture_screen_region()\n                if img is None:\n                    return None\n                \n                # Analyse\n                game_data = self.analyze_game_state(img)\n                \n                # Cache du r√©sultat\n                self.last_capture = img\n                self.last_analysis = game_data\n                \n                return game_data\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur capture et analyse: {e}\")\n            return None\n    \n    def calibrate_zones(self, poker_client: str = \"auto\"):\n        \"\"\"Calibre les zones d'int√©r√™t selon le client\"\"\"\n        try:\n            if poker_client == \"pokerstars\":\n                self.roi_zones.update({\n                    'hero_cards': {'top': 580, 'left': 440, 'width': 140, 'height': 50},\n                    'board_cards': {'top': 280, 'left': 350, 'width': 320, 'height': 60}\n                })\n            elif poker_client == \"winamax\":\n                self.roi_zones.update({\n                    'hero_cards': {'top': 600, 'left': 460, 'width': 120, 'height': 45},\n                    'board_cards': {'top': 300, 'left': 370, 'width': 300, 'height': 55}\n                })\n            \n            self.logger.info(f\"Zones calibr√©es pour {poker_client}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur calibrage: {e}\")\n    \n    def get_performance_metrics(self) -> Dict[str, float]:\n        \"\"\"Retourne les m√©triques de performance OCR\"\"\"\n        try:\n            # Simulation de m√©triques (√† impl√©menter avec de vraies mesures)\n            return {\n                'avg_capture_time_ms': 15.0,\n                'avg_ocr_time_ms': 35.0,\n                'avg_confidence': 85.0,\n                'success_rate': 92.0\n            }\n        except Exception as e:\n            self.logger.error(f\"Erreur m√©triques: {e}\")\n            return {}","size_bytes":17824},"src/ocr/screen_capture_headless.py":{"content":"\"\"\"\nVersion headless du syst√®me de capture pour environnement sans X11\nSimule les donn√©es OCR pour d√©monstration\n\"\"\"\n\nimport time\nimport random\nfrom typing import Dict, Any, Optional\nfrom ..utils.logger import get_logger\n\nclass ScreenCaptureHeadless:\n    \"\"\"Version simulation du syst√®me de capture d'√©cran\"\"\"\n    \n    def __init__(self):\n        self.logger = get_logger(__name__)\n        \n        # Noms de joueurs r√©alistes pour simulation\n        self.player_names = [\n            \"PokerPro\", \"AliceBluff\", \"BobNuts\", \"CharlieTilt\", \"DianaAce\", \n            \"EdRaise\", \"FionaCall\", \"GaryFold\", \"HelenShark\", \"IvanFish\",\n            \"JackPot\", \"KarenNit\", \"LeoLAG\", \"MonaTag\", \"NickRock\"\n        ]\n        \n        # Position mapping 9-max\n        self.position_names = {\n            0: \"UTG\", 1: \"UTG+1\", 2: \"MP1\", 3: \"MP2\", 4: \"MP3\", \n            5: \"CO\", 6: \"BTN\", 7: \"SB\", 8: \"BB\"\n        }\n        \n        # Simulation de donn√©es de poker avec joueurs complets 9-max\n        self.simulation_hands = [\n            {\n                'hero_cards': ('As', 'Kh'),\n                'board_cards': ['Ah', 'Kd', '7c'],\n                'pot_size': 150.0,\n                'hero_stack': 2500.0,\n                'small_blind': 5.0,\n                'big_blind': 10.0,\n                'action_to_hero': True,\n                'players_at_table': self._generate_players_data(0)\n            },\n            {\n                'hero_cards': ('Qd', 'Qs'),\n                'board_cards': ['9h', '3c', '2s', 'Jd'],\n                'pot_size': 340.0,\n                'hero_stack': 1850.0,\n                'small_blind': 5.0,\n                'big_blind': 10.0,\n                'action_to_hero': True,\n                'players_at_table': self._generate_players_data(1)\n            },\n            {\n                'hero_cards': ('Ac', '7d'),\n                'board_cards': ['Ah', '7h', '2c', '9s', 'Kh'],\n                'pot_size': 890.0,\n                'hero_stack': 1200.0,\n                'small_blind': 5.0,\n                'big_blind': 10.0,\n                'action_to_hero': False,\n                'players_at_table': self._generate_players_data(2)\n            }\n        ]\n        \n        self.current_hand_index = 0\n        self.hand_progress = 0  # 0-100, progression dans la main\n        \n        self.logger.info(\"ScreenCaptureHeadless initialis√© (mode simulation)\")\n    \n    def capture_and_analyze(self) -> Optional[Dict[str, Any]]:\n        \"\"\"Simule une capture et analyse\"\"\"\n        try:\n            # Progression automatique des mains\n            self.hand_progress += 1\n            if self.hand_progress > 100:\n                self.hand_progress = 0\n                self.current_hand_index = (self.current_hand_index + 1) % len(self.simulation_hands)\n            \n            # R√©cup√©ration de la main actuelle\n            current_hand = self.simulation_hands[self.current_hand_index].copy()\n            \n            # Simulation de variations\n            current_hand['pot_size'] += random.uniform(-50, 50)\n            current_hand['hero_stack'] += random.uniform(-100, 100)\n            \n            # Ajout de m√©tadonn√©es\n            current_hand.update({\n                'timestamp': time.time(),\n                'confidence': random.uniform(85, 98),\n                'poker_client': 'simulation',\n                'current_bet': random.uniform(0, 50),\n                'players_count': 9,\n                'hero_position': random.randint(0, 8),\n                'ante': 0.0,\n                'tournament_level': 1,\n                'rebuys_available': 0,\n                'table_type': 'cashgame'\n            })\n            \n            return current_hand\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur simulation OCR: {e}\")\n            return None\n    \n    def get_performance_metrics(self) -> Dict[str, float]:\n        \"\"\"Retourne des m√©triques simul√©es\"\"\"\n        return {\n            'avg_capture_time_ms': 12.0,\n            'avg_ocr_time_ms': 28.0,\n            'avg_confidence': 92.5,\n            'success_rate': 96.8\n        }\n\n    def _generate_players_data(self, scenario: int) -> list:\n        \"\"\"G√©n√®re des donn√©es de joueurs r√©alistes pour une table 9-max\"\"\"\n        players = []\n        \n        # Nombre de joueurs actifs selon le sc√©nario (6-9 joueurs)\n        num_players = [8, 9, 7][scenario % 3]\n        \n        # Position hero al√©atoire\n        hero_position = random.randint(0, 8)\n        \n        # Positions occup√©es (excluant le h√©ros)\n        occupied_positions = []\n        available_positions = [i for i in range(9) if i != hero_position]\n        random.shuffle(available_positions)\n        occupied_positions = available_positions[:num_players-1]\n        \n        # Cr√©er les joueurs\n        for i, position in enumerate(occupied_positions):\n            player_name = random.choice(self.player_names)\n            \n            # Stack r√©aliste\n            stack = random.uniform(500, 5000)\n            \n            # Stats poker r√©alistes selon type de joueur\n            player_type = random.choice(['tight', 'loose', 'aggressive', 'passive'])\n            if player_type == 'tight':\n                vpip = random.randint(8, 18)\n                pfr = random.randint(6, 15)\n            elif player_type == 'loose':\n                vpip = random.randint(25, 45)\n                pfr = random.randint(8, 20)\n            elif player_type == 'aggressive':\n                vpip = random.randint(18, 35)\n                pfr = random.randint(15, 30)\n            else:  # passive\n                vpip = random.randint(20, 40)\n                pfr = random.randint(5, 12)\n            \n            # Status du joueur\n            status = random.choice(['actif', 'fold', 'sitting_out']) if random.random() < 0.85 else 'fold'\n            \n            # Positions sp√©ciales\n            is_button = position == 6\n            is_sb = position == 7  \n            is_bb = position == 8\n            \n            players.append({\n                'name': player_name,\n                'position': position,\n                'position_name': self.position_names[position],\n                'stack': stack,\n                'vpip': vpip,\n                'pfr': pfr,\n                'status': status,\n                'is_button': is_button,\n                'is_sb': is_sb,\n                'is_bb': is_bb,\n                'cards_visible': status == 'actif',\n                'action_pending': status == 'actif' and random.random() < 0.3\n            })\n        \n        return players","size_bytes":6537},"src/utils/__init__.py":{"content":"# Utils module","size_bytes":14},"src/utils/cpp_integration.py":{"content":"\"\"\"\nInt√©gration du module C++ pour optimisations\n\"\"\"\n\nimport logging\nfrom typing import List, Dict, Any, Optional\n\nlogger = logging.getLogger(__name__)\n\nclass CPPIntegration:\n    \"\"\"Wrapper pour le module C++ optimis√©\"\"\"\n    \n    def __init__(self):\n        self.cpp_module = None\n        self.cpp_available = False\n        self._initialize_cpp()\n    \n    def _initialize_cpp(self):\n        \"\"\"Initialise le module C++ si disponible\"\"\"\n        try:\n            import rtpa_core\n            self.cpp_module = rtpa_core\n            self.cpp_module.init_cfr_engine()\n            self.cpp_available = True\n            logger.info(\"Module C++ charg√© avec succ√®s\")\n        except ImportError:\n            logger.warning(\"Module C++ non disponible, utilisation des versions Python\")\n            self.cpp_available = False\n        except Exception as e:\n            logger.error(f\"Erreur chargement module C++: {e}\")\n            self.cpp_available = False\n    \n    def calculate_equity_optimized(self, hero_cards: List[int], board_cards: List[int], \n                                 num_opponents: int = 1, simulations: int = 10000) -> float:\n        \"\"\"Calcul d'√©quit√© optimis√© C++ ou fallback Python\"\"\"\n        if self.cpp_available and self.cpp_module:\n            try:\n                return self.cpp_module.calculate_equity_fast(\n                    hero_cards, board_cards, num_opponents, simulations\n                )\n            except Exception as e:\n                logger.error(f\"Erreur calcul C++: {e}\")\n        \n        # Fallback Python\n        return self._calculate_equity_python(hero_cards, board_cards, num_opponents, simulations)\n    \n    def get_recommendation_optimized(self, game_state: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        \"\"\"Recommandation optimis√©e C++ ou fallback Python\"\"\"\n        if self.cpp_available and self.cpp_module:\n            try:\n                # Conversion de l'√©tat de jeu\n                street = 0  # 0=preflop, 1=flop, 2=turn, 3=river\n                hero_card1 = self._card_to_int(game_state.get('hero_cards', ['', ''])[0])\n                hero_card2 = self._card_to_int(game_state.get('hero_cards', ['', ''])[1])\n                position = game_state.get('hero_position', 0)\n                num_players = game_state.get('players_count', 9)\n                pot_size = game_state.get('pot_size', 0.0)\n                hero_stack = game_state.get('hero_stack', 0.0)\n                current_bet = game_state.get('current_bet', 0.0)\n                \n                # Conversion des cartes board\n                board_cards = []\n                for card_str in game_state.get('board_cards', []):\n                    if card_str:\n                        board_cards.append(self._card_to_int(card_str))\n                \n                table_type = game_state.get('table_type', 'cashgame')\n                action_to_hero = 1 if game_state.get('action_to_hero', True) else 0\n                \n                return self.cpp_module.get_recommendation_fast(\n                    street, hero_card1, hero_card2, position, num_players,\n                    pot_size, hero_stack, current_bet, board_cards,\n                    table_type, action_to_hero\n                )\n            except Exception as e:\n                logger.error(f\"Erreur recommandation C++: {e}\")\n        \n        # Fallback Python\n        return self._get_recommendation_python(game_state)\n    \n    def _card_to_int(self, card_str: str) -> int:\n        \"\"\"Convertit une carte string en entier\"\"\"\n        if not card_str or len(card_str) != 2:\n            return -1\n        \n        rank_char = card_str[0].upper()\n        suit_char = card_str[1].lower()\n        \n        # Mapping des rangs\n        rank_map = {\n            '2': 0, '3': 1, '4': 2, '5': 3, '6': 4, '7': 5, '8': 6, '9': 7,\n            'T': 8, 'J': 9, 'Q': 10, 'K': 11, 'A': 12\n        }\n        \n        # Mapping des couleurs\n        suit_map = {'s': 0, 'h': 1, 'd': 2, 'c': 3}\n        \n        if rank_char in rank_map and suit_char in suit_map:\n            return rank_map[rank_char] + suit_map[suit_char] * 13\n        \n        return -1\n    \n    def _calculate_equity_python(self, hero_cards: List[int], board_cards: List[int], \n                               num_opponents: int, simulations: int) -> float:\n        \"\"\"Version Python du calcul d'√©quit√©\"\"\"\n        import random\n        \n        # Simulation simplifi√©e\n        wins = 0\n        deck = list(range(52))\n        \n        # Retire les cartes connues\n        used_cards = set(hero_cards + board_cards)\n        available_deck = [card for card in deck if card not in used_cards]\n        \n        for _ in range(min(simulations, 1000)):  # Limite pour performance\n            random.shuffle(available_deck)\n            \n            # Simule une main gagnante avec probabilit√© bas√©e sur les cartes\n            base_prob = 0.5\n            if len(hero_cards) == 2:\n                # Ajustement basique selon les cartes h√©ros\n                if hero_cards[0] % 13 == hero_cards[1] % 13:  # Paire\n                    base_prob = 0.7\n                elif abs(hero_cards[0] % 13 - hero_cards[1] % 13) <= 1:  # Connect√©es\n                    base_prob = 0.6\n            \n            if random.random() < base_prob:\n                wins += 1\n        \n        return wins / min(simulations, 1000)\n    \n    def _get_recommendation_python(self, game_state: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Version Python de la recommandation\"\"\"\n        # Logique simplifi√©e\n        pot_size = game_state.get('pot_size', 0.0)\n        hero_stack = game_state.get('hero_stack', 0.0)\n        current_bet = game_state.get('current_bet', 0.0)\n        hero_cards = game_state.get('hero_cards', ['', ''])\n        \n        # Analyse basique\n        win_prob = 50.0  # Valeur par d√©faut\n        \n        # Ajustements selon les cartes\n        if len(hero_cards) == 2 and hero_cards[0] and hero_cards[1]:\n            if hero_cards[0][0] == hero_cards[1][0]:  # Paire\n                win_prob = 70.0\n            elif hero_cards[0][0] in 'AKQJ' or hero_cards[1][0] in 'AKQJ':  # Cartes hautes\n                win_prob = 60.0\n        \n        # D√©cision d'action\n        if win_prob > 65:\n            action = \"bet_large\"\n            bet_size = pot_size * 0.75\n            risk_level = 40.0\n        elif win_prob > 50:\n            action = \"bet_medium\"\n            bet_size = pot_size * 0.5\n            risk_level = 50.0\n        elif current_bet == 0:\n            action = \"check\"\n            bet_size = 0.0\n            risk_level = 30.0\n        elif current_bet < pot_size * 0.3:\n            action = \"call\"\n            bet_size = current_bet\n            risk_level = 60.0\n        else:\n            action = \"fold\"\n            bet_size = 0.0\n            risk_level = 0.0\n        \n        return {\n            'action_type': action,\n            'bet_size': bet_size,\n            'win_probability': win_prob,\n            'expected_value': win_prob / 100.0 * pot_size - (1 - win_prob / 100.0) * bet_size,\n            'risk_level': risk_level,\n            'confidence': min(95.0, 50.0 + win_prob / 2),\n            'reasoning': f\"Analyse Python - Probabilit√© {win_prob:.1f}%\"\n        }\n    \n    def cleanup(self):\n        \"\"\"Nettoyage des ressources C++\"\"\"\n        if self.cpp_available and self.cpp_module:\n            try:\n                self.cpp_module.cleanup_cfr()\n            except Exception as e:\n                logger.error(f\"Erreur nettoyage C++: {e}\")\n\n# Instance globale\ncpp_integration = CPPIntegration()","size_bytes":7545},"src/utils/logger.py":{"content":"\"\"\"\nSyst√®me de logging pour RTPA Studio\n\"\"\"\n\nimport logging\nimport sys\nfrom pathlib import Path\nfrom logging.handlers import RotatingFileHandler\nfrom typing import Optional\n\n# Configuration globale des logs\nLOG_LEVEL = logging.INFO\nLOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\nLOG_DIR = Path('logs')\nLOG_DIR.mkdir(exist_ok=True)\n\ndef setup_logger(name: Optional[str] = None) -> logging.Logger:\n    \"\"\"Configure et retourne un logger\"\"\"\n    logger_name = name or 'RTPA_Studio'\n    logger = logging.getLogger(logger_name)\n    \n    if logger.handlers:\n        return logger\n    \n    logger.setLevel(LOG_LEVEL)\n    \n    # Formatter\n    formatter = logging.Formatter(LOG_FORMAT)\n    \n    # Handler console\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setLevel(LOG_LEVEL)\n    console_handler.setFormatter(formatter)\n    logger.addHandler(console_handler)\n    \n    # Handler fichier rotatif\n    file_handler = RotatingFileHandler(\n        LOG_DIR / 'rtpa_studio.log',\n        maxBytes=10*1024*1024,  # 10MB\n        backupCount=5\n    )\n    file_handler.setLevel(LOG_LEVEL)\n    file_handler.setFormatter(formatter)\n    logger.addHandler(file_handler)\n    \n    return logger\n\ndef get_logger(name: Optional[str] = None) -> logging.Logger:\n    \"\"\"Retourne un logger configur√©\"\"\"\n    return setup_logger(name)","size_bytes":1352},"rtpa_studio.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nüéØ RTPA Studio - Lanceur Principal\nLogiciel d'analyse poker temps r√©el √† des fins d'√©tude\n\"\"\"\n\nimport sys\nimport os\nimport subprocess\nfrom pathlib import Path\n\ndef print_banner():\n    \"\"\"Affiche la banni√®re de lancement\"\"\"\n    print(\"üéØ RTPA STUDIO - REAL-TIME POKER ANALYSIS\")\n    print(\"=\" * 60)\n    print(\"Logiciel d'analyse poker temps r√©el √† des fins d'√©tude\")\n    print(\"Usage exclusivement √©ducatif et non-commercial\")\n    print(\"=\" * 60)\n    print()\n\ndef check_requirements():\n    \"\"\"V√©rifie les pr√©requis d'installation\"\"\"\n    errors = []\n    \n    # V√©rification Python\n    if sys.version_info < (3, 8):\n        errors.append(f\"Python 3.8+ requis (version actuelle: {sys.version_info.major}.{sys.version_info.minor})\")\n    \n    # V√©rification Tesseract\n    try:\n        result = subprocess.run(['tesseract', '--version'], \n                              capture_output=True, text=True, timeout=5)\n        if result.returncode != 0:\n            errors.append(\"Tesseract OCR non fonctionnel\")\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        errors.append(\"Tesseract OCR non install√© ou non dans le PATH\")\n    \n    # V√©rification modules Python critiques\n    critical_modules = [\n        'numpy', 'cv2', 'pytesseract', 'PIL', 'customtkinter',\n        'mss', 'psutil', 'yaml'\n    ]\n    \n    missing_modules = []\n    for module in critical_modules:\n        try:\n            __import__(module)\n        except ImportError:\n            missing_modules.append(module)\n    \n    if missing_modules:\n        errors.append(f\"Modules Python manquants: {', '.join(missing_modules)}\")\n    \n    return errors\n\ndef show_launcher_menu():\n    \"\"\"Affiche le menu de lancement\"\"\"\n    print(\"üöÄ MODES DE LANCEMENT DISPONIBLES:\")\n    print()\n    print(\"1. üéÆ Interface Graphique Compl√®te\")\n    print(\"   ‚Üí Analyse temps r√©el avec GUI moderne\")\n    print(\"   ‚Üí Tous les onglets et fonctionnalit√©s\")\n    print()\n    print(\"2. üñ•Ô∏è  Mode Console/D√©mo\")\n    print(\"   ‚Üí D√©monstration en ligne de commande\")\n    print(\"   ‚Üí Affichage temps r√©el des calculs\")\n    print()\n    print(\"3. üß™ Tests et Validation\")\n    print(\"   ‚Üí Tests complets du syst√®me\")\n    print(\"   ‚Üí Validation algorithmes CFR/Nash\")\n    print()\n    print(\"4. ‚öôÔ∏è  Installation/Configuration\")\n    print(\"   ‚Üí R√©installer les d√©pendances\")\n    print(\"   ‚Üí Calibrage OCR client poker\")\n    print()\n    print(\"0. ‚ùå Quitter\")\n    print()\n\ndef launch_gui():\n    \"\"\"Lance l'interface graphique\"\"\"\n    print(\"üéÆ Lancement interface graphique...\")\n    print(\"‚è≥ Chargement des composants...\")\n    \n    try:\n        # Ajouter le r√©pertoire du projet au path\n        project_dir = Path(__file__).parent\n        sys.path.insert(0, str(project_dir))\n        \n        # Lancement de l'interface\n        from main_gui import main\n        main()\n        \n    except Exception as e:\n        print(f\"‚ùå Erreur lancement interface: {e}\")\n        print(\"\\nüîß Solutions possibles:\")\n        print(\"   1. V√©rifiez l'installation: python setup_installer.py\")\n        print(\"   2. Mode console: python main_headless.py\")\n        print(\"   3. Tests: python test_final.py\")\n        input(\"\\nAppuyez sur Entr√©e pour continuer...\")\n\ndef launch_console():\n    \"\"\"Lance le mode console\"\"\"\n    print(\"üñ•Ô∏è  Lancement mode console...\")\n    \n    try:\n        subprocess.run([sys.executable, \"main_headless.py\"], check=True)\n    except subprocess.CalledProcessError as e:\n        print(f\"‚ùå Erreur mode console: {e}\")\n    except FileNotFoundError:\n        print(\"‚ùå Fichier main_headless.py non trouv√©\")\n\ndef launch_tests():\n    \"\"\"Lance les tests\"\"\"\n    print(\"üß™ TESTS DISPONIBLES:\")\n    print(\"1. Tests complets (recommand√©)\")\n    print(\"2. Tests algorithmes CFR/Nash\")\n    print(\"3. Benchmarks performance\")\n    print(\"4. Retour menu principal\")\n    \n    choice = input(\"\\nChoisissez (1-4): \").strip()\n    \n    test_files = {\n        '1': 'test_final.py',\n        '2': 'test_algorithms_validation.py',\n        '3': 'test_performance_benchmarks.py'\n    }\n    \n    if choice in test_files:\n        test_file = test_files[choice]\n        print(f\"üîÑ Ex√©cution {test_file}...\")\n        \n        try:\n            subprocess.run([sys.executable, test_file], check=True)\n        except subprocess.CalledProcessError as e:\n            print(f\"‚ùå Erreur test: {e}\")\n        except FileNotFoundError:\n            print(f\"‚ùå Fichier {test_file} non trouv√©\")\n    elif choice == '4':\n        return\n    else:\n        print(\"‚ùå Choix invalide\")\n\ndef launch_setup():\n    \"\"\"Lance l'installation/configuration\"\"\"\n    print(\"‚öôÔ∏è  INSTALLATION ET CONFIGURATION:\")\n    print(\"1. R√©installer toutes les d√©pendances\")\n    print(\"2. Test installation actuelle\")\n    print(\"3. Configuration OCR clients poker\")\n    print(\"4. Retour menu principal\")\n    \n    choice = input(\"\\nChoisissez (1-4): \").strip()\n    \n    if choice == '1':\n        print(\"üîÑ Lancement installateur automatique...\")\n        try:\n            subprocess.run([sys.executable, \"setup_installer.py\"], check=True)\n        except FileNotFoundError:\n            print(\"‚ùå Fichier setup_installer.py non trouv√©\")\n            print(\"üí° T√©l√©chargez le package complet de RTPA Studio\")\n    \n    elif choice == '2':\n        print(\"üß™ Test installation...\")\n        errors = check_requirements()\n        if not errors:\n            print(\"‚úÖ Installation compl√®te et fonctionnelle!\")\n        else:\n            print(\"‚ùå Probl√®mes d√©tect√©s:\")\n            for error in errors:\n                print(f\"   ‚Ä¢ {error}\")\n    \n    elif choice == '3':\n        print(\"‚öôÔ∏è  Configuration OCR...\")\n        print(\"üí° Utilisez l'onglet 'Configuration' dans l'interface graphique\")\n        print(\"   pour calibrer les zones OCR selon votre client poker.\")\n        launch_gui()\n    \n    elif choice == '4':\n        return\n    else:\n        print(\"‚ùå Choix invalide\")\n\ndef main():\n    \"\"\"Fonction principale du lanceur\"\"\"\n    print_banner()\n    \n    # V√©rification des pr√©requis\n    print(\"üîç V√©rification de l'installation...\")\n    errors = check_requirements()\n    \n    if errors:\n        print(\"‚ö†Ô∏è  PROBL√àMES D√âTECT√âS:\")\n        for error in errors:\n            print(f\"   ‚Ä¢ {error}\")\n        print()\n        print(\"üîß Ex√©cutez l'installateur automatique:\")\n        print(\"   python setup_installer.py\")\n        print()\n        \n        choice = input(\"Continuer malgr√© les erreurs? (o/N): \").lower()\n        if choice not in ['o', 'oui', 'y', 'yes']:\n            print(\"Installation requise. Arr√™t du programme.\")\n            return\n    else:\n        print(\"‚úÖ Installation v√©rifi√©e et fonctionnelle!\")\n    \n    print()\n    \n    # Menu principal\n    while True:\n        show_launcher_menu()\n        \n        choice = input(\"Choisissez votre option (0-4): \").strip()\n        print()\n        \n        if choice == '1':\n            launch_gui()\n        elif choice == '2':\n            launch_console()\n        elif choice == '3':\n            launch_tests()\n        elif choice == '4':\n            launch_setup()\n        elif choice == '0':\n            print(\"üéì Merci d'avoir utilis√© RTPA Studio!\")\n            print(\"üìö N'oubliez pas: usage strictement √©ducatif!\")\n            break\n        else:\n            print(\"‚ùå Choix invalide. Utilisez 0-4.\")\n        \n        print(\"\\n\" + \"‚îÄ\" * 60 + \"\\n\")\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except KeyboardInterrupt:\n        print(\"\\n\\nüõë Arr√™t demand√© par l'utilisateur\")\n    except Exception as e:\n        print(f\"\\n‚ùå Erreur inattendue: {e}\")\n        print(\"üîß Essayez: python setup_installer.py\")\n    finally:\n        print(\"\\nüëã Au revoir!\")","size_bytes":7751},"setup_installer.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nInstallateur automatique pour RTPA Studio\nInstallation automatique de toutes les d√©pendances\n\"\"\"\n\nimport os\nimport sys\nimport subprocess\nimport platform\nimport urllib.request\nimport zipfile\nimport shutil\nfrom pathlib import Path\n\nclass RTAPInstaller:\n    \"\"\"Installateur automatique RTPA Studio\"\"\"\n    \n    def __init__(self):\n        self.system = platform.system().lower()\n        self.python_version = f\"{sys.version_info.major}.{sys.version_info.minor}\"\n        self.errors = []\n        \n    def print_header(self):\n        \"\"\"Affiche l'en-t√™te d'installation\"\"\"\n        print(\"üéØ RTPA STUDIO - INSTALLATEUR AUTOMATIQUE\")\n        print(\"=\" * 55)\n        print(f\"Syst√®me: {platform.system()} {platform.release()}\")\n        print(f\"Python: {sys.version}\")\n        print(f\"Architecture: {platform.machine()}\")\n        print()\n        print(\"‚ö†Ô∏è  AVERTISSEMENT IMPORTANT ‚ö†Ô∏è\")\n        print(\"Ce logiciel est con√ßu exclusivement √† des fins d'√©tude\")\n        print(\"et de recherche acad√©mique sur les algorithmes de poker.\")\n        print(\"Usage strictement √©ducatif et non-commercial.\")\n        print()\n        \n    def check_python_version(self):\n        \"\"\"V√©rifie la version Python\"\"\"\n        print(\"üêç V√©rification version Python...\")\n        \n        if sys.version_info < (3, 8):\n            print(\"‚ùå Python 3.8+ requis\")\n            print(f\"   Version actuelle: {self.python_version}\")\n            return False\n        \n        print(f\"‚úÖ Python {self.python_version} OK\")\n        return True\n    \n    def install_tesseract(self):\n        \"\"\"Installe Tesseract OCR selon le syst√®me\"\"\"\n        print(\"üëÅÔ∏è Installation Tesseract OCR...\")\n        \n        try:\n            # Test si Tesseract est d√©j√† install√©\n            subprocess.run(['tesseract', '--version'], \n                         capture_output=True, check=True)\n            print(\"‚úÖ Tesseract d√©j√† install√©\")\n            return True\n            \n        except (subprocess.CalledProcessError, FileNotFoundError):\n            print(\"‚è≥ Installation de Tesseract...\")\n            \n            if self.system == \"windows\":\n                return self._install_tesseract_windows()\n            elif self.system == \"darwin\":  # macOS\n                return self._install_tesseract_macos()\n            elif self.system == \"linux\":\n                return self._install_tesseract_linux()\n            else:\n                print(f\"‚ùå Syst√®me non support√©: {self.system}\")\n                return False\n    \n    def _install_tesseract_windows(self):\n        \"\"\"Installation Tesseract sur Windows\"\"\"\n        try:\n            print(\"üì• T√©l√©chargement Tesseract Windows...\")\n            \n            # URL de Tesseract pour Windows\n            url = \"https://github.com/UB-Mannheim/tesseract/releases/download/v5.3.3/tesseract-ocr-w64-setup-5.3.3.20231005.exe\"\n            installer_path = \"tesseract_installer.exe\"\n            \n            urllib.request.urlretrieve(url, installer_path)\n            \n            print(\"üîß Lancement installation Tesseract...\")\n            print(\"‚ö†Ô∏è  Suivez les instructions √† l'√©cran\")\n            print(\"‚ö†Ô∏è  Assurez-vous d'ajouter Tesseract au PATH\")\n            \n            subprocess.run([installer_path, '/S'], check=True)\n            os.remove(installer_path)\n            \n            # Ajouter au PATH si n√©cessaire\n            tesseract_path = r\"C:\\\\Program Files\\\\Tesseract-OCR\"\n            if tesseract_path not in os.environ.get('PATH', ''):\n                print(\"üìù Ajout de Tesseract au PATH...\")\n                current_path = os.environ.get('PATH', '')\n                os.environ['PATH'] = f\"{current_path};{tesseract_path}\"\n            \n            print(\"‚úÖ Tesseract install√© avec succ√®s\")\n            return True\n            \n        except Exception as e:\n            print(f\"‚ùå Erreur installation Tesseract: {e}\")\n            print(\"üîß Installation manuelle requise:\")\n            print(\"   1. T√©l√©chargez Tesseract: https://github.com/UB-Mannheim/tesseract/releases\")\n            print(\"   2. Installez en suivant les instructions\")\n            print(\"   3. Ajoutez Tesseract au PATH syst√®me\")\n            return False\n    \n    def _install_tesseract_macos(self):\n        \"\"\"Installation Tesseract sur macOS\"\"\"\n        try:\n            # Tenter avec Homebrew\n            print(\"üç∫ Installation via Homebrew...\")\n            subprocess.run(['brew', 'install', 'tesseract'], check=True)\n            print(\"‚úÖ Tesseract install√© via Homebrew\")\n            return True\n            \n        except (subprocess.CalledProcessError, FileNotFoundError):\n            print(\"‚ùå Homebrew non trouv√©\")\n            print(\"üîß Installation manuelle requise:\")\n            print(\"   1. Installez Homebrew: https://brew.sh\")\n            print(\"   2. Ex√©cutez: brew install tesseract\")\n            print(\"   Ou t√©l√©chargez depuis: https://github.com/tesseract-ocr/tesseract\")\n            return False\n    \n    def _install_tesseract_linux(self):\n        \"\"\"Installation Tesseract sur Linux\"\"\"\n        try:\n            # D√©tecter la distribution\n            if os.path.exists('/etc/debian_version'):\n                # Debian/Ubuntu\n                print(\"üêß Installation via apt...\")\n                subprocess.run(['sudo', 'apt', 'update'], check=True)\n                subprocess.run(['sudo', 'apt', 'install', '-y', 'tesseract-ocr'], check=True)\n                \n            elif os.path.exists('/etc/redhat-release'):\n                # RedHat/CentOS/Fedora\n                print(\"üé© Installation via yum/dnf...\")\n                try:\n                    subprocess.run(['sudo', 'dnf', 'install', '-y', 'tesseract'], check=True)\n                except:\n                    subprocess.run(['sudo', 'yum', 'install', '-y', 'tesseract'], check=True)\n                    \n            elif os.path.exists('/etc/arch-release'):\n                # Arch Linux\n                print(\"üèπ Installation via pacman...\")\n                subprocess.run(['sudo', 'pacman', '-S', '--noconfirm', 'tesseract'], check=True)\n                \n            else:\n                print(\"‚ùå Distribution Linux non reconnue\")\n                print(\"üîß Installez manuellement: sudo apt install tesseract-ocr\")\n                return False\n            \n            print(\"‚úÖ Tesseract install√© sur Linux\")\n            return True\n            \n        except subprocess.CalledProcessError as e:\n            print(f\"‚ùå Erreur installation Tesseract: {e}\")\n            print(\"üîß Essayez manuellement: sudo apt install tesseract-ocr\")\n            return False\n    \n    def install_python_dependencies(self):\n        \"\"\"Installe les d√©pendances Python\"\"\"\n        print(\"üì¶ Installation des d√©pendances Python...\")\n        \n        # Liste des packages requis\n        packages = [\n            \"numpy>=1.21.0\",\n            \"opencv-python>=4.5.0\",\n            \"pytesseract>=0.3.8\",\n            \"pillow>=8.0.0\",\n            \"customtkinter>=5.0.0\",\n            \"mss>=6.1.0\",\n            \"psutil>=5.8.0\",\n            \"pybind11>=2.12.0\",\n            \"pyyaml>=6.0\",\n            \"matplotlib>=3.5.0\",\n            \"seaborn>=0.11.0\",\n            \"scipy>=1.7.0\",\n            \"numba>=0.56.0\"\n        ]\n        \n        try:\n            # Mise √† jour pip\n            print(\"‚¨ÜÔ∏è Mise √† jour pip...\")\n            subprocess.run([sys.executable, '-m', 'pip', 'install', '--upgrade', 'pip'], \n                         check=True, capture_output=True)\n            \n            # Installation des packages\n            for package in packages:\n                print(f\"üì• Installation {package}...\")\n                subprocess.run([sys.executable, '-m', 'pip', 'install', package], \n                             check=True, capture_output=True)\n            \n            print(\"‚úÖ Toutes les d√©pendances Python install√©es\")\n            return True\n            \n        except subprocess.CalledProcessError as e:\n            print(f\"‚ùå Erreur installation d√©pendances: {e}\")\n            return False\n    \n    def setup_directories(self):\n        \"\"\"Cr√©e les r√©pertoires n√©cessaires\"\"\"\n        print(\"üìÅ Cr√©ation des r√©pertoires...\")\n        \n        directories = [\n            \"logs\",\n            \"config\",\n            \"attached_assets/generated_images\",\n            \"exports\"\n        ]\n        \n        for directory in directories:\n            Path(directory).mkdir(parents=True, exist_ok=True)\n            print(f\"‚úÖ {directory}/\")\n        \n        return True\n    \n    def configure_tesseract_path(self):\n        \"\"\"Configure le chemin Tesseract pour pytesseract\"\"\"\n        print(\"‚öôÔ∏è Configuration Tesseract...\")\n        \n        try:\n            import pytesseract\n            \n            # Tentative de d√©tection automatique\n            if self.system == \"windows\":\n                possible_paths = [\n                    r\"C:\\Program Files\\Tesseract-OCR\\tesseract.exe\",\n                    r\"C:\\Program Files (x86)\\Tesseract-OCR\\tesseract.exe\",\n                    r\"C:\\Users\\{}\\AppData\\Local\\Tesseract-OCR\\tesseract.exe\".format(os.getlogin())\n                ]\n                \n                for path in possible_paths:\n                    if os.path.exists(path):\n                        pytesseract.pytesseract.tesseract_cmd = path\n                        print(f\"‚úÖ Tesseract configur√©: {path}\")\n                        return True\n            \n            # Test avec le PATH par d√©faut\n            result = subprocess.run(['tesseract', '--version'], \n                                  capture_output=True, text=True)\n            if result.returncode == 0:\n                print(\"‚úÖ Tesseract accessible via PATH\")\n                return True\n            \n            print(\"‚ö†Ô∏è Tesseract peut n√©cessiter une configuration manuelle\")\n            return True\n            \n        except ImportError:\n            print(\"‚ö†Ô∏è pytesseract non encore install√©\")\n            return True\n        except Exception as e:\n            print(f\"‚ö†Ô∏è Configuration Tesseract: {e}\")\n            return True\n    \n    def test_installation(self):\n        \"\"\"Test l'installation compl√®te\"\"\"\n        print(\"üß™ Test de l'installation...\")\n        \n        try:\n            # Test imports Python\n            import numpy\n            import cv2\n            import pytesseract\n            from PIL import Image\n            import customtkinter\n            import mss\n            import psutil\n            import yaml\n            \n            print(\"‚úÖ Tous les modules Python import√©s\")\n            \n            # Test Tesseract\n            version = pytesseract.get_tesseract_version()\n            print(f\"‚úÖ Tesseract {version} fonctionnel\")\n            \n            # Test cr√©ation image simple\n            test_img = Image.new('RGB', (100, 50), 'white')\n            text = pytesseract.image_to_string(test_img)\n            print(\"‚úÖ OCR Tesseract op√©rationnel\")\n            \n            # Test capture √©cran\n            with mss.mss() as sct:\n                screenshot = sct.grab({\"top\": 0, \"left\": 0, \"width\": 100, \"height\": 100})\n                print(\"‚úÖ Capture d'√©cran fonctionnelle\")\n            \n            print(\"üéâ Installation valid√©e avec succ√®s!\")\n            return True\n            \n        except Exception as e:\n            print(f\"‚ùå Erreur test installation: {e}\")\n            return False\n    \n    def create_shortcuts(self):\n        \"\"\"Cr√©e les raccourcis de lancement\"\"\"\n        print(\"üîó Cr√©ation des raccourcis...\")\n        \n        # Script de lancement principal\n        launcher_content = f'''#!/usr/bin/env python3\n\"\"\"Lanceur RTPA Studio\"\"\"\nimport sys\nimport os\n\n# Ajouter le r√©pertoire du projet au path\nproject_dir = os.path.dirname(os.path.abspath(__file__))\nsys.path.insert(0, project_dir)\n\n# Lancement interface graphique\nif __name__ == \"__main__\":\n    try:\n        from main_gui import main\n        main()\n    except Exception as e:\n        print(f\"Erreur lancement RTPA Studio: {{e}}\")\n        input(\"Appuyez sur Entr√©e pour fermer...\")\n'''\n        \n        with open(\"rtpa_studio.py\", \"w\", encoding=\"utf-8\") as f:\n            f.write(launcher_content)\n        \n        # Rendre ex√©cutable sur Unix\n        if self.system in [\"linux\", \"darwin\"]:\n            os.chmod(\"rtpa_studio.py\", 0o755)\n        \n        print(\"‚úÖ Lanceur rtpa_studio.py cr√©√©\")\n        return True\n    \n    def show_final_instructions(self):\n        \"\"\"Affiche les instructions finales\"\"\"\n        print()\n        print(\"üéâ INSTALLATION TERMIN√âE AVEC SUCC√àS!\")\n        print(\"=\" * 45)\n        print()\n        print(\"üöÄ LANCEMENT DU LOGICIEL:\")\n        print(\"   python rtpa_studio.py          # Interface graphique compl√®te\")\n        print(\"   python main_gui.py             # Interface graphique\")\n        print(\"   python main_headless.py        # Mode d√©mo console\")\n        print(\"   python test_final.py           # Tests complets\")\n        print()\n        print(\"üìã CALIBRAGE INITIAL:\")\n        print(\"   1. Lancez votre client poker (PokerStars, Winamax, PMU)\")\n        print(\"   2. Ouvrez une table de poker\")\n        print(\"   3. Lancez RTPA Studio\")\n        print(\"   4. Utilisez l'outil de calibrage pour ajuster les zones OCR\")\n        print()\n        print(\"‚öôÔ∏è CONFIGURATION:\")\n        print(\"   ‚Ä¢ config/settings.yaml - Param√®tres g√©n√©raux\")\n        print(\"   ‚Ä¢ Onglet 'Configuration' - Zones OCR et clients poker\")\n        print(\"   ‚Ä¢ Onglet 'Performance' - Optimisations syst√®me\")\n        print()\n        print(\"‚ö†Ô∏è  IMPORTANT:\")\n        print(\"   ‚Ä¢ Usage strictement √©ducatif et de recherche\")\n        print(\"   ‚Ä¢ Respectez les conditions d'utilisation des plateformes\")\n        print(\"   ‚Ä¢ Aucune injection de code dans les clients poker\")\n        print(\"   ‚Ä¢ Lecture passive uniquement via OCR\")\n        print()\n        print(\"üìö DOCUMENTATION:\")\n        print(\"   ‚Ä¢ README.md - Guide complet d'utilisation\")\n        print(\"   ‚Ä¢ logs/ - Fichiers de logs pour debug\")\n        print(\"   ‚Ä¢ exports/ - Donn√©es export√©es\")\n        print()\n    \n    def run_installation(self):\n        \"\"\"Lance l'installation compl√®te\"\"\"\n        self.print_header()\n        \n        success = True\n        \n        # V√©rifications pr√©alables\n        if not self.check_python_version():\n            return False\n        \n        # Installation Tesseract\n        if not self.install_tesseract():\n            success = False\n            self.errors.append(\"Installation Tesseract √©chou√©e\")\n        \n        # Installation d√©pendances Python\n        if not self.install_python_dependencies():\n            success = False\n            self.errors.append(\"Installation d√©pendances Python √©chou√©e\")\n        \n        # Configuration\n        self.setup_directories()\n        self.configure_tesseract_path()\n        \n        # Test final\n        if success and not self.test_installation():\n            success = False\n            self.errors.append(\"Tests de validation √©chou√©s\")\n        \n        # Finalisation\n        if success:\n            self.create_shortcuts()\n            self.show_final_instructions()\n        else:\n            print(\"‚ùå INSTALLATION INCOMPL√àTE\")\n            print(\"Erreurs rencontr√©es:\")\n            for error in self.errors:\n                print(f\"   ‚Ä¢ {error}\")\n        \n        return success\n\nif __name__ == \"__main__\":\n    installer = RTAPInstaller()\n    installer.run_installation()","size_bytes":15488},"test_algorithms_validation.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTests de validation math√©matique pour les algorithmes CFR/Nash\nV√©rifie la correctness des formules et l'exactitude des calculs\n\"\"\"\n\nimport unittest\nimport time\nimport numpy as np\nfrom src.algorithms.cfr_engine import CFREngine, PokerState\nfrom src.core.app_manager import GameState\nfrom src.database.memory_db import MemoryDatabase\nimport logging\n\n# Configuration logging pour les tests\nlogging.basicConfig(level=logging.WARNING)\n\nclass TestCFRValidation(unittest.TestCase):\n    \"\"\"Tests de validation des algorithmes CFR\"\"\"\n    \n    def setUp(self):\n        \"\"\"Initialisation pour chaque test\"\"\"\n        self.cfr_engine = CFREngine()\n        self.tolerance = 1e-6  # Tol√©rance pour comparaisons num√©riques\n    \n    def test_regret_calculation_formula(self):\n        \"\"\"Test: Validation de la formule de calcul des regrets\"\"\"\n        # √âtat de test simple\n        game_state = GameState(\n            hero_cards=(\"As\", \"Kh\"),\n            board_cards=(\"Ah\", \"Kd\", \"7c\"),\n            pot_size=100.0,\n            hero_stack=500.0\n        )\n        \n        # Calcul de recommandation\n        recommendation = self.cfr_engine.get_recommendation(game_state)\n        \n        # V√©rifications de base\n        self.assertIsNotNone(recommendation)\n        self.assertIn('action_type', recommendation)\n        self.assertIn('win_probability', recommendation)\n        self.assertIn('expected_value', recommendation)\n        \n        # La probabilit√© de victoire doit √™tre entre 0 et 1\n        win_prob = recommendation['win_probability']\n        self.assertGreaterEqual(win_prob, 0.0)\n        self.assertLessEqual(win_prob, 1.0)\n    \n    def test_strategy_normalization(self):\n        \"\"\"Test: V√©rification que les strat√©gies sont normalis√©es\"\"\"\n        # Cr√©er un information set simple\n        info_set = \"test_info_set\"\n        actions = [\"fold\", \"call\", \"bet\"]\n        \n        # Ajouter des regrets fictifs\n        for action in actions:\n            self.cfr_engine.regret_sum[info_set][action] = np.random.random() * 10\n        \n        # Obtenir la strat√©gie\n        poker_state = PokerState(\n            street=1,\n            hero_cards=(\"As\", \"Kh\"),\n            board_cards=[\"Ah\", \"Kd\", \"7c\"],\n            pot_size=100.0,\n            hero_stack=500.0,\n            position=3,\n            num_players=6,\n            current_bet=20.0,\n            action_history=[],\n            table_type=\"cashgame\"\n        )\n        \n        strategy = self.cfr_engine._get_strategy(info_set, poker_state)\n        \n        # V√©rifier que les probabilit√©s somment √† 1\n        total_prob = sum(strategy.values())\n        self.assertAlmostEqual(total_prob, 1.0, delta=self.tolerance)\n        \n        # V√©rifier que toutes les probabilit√©s sont positives\n        for prob in strategy.values():\n            self.assertGreaterEqual(prob, 0.0)\n    \n    def test_nash_equilibrium_properties(self):\n        \"\"\"Test: Propri√©t√©s d'√©quilibre de Nash\"\"\"\n        # Simuler plusieurs it√©rations CFR\n        game_state = GameState(\n            hero_cards=(\"Qd\", \"Qs\"),\n            board_cards=(\"9h\", \"3c\", \"2s\"),\n            pot_size=200.0,\n            hero_stack=800.0\n        )\n        \n        # Faire plusieurs calculs pour stabiliser\n        recommendations = []\n        for _ in range(10):\n            rec = self.cfr_engine.get_recommendation(game_state)\n            recommendations.append(rec)\n            time.sleep(0.01)  # Petit d√©lai pour permettre les calculs\n        \n        # V√©rifier la coh√©rence des recommandations\n        action_types = [rec['action_type'] for rec in recommendations]\n        \n        # Au moins 70% des recommandations devraient √™tre coh√©rentes\n        most_common_action = max(set(action_types), key=action_types.count)\n        consistency = action_types.count(most_common_action) / len(action_types)\n        self.assertGreaterEqual(consistency, 0.7)\n    \n    def test_equity_calculation_bounds(self):\n        \"\"\"Test: V√©rification des bornes de calcul d'√©quit√©\"\"\"\n        # Main tr√®s forte (paire d'As sur board sec)\n        strong_hand = GameState(\n            hero_cards=(\"As\", \"Ad\"),\n            board_cards=(\"7c\", \"2h\", \"9s\"),\n            pot_size=150.0,\n            hero_stack=600.0\n        )\n        \n        rec_strong = self.cfr_engine.get_recommendation(strong_hand)\n        \n        # Main tr√®s faible (7-2 offsuit)\n        weak_hand = GameState(\n            hero_cards=(\"7c\", \"2h\"),\n            board_cards=(\"As\", \"Kd\", \"Qj\"),\n            pot_size=150.0,\n            hero_stack=600.0\n        )\n        \n        rec_weak = self.cfr_engine.get_recommendation(weak_hand)\n        \n        # La main forte devrait avoir une probabilit√© de victoire plus √©lev√©e\n        # Note: en simulation, les valeurs peuvent √™tre normalis√©es diff√©remment\n        # On v√©rifie juste que les calculs ne plantent pas et donnent des valeurs coh√©rentes\n        self.assertIsNotNone(rec_strong['win_probability'])\n        self.assertIsNotNone(rec_weak['win_probability'])\n\nclass TestPerformanceValidation(unittest.TestCase):\n    \"\"\"Tests de performance pour √©viter freezes et lags\"\"\"\n    \n    def setUp(self):\n        \"\"\"Initialisation pour les tests de performance\"\"\"\n        self.cfr_engine = CFREngine()\n        self.database = MemoryDatabase()\n        \n        # Seuils de performance acceptables\n        self.max_response_time = 0.5  # 500ms maximum\n        self.max_memory_growth = 100 * 1024 * 1024  # 100MB max\n    \n    def test_recommendation_speed(self):\n        \"\"\"Test: Temps de r√©ponse des recommandations\"\"\"\n        game_state = GameState(\n            hero_cards=(\"Kh\", \"Qd\"),\n            board_cards=(\"Ac\", \"8s\", \"3h\", \"9d\"),\n            pot_size=300.0,\n            hero_stack=750.0\n        )\n        \n        # Mesurer le temps de calcul\n        start_time = time.time()\n        recommendation = self.cfr_engine.get_recommendation(game_state)\n        end_time = time.time()\n        \n        response_time = end_time - start_time\n        \n        # V√©rifier que la r√©ponse est dans les temps\n        self.assertLess(response_time, self.max_response_time,\n                       f\"Temps de r√©ponse trop long: {response_time:.3f}s\")\n        self.assertIsNotNone(recommendation)\n    \n    def test_continuous_calculation_stability(self):\n        \"\"\"Test: Stabilit√© des calculs continus\"\"\"\n        game_states = [\n            GameState(hero_cards=(\"As\", \"Kh\"), board_cards=(\"Ah\", \"Kd\", \"7c\"), pot_size=100.0, hero_stack=500.0),\n            GameState(hero_cards=(\"Qd\", \"Qs\"), board_cards=(\"9h\", \"3c\", \"2s\"), pot_size=200.0, hero_stack=800.0),\n            GameState(hero_cards=(\"Ac\", \"7d\"), board_cards=(\"Ah\", \"7h\", \"2c\", \"9s\", \"Kh\"), pot_size=400.0, hero_stack=600.0)\n        ]\n        \n        start_time = time.time()\n        \n        # Simuler 100 calculs rapides\n        for i in range(100):\n            game_state = game_states[i % len(game_states)]\n            recommendation = self.cfr_engine.get_recommendation(game_state)\n            self.assertIsNotNone(recommendation)\n            \n            # V√©rifier qu'on ne d√©passe pas le temps total\n            if time.time() - start_time > 10.0:  # 10 secondes max\n                self.fail(\"Test de stabilit√© trop lent\")\n    \n    def test_memory_leak_prevention(self):\n        \"\"\"Test: Pr√©vention des fuites m√©moire\"\"\"\n        import psutil\n        import os\n        \n        process = psutil.Process(os.getpid())\n        initial_memory = process.memory_info().rss\n        \n        # Ex√©cuter de nombreuses op√©rations\n        for i in range(1000):\n            game_state = GameState(\n                hero_cards=(\"As\", \"Kh\"),\n                board_cards=(\"Ah\", \"Kd\", \"7c\"),\n                pot_size=float(100 + i),\n                hero_stack=float(500 + i)\n            )\n            \n            recommendation = self.cfr_engine.get_recommendation(game_state)\n            \n            # Stocker en base\n            self.database.store_recommendation(recommendation)\n            \n            # V√©rifier la m√©moire tous les 100 it√©rations\n            if i % 100 == 0:\n                current_memory = process.memory_info().rss\n                memory_growth = current_memory - initial_memory\n                \n                if memory_growth > self.max_memory_growth:\n                    self.fail(f\"Fuite m√©moire d√©tect√©e: {memory_growth / 1024 / 1024:.1f} MB\")\n\nclass TestIntegrationValidation(unittest.TestCase):\n    \"\"\"Tests d'int√©gration compl√®te OCR ‚Üí CFR ‚Üí Recommandations\"\"\"\n    \n    def setUp(self):\n        \"\"\"Initialisation pour tests d'int√©gration\"\"\"\n        from src.core.app_manager import RTAPStudioManager\n        self.app_manager = RTAPStudioManager()\n    \n    def test_full_pipeline_simulation(self):\n        \"\"\"Test: Pipeline complet en mode simulation\"\"\"\n        # Test avec des donn√©es simul√©es\n        simulated_ocr_data = {\n            'hero_cards': (\"As\", \"Kh\"),\n            'board_cards': [\"Ah\", \"Kd\", \"7c\"],\n            'pot_size': 150.0,\n            'hero_stack': 800.0,\n            'small_blind': 5.0,\n            'big_blind': 10.0,\n            'action_to_hero': True,\n            'timestamp': time.time()\n        }\n        \n        # Mettre √† jour l'√©tat de jeu\n        self.app_manager._update_game_state(simulated_ocr_data)\n        \n        # G√©n√©rer une recommandation\n        recommendation = self.app_manager.cfr_engine.get_recommendation(self.app_manager.game_state)\n        \n        # V√©rifications\n        self.assertIsNotNone(recommendation)\n        self.assertIn('action_type', recommendation)\n        self.assertIn('bet_size', recommendation)\n        self.assertIn('win_probability', recommendation)\n        \n        # Stocker en base\n        success = self.app_manager.database.store_recommendation(recommendation)\n        self.assertTrue(success)\n    \n    def test_error_handling_robustness(self):\n        \"\"\"Test: Robustesse de la gestion d'erreurs\"\"\"\n        # Test avec des donn√©es corrompues\n        corrupted_data = {\n            'hero_cards': None,  # Donn√©es corrompues\n            'board_cards': [\"InvalidCard\"],\n            'pot_size': -100.0,  # Valeur n√©gative\n            'hero_stack': float('inf'),  # Valeur infinie\n        }\n        \n        # Le syst√®me ne doit pas planter\n        try:\n            self.app_manager._update_game_state(corrupted_data)\n            recommendation = self.app_manager.cfr_engine.get_recommendation(self.app_manager.game_state)\n            # M√™me avec des donn√©es corrompues, on doit avoir une recommandation par d√©faut\n            self.assertIsNotNone(recommendation)\n        except Exception as e:\n            self.fail(f\"Le syst√®me a plant√© avec des donn√©es corrompues: {e}\")\n\nif __name__ == '__main__':\n    print(\"üß™ Lancement des tests de validation RTPA Studio...\")\n    print(\"=\" * 60)\n    \n    # Ex√©cuter tous les tests\n    unittest.main(verbosity=2)","size_bytes":10906},"test_performance_benchmarks.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTests de performance et benchmarks pour RTPA Studio\nMesure les temps de r√©ponse et l'utilisation des ressources\n\"\"\"\n\nimport time\nimport psutil\nimport threading\nfrom src.core.app_manager import RTAPStudioManager\nfrom src.algorithms.cfr_engine import CFREngine\nfrom src.database.memory_db import MemoryDatabase\nfrom src.core.app_manager import GameState\n\nclass PerformanceBenchmark:\n    \"\"\"Benchmark de performance du syst√®me RTPA\"\"\"\n    \n    def __init__(self):\n        self.results = {}\n        self.app_manager = RTAPStudioManager()\n        \n    def benchmark_cfr_speed(self, iterations=1000):\n        \"\"\"Benchmark vitesse calculs CFR\"\"\"\n        print(\"üß† Test vitesse CFR...\")\n        \n        game_state = GameState(\n            hero_cards=(\"As\", \"Kh\"),\n            board_cards=(\"Ah\", \"Kd\", \"7c\"),\n            pot_size=100.0,\n            hero_stack=500.0\n        )\n        \n        start_time = time.time()\n        for i in range(iterations):\n            recommendation = self.app_manager.cfr_engine.get_recommendation(game_state)\n        end_time = time.time()\n        \n        total_time = end_time - start_time\n        avg_time = total_time / iterations\n        \n        self.results['cfr_speed'] = {\n            'total_time': total_time,\n            'avg_time_ms': avg_time * 1000,\n            'iterations': iterations,\n            'req_per_sec': iterations / total_time\n        }\n        \n        print(f\"  ‚úÖ {iterations} recommandations en {total_time:.2f}s\")\n        print(f\"  ‚úÖ Temps moyen: {avg_time*1000:.1f}ms\")\n        print(f\"  ‚úÖ D√©bit: {iterations/total_time:.1f} req/sec\")\n        \n    def benchmark_database_speed(self, operations=5000):\n        \"\"\"Benchmark vitesse base de donn√©es\"\"\"\n        print(\"üíæ Test vitesse base de donn√©es...\")\n        \n        db = MemoryDatabase()\n        \n        # Test √©criture\n        start_time = time.time()\n        for i in range(operations):\n            game_state = GameState(\n                hero_cards=(\"As\", \"Kh\"),\n                pot_size=float(100 + i),\n                hero_stack=float(500 + i)\n            )\n            recommendation = {\n                'action_type': 'bet',\n                'bet_size': 50.0,\n                'timestamp': time.time()\n            }\n            db.store_recommendation(recommendation)\n        \n        write_time = time.time() - start_time\n        \n        # Test lecture\n        start_time = time.time()\n        for i in range(operations):\n            recent = db.get_latest_recommendation()\n        read_time = time.time() - start_time\n        \n        self.results['database_speed'] = {\n            'write_ops': operations,\n            'write_time': write_time,\n            'write_ops_per_sec': operations / write_time,\n            'read_ops': operations,\n            'read_time': read_time,\n            'read_ops_per_sec': operations / read_time\n        }\n        \n        print(f\"  ‚úÖ √âcriture: {operations/write_time:.0f} ops/sec\")\n        print(f\"  ‚úÖ Lecture: {operations/read_time:.0f} ops/sec\")\n        \n    def benchmark_memory_usage(self, duration=10):\n        \"\"\"Benchmark utilisation m√©moire\"\"\"\n        print(\"üß† Test utilisation m√©moire...\")\n        \n        process = psutil.Process()\n        initial_memory = process.memory_info().rss\n        max_memory = initial_memory\n        \n        # Simulation charge de travail\n        start_time = time.time()\n        while time.time() - start_time < duration:\n            # Simulation calculs CFR\n            for i in range(10):\n                game_state = GameState(\n                    hero_cards=(\"As\", \"Kh\"),\n                    board_cards=(\"Ah\", \"Kd\", \"7c\"),\n                    pot_size=float(100 + i),\n                    hero_stack=float(500 + i)\n                )\n                recommendation = self.app_manager.cfr_engine.get_recommendation(game_state)\n            \n            # Mesure m√©moire\n            current_memory = process.memory_info().rss\n            max_memory = max(max_memory, current_memory)\n            \n            time.sleep(0.1)\n        \n        final_memory = process.memory_info().rss\n        memory_growth = final_memory - initial_memory\n        peak_usage = max_memory - initial_memory\n        \n        self.results['memory_usage'] = {\n            'initial_mb': initial_memory / 1024 / 1024,\n            'final_mb': final_memory / 1024 / 1024,\n            'growth_mb': memory_growth / 1024 / 1024,\n            'peak_mb': peak_usage / 1024 / 1024\n        }\n        \n        print(f\"  ‚úÖ M√©moire initiale: {initial_memory/1024/1024:.1f} MB\")\n        print(f\"  ‚úÖ Croissance m√©moire: {memory_growth/1024/1024:.1f} MB\")\n        print(f\"  ‚úÖ Pic d'utilisation: {peak_usage/1024/1024:.1f} MB\")\n        \n    def benchmark_concurrent_load(self, threads=5, duration=5):\n        \"\"\"Benchmark charge concurrente\"\"\"\n        print(f\"‚ö° Test charge concurrente ({threads} threads)...\")\n        \n        results = {'completed': 0, 'errors': 0}\n        \n        def worker():\n            start_time = time.time()\n            while time.time() - start_time < duration:\n                try:\n                    game_state = GameState(\n                        hero_cards=(\"Qd\", \"Qs\"),\n                        board_cards=(\"9h\", \"3c\", \"2s\"),\n                        pot_size=200.0,\n                        hero_stack=800.0\n                    )\n                    recommendation = self.app_manager.cfr_engine.get_recommendation(game_state)\n                    results['completed'] += 1\n                except Exception as e:\n                    results['errors'] += 1\n                \n                time.sleep(0.01)\n        \n        # Lancement des threads\n        worker_threads = []\n        start_time = time.time()\n        \n        for i in range(threads):\n            thread = threading.Thread(target=worker, daemon=True)\n            thread.start()\n            worker_threads.append(thread)\n        \n        # Attendre completion\n        for thread in worker_threads:\n            thread.join()\n        \n        total_time = time.time() - start_time\n        \n        self.results['concurrent_load'] = {\n            'threads': threads,\n            'duration': total_time,\n            'completed_ops': results['completed'],\n            'errors': results['errors'],\n            'ops_per_sec': results['completed'] / total_time,\n            'success_rate': results['completed'] / (results['completed'] + results['errors']) if (results['completed'] + results['errors']) > 0 else 0\n        }\n        \n        print(f\"  ‚úÖ Op√©rations r√©ussies: {results['completed']}\")\n        print(f\"  ‚úÖ Erreurs: {results['errors']}\")\n        print(f\"  ‚úÖ D√©bit: {results['completed']/total_time:.1f} ops/sec\")\n        print(f\"  ‚úÖ Taux de succ√®s: {results['completed']/(results['completed']+results['errors'])*100:.1f}%\")\n        \n    def run_all_benchmarks(self):\n        \"\"\"Ex√©cute tous les benchmarks\"\"\"\n        print(\"üöÄ BENCHMARKS PERFORMANCE RTPA STUDIO\")\n        print(\"=\" * 50)\n        \n        self.benchmark_cfr_speed(500)\n        print()\n        \n        self.benchmark_database_speed(2000)\n        print()\n        \n        self.benchmark_memory_usage(5)\n        print()\n        \n        self.benchmark_concurrent_load(3, 3)\n        print()\n        \n        self.print_summary()\n        \n    def print_summary(self):\n        \"\"\"Affiche un r√©sum√© des performances\"\"\"\n        print(\"üìä R√âSUM√â PERFORMANCES\")\n        print(\"-\" * 30)\n        \n        if 'cfr_speed' in self.results:\n            cfr = self.results['cfr_speed']\n            status = \"‚úÖ EXCELLENT\" if cfr['avg_time_ms'] < 100 else \"‚ö†Ô∏è ACCEPTABLE\" if cfr['avg_time_ms'] < 500 else \"‚ùå LENT\"\n            print(f\"CFR: {cfr['avg_time_ms']:.1f}ms/req - {status}\")\n        \n        if 'database_speed' in self.results:\n            db = self.results['database_speed']\n            write_status = \"‚úÖ RAPIDE\" if db['write_ops_per_sec'] > 1000 else \"‚ö†Ô∏è MOYEN\" if db['write_ops_per_sec'] > 500 else \"‚ùå LENT\"\n            print(f\"Base: {db['write_ops_per_sec']:.0f} √©cr/sec - {write_status}\")\n        \n        if 'memory_usage' in self.results:\n            mem = self.results['memory_usage']\n            mem_status = \"‚úÖ STABLE\" if mem['growth_mb'] < 50 else \"‚ö†Ô∏è CROISSANCE\" if mem['growth_mb'] < 100 else \"‚ùå FUITE\"\n            print(f\"M√©moire: +{mem['growth_mb']:.1f}MB - {mem_status}\")\n        \n        if 'concurrent_load' in self.results:\n            conc = self.results['concurrent_load']\n            conc_status = \"‚úÖ STABLE\" if conc['success_rate'] > 0.95 else \"‚ö†Ô∏è INSTABLE\" if conc['success_rate'] > 0.9 else \"‚ùå PROBL√àME\"\n            print(f\"Concurrence: {conc['success_rate']*100:.1f}% succ√®s - {conc_status}\")\n\nif __name__ == '__main__':\n    benchmark = PerformanceBenchmark()\n    benchmark.run_all_benchmarks()","size_bytes":8845},"src/utils/platform_detector.py":{"content":"\"\"\"\nD√©tecteur automatique de plateformes poker\nSurveille les processus et fen√™tres pour d√©marrage automatique\n\"\"\"\n\nimport psutil\nimport time\nimport threading\nfrom typing import List, Dict, Optional, Callable\nfrom ..utils.logger import get_logger\n\nclass PlatformDetector:\n    \"\"\"D√©tecteur automatique des plateformes poker\"\"\"\n    \n    def __init__(self):\n        self.logger = get_logger(__name__)\n        \n        # Plateformes support√©es avec leurs processus\n        self.supported_platforms = {\n            'pokerstars': {\n                'processes': ['PokerStars.exe', 'pokerstars'],\n                'window_titles': ['PokerStars', 'Poker Stars'],\n                'name': 'PokerStars'\n            },\n            'winamax': {\n                'processes': ['Winamax.exe', 'winamax', 'WinamaxPoker.exe'],\n                'window_titles': ['Winamax', 'Winamax Poker'],\n                'name': 'Winamax'\n            },\n            'pmu': {\n                'processes': ['PMUPoker.exe', 'pmu-poker'],\n                'window_titles': ['PMU Poker', 'PMU.fr'],\n                'name': 'PMU Poker'\n            },\n            'partypoker': {\n                'processes': ['PartyPoker.exe', 'partypoker'],\n                'window_titles': ['PartyPoker', 'Party Poker'],\n                'name': 'PartyPoker'\n            }\n        }\n        \n        self.detected_platforms = set()\n        self.is_monitoring = False\n        self.monitor_thread = None\n        self.status_callback = None\n        self.detection_interval = 2.0  # V√©rification toutes les 2 secondes\n        \n        self.logger.info(\"PlatformDetector initialis√©\")\n    \n    def set_status_callback(self, callback: Callable[[str, str], None]):\n        \"\"\"D√©finit le callback pour les changements d'√©tat\"\"\"\n        self.status_callback = callback\n    \n    def start_monitoring(self):\n        \"\"\"D√©marre la surveillance automatique\"\"\"\n        if self.is_monitoring:\n            return\n        \n        self.is_monitoring = True\n        self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)\n        self.monitor_thread.start()\n        \n        self.logger.info(\"Surveillance automatique des plateformes d√©marr√©e\")\n    \n    def stop_monitoring(self):\n        \"\"\"Arr√™te la surveillance\"\"\"\n        self.is_monitoring = False\n        if self.monitor_thread:\n            self.monitor_thread.join(timeout=1.0)\n        \n        self.logger.info(\"Surveillance automatique arr√™t√©e\")\n    \n    def _monitor_loop(self):\n        \"\"\"Boucle de surveillance continue\"\"\"\n        while self.is_monitoring:\n            try:\n                current_platforms = self._detect_active_platforms()\n                \n                # D√©tecter les nouvelles plateformes\n                new_platforms = current_platforms - self.detected_platforms\n                for platform in new_platforms:\n                    self.logger.info(f\"Plateforme d√©tect√©e: {self.supported_platforms[platform]['name']}\")\n                    if self.status_callback:\n                        self.status_callback('platform_detected', platform)\n                \n                # D√©tecter les plateformes ferm√©es\n                closed_platforms = self.detected_platforms - current_platforms\n                for platform in closed_platforms:\n                    self.logger.info(f\"Plateforme ferm√©e: {self.supported_platforms[platform]['name']}\")\n                    if self.status_callback:\n                        self.status_callback('platform_closed', platform)\n                \n                self.detected_platforms = current_platforms\n                \n                # Notifier l'√©tat global\n                if current_platforms:\n                    if self.status_callback:\n                        self.status_callback('status', 'active')\n                else:\n                    if self.status_callback:\n                        self.status_callback('status', 'waiting')\n                \n            except Exception as e:\n                self.logger.error(f\"Erreur surveillance plateformes: {e}\")\n            \n            time.sleep(self.detection_interval)\n    \n    def _detect_active_platforms(self) -> set:\n        \"\"\"D√©tecte les plateformes actuellement actives\"\"\"\n        active_platforms = set()\n        \n        try:\n            # V√©rification par processus\n            for proc in psutil.process_iter(['pid', 'name']):\n                try:\n                    proc_name = proc.info['name']\n                    if proc_name:\n                        for platform_id, platform_info in self.supported_platforms.items():\n                            if any(proc_name.lower().startswith(p.lower().split('.')[0]) \n                                  for p in platform_info['processes']):\n                                active_platforms.add(platform_id)\n                                break\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    continue\n            \n            # V√©rification suppl√©mentaire par fen√™tres (si disponible)\n            try:\n                import pygetwindow as gw\n                windows = gw.getAllTitles()\n                \n                for window_title in windows:\n                    for platform_id, platform_info in self.supported_platforms.items():\n                        if any(title.lower() in window_title.lower() \n                              for title in platform_info['window_titles']):\n                            active_platforms.add(platform_id)\n                            break\n                            \n            except ImportError:\n                # pygetwindow non disponible, utiliser seulement les processus\n                pass\n            except Exception as e:\n                self.logger.debug(f\"Erreur d√©tection fen√™tres: {e}\")\n        \n        except Exception as e:\n            self.logger.error(f\"Erreur d√©tection plateformes: {e}\")\n        \n        return active_platforms\n    \n    def get_detected_platforms(self) -> List[Dict[str, str]]:\n        \"\"\"Retourne la liste des plateformes d√©tect√©es\"\"\"\n        return [\n            {\n                'id': platform_id,\n                'name': self.supported_platforms[platform_id]['name']\n            }\n            for platform_id in self.detected_platforms\n        ]\n    \n    def is_any_platform_active(self) -> bool:\n        \"\"\"V√©rifie si au moins une plateforme est active\"\"\"\n        return len(self.detected_platforms) > 0\n    \n    def get_primary_platform(self) -> Optional[str]:\n        \"\"\"Retourne la plateforme principale d√©tect√©e\"\"\"\n        if not self.detected_platforms:\n            return None\n        \n        # Ordre de priorit√©\n        priority_order = ['pokerstars', 'winamax', 'pmu', 'partypoker']\n        for platform in priority_order:\n            if platform in self.detected_platforms:\n                return platform\n        \n        # Retourner le premier disponible\n        return next(iter(self.detected_platforms))\n    \n    def force_detection(self) -> Dict[str, any]:\n        \"\"\"Force une d√©tection imm√©diate (pour tests)\"\"\"\n        platforms = self._detect_active_platforms()\n        return {\n            'active_platforms': list(platforms),\n            'platform_names': [self.supported_platforms[p]['name'] for p in platforms],\n            'count': len(platforms)\n        }","size_bytes":7329},"src/algorithms/cfr_trainer.py":{"content":"\"\"\"\nEntra√Æneur CFR intensif pour convergence Nash rapide\nImpl√©mentation optimis√©e avec m√©triques de qualit√©\n\"\"\"\n\nimport time\nimport threading\nimport numpy as np\nfrom typing import Dict, List, Any, Optional\nfrom collections import defaultdict, deque\nfrom concurrent.futures import ThreadPoolExecutor\nimport pickle\nimport json\n\nfrom .hand_parser import ParsedHand\nfrom .hand_generator import HandGenerator, GenerationSettings\nfrom .cfr_engine import CFREngine, PokerState\nfrom ..utils.logger import get_logger\n\nclass CFRTrainer:\n    \"\"\"Entra√Æneur CFR avec g√©n√©ration massive de mains\"\"\"\n    \n    def __init__(self, cfr_engine: CFREngine):\n        self.logger = get_logger(__name__)\n        self.cfr_engine = cfr_engine\n        \n        # Configuration d'entra√Ænement\n        self.target_iterations = 100000\n        self.convergence_threshold = 0.01\n        self.quality_threshold = 0.85\n        \n        # G√©n√©rateur de mains\n        generation_settings = GenerationSettings(\n            hands_per_batch=5000,\n            max_hands=500000,\n            preflop_ratio=0.3,\n            flop_ratio=0.3,\n            turn_ratio=0.25,\n            river_ratio=0.15\n        )\n        self.hand_generator = HandGenerator(generation_settings)\n        \n        # M√©triques de training\n        self.training_hands = []\n        self.convergence_history = deque(maxlen=1000)\n        self.quality_history = deque(maxlen=1000)\n        self.iteration_times = deque(maxlen=100)\n        \n        # √âtat de l'entra√Ænement\n        self.is_training = False\n        self.training_thread = None\n        self.start_time = 0.0\n        self.total_training_time = 0.0\n        \n        # M√©triques de progression pour l'interface\n        self.current_iteration = 0\n        self.training_start_time = None\n        \n        # Cache et optimisations\n        self.strategy_cache = {}\n        self.regret_updates = 0\n        self.strategy_updates = 0\n        \n        # G√©n√©rateur continu et gestionnaire de donn√©es\n        self.continuous_generator = None\n        self.data_manager = None\n        self._init_continuous_generator()\n        self._init_data_manager()\n        \n        self.logger.info(\"CFRTrainer initialis√© avec g√©n√©ration continue\")\n    \n    def _init_continuous_generator(self):\n        \"\"\"Initialise le g√©n√©rateur continu de mains\"\"\"\n        try:\n            from .continuous_generator import ContinuousHandGenerator, ContinuousSettings\n            \n            # Configuration optimis√©e pour performance\n            settings = ContinuousSettings(\n                batch_size=25,  # Petits batches pour r√©activit√©\n                generation_interval=0.2,  # 200ms entre g√©n√©rations\n                max_queue_size=500,  # Queue mod√©r√©e\n                cpu_usage_limit=0.1  # Max 10% CPU\n            )\n            \n            self.continuous_generator = ContinuousHandGenerator(settings)\n            \n            # Configuration des callbacks\n            self.continuous_generator.set_integration_callback(self._integrate_continuous_hands)\n            self.continuous_generator.set_stats_callback(self._update_generation_stats)\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur init g√©n√©rateur continu: {e}\")\n    \n    def _integrate_continuous_hands(self, hands):\n        \"\"\"Int√®gre les mains g√©n√©r√©es en continu dans l'entra√Ænement CFR\"\"\"\n        try:\n            if not hands:\n                return\n            \n            # Ajout imm√©diat aux mains d'entra√Ænement\n            self.training_hands.extend(hands)\n            \n            # Si entra√Ænement en cours, int√©gration directe dans CFR\n            if self.is_training:\n                for hand in hands:\n                    try:\n                        # Conversion en √©tat CFR\n                        cfr_state = self._hand_to_cfr_state(hand)\n                        if cfr_state:\n                            # Mise √† jour imm√©diate des tables CFR\n                            self._update_cfr_tables_immediate(cfr_state)\n                    except Exception as e:\n                        continue\n            \n            # Mise √† jour statistiques\n            if len(hands) > 0:\n                self.logger.debug(f\"Int√©gr√© {len(hands)} mains continues -> Total: {len(self.training_hands)}\")\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur int√©gration mains continues: {e}\")\n    \n    def _hand_to_cfr_state(self, hand):\n        \"\"\"Convertit une main pars√©e en √©tat CFR\"\"\"\n        try:\n            from .cfr_engine import PokerState\n            \n            # Extraction des informations de la main\n            hero_cards = (hand.hero_cards[0], hand.hero_cards[1]) if hand.hero_cards and len(hand.hero_cards) >= 2 else ('As', 'Ks')\n            board_cards = hand.board_cards if hand.board_cards else []\n            pot_size = hand.pot_size if hand.pot_size else 100.0\n            hero_stack = hand.hero_stack if hand.hero_stack else 1000.0\n            \n            # D√©termination de la street\n            street = 0\n            if len(board_cards) >= 3:\n                street = 1  # flop\n            if len(board_cards) >= 4:\n                street = 2  # turn\n            if len(board_cards) >= 5:\n                street = 3  # river\n            \n            cfr_state = PokerState(\n                street=street,\n                hero_cards=hero_cards,\n                board_cards=board_cards,\n                pot_size=pot_size,\n                hero_stack=hero_stack,\n                position=0,  # Default position\n                num_players=2,  # Default heads-up\n                current_bet=0.0,\n                action_history=[],\n                table_type=\"cashgame\"\n            )\n            \n            return cfr_state\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur conversion main->CFR: {e}\")\n            return None\n    \n    def _get_information_set(self, cfr_state):\n        \"\"\"G√©n√®re l'ensemble d'informations pour un √©tat CFR\"\"\"\n        try:\n            # G√©n√©ration simplifi√©e d'information set\n            bucket = self.cfr_engine.card_abstraction.get_bucket(\n                cfr_state.hero_cards, \n                cfr_state.board_cards, \n                cfr_state.street\n            )\n            \n            # Combine bucket, position, action history\n            action_history_str = \"_\".join(cfr_state.action_history[-5:])  # Derni√®res 5 actions\n            info_set = f\"{bucket}_{cfr_state.position}_{cfr_state.street}_{action_history_str}\"\n            \n            return info_set\n            \n        except Exception as e:\n            return f\"default_{cfr_state.street}_{hash(str(cfr_state.hero_cards)) % 100}\"\n    \n    def _get_legal_actions(self, cfr_state):\n        \"\"\"Retourne les actions l√©gales pour un √©tat CFR\"\"\"\n        try:\n            actions = ['fold', 'check_call']\n            \n            # Actions de mise disponibles selon l'√©tat\n            if cfr_state.hero_stack > cfr_state.current_bet:\n                # Tailles de mises bas√©es sur le pot\n                bet_sizes = [0.25, 0.5, 0.75, 1.0, 1.5, 2.0]\n                for size in bet_sizes:\n                    bet_amount = cfr_state.pot_size * size\n                    if bet_amount <= cfr_state.hero_stack:\n                        actions.append(f'bet_{size}')\n            \n            return actions\n            \n        except Exception:\n            return ['fold', 'check_call', 'bet_0.5']\n    \n    def _get_strategy_from_regrets(self, info_set):\n        \"\"\"Calcule la strat√©gie √† partir des regrets\"\"\"\n        try:\n            regrets = self.cfr_engine.regret_sum[info_set]\n            if not regrets:\n                # Strat√©gie uniforme par d√©faut\n                return {'fold': 0.2, 'check_call': 0.4, 'bet_0.5': 0.4}\n            \n            # Conversion regrets -> probabilit√©s\n            positive_regrets = {action: max(0, regret) for action, regret in regrets.items()}\n            total_regret = sum(positive_regrets.values())\n            \n            if total_regret <= 0:\n                # Strat√©gie uniforme si pas de regrets positifs\n                num_actions = len(regrets)\n                uniform_prob = 1.0 / num_actions\n                return {action: uniform_prob for action in regrets.keys()}\n            \n            # Normalisation\n            strategy = {action: regret / total_regret for action, regret in positive_regrets.items()}\n            return strategy\n            \n        except Exception:\n            return {'fold': 0.2, 'check_call': 0.4, 'bet_0.5': 0.4}\n    \n    def _update_cfr_tables_immediate(self, cfr_state):\n        \"\"\"Met √† jour les tables CFR imm√©diatement avec un nouvel √©tat\"\"\"\n        try:\n            # Calcul rapide CFR pour cet √©tat\n            info_set = self._get_information_set(cfr_state)\n            actions = self._get_legal_actions(cfr_state)\n            \n            if info_set and actions:\n                # Calcul des regrets pour cet √©tat\n                regrets = self._calculate_immediate_regrets(cfr_state, actions)\n                \n                # Mise √† jour des tables de regret\n                for action, regret in regrets.items():\n                    self.cfr_engine.regret_sum[info_set][action] += regret\n                \n                # Mise √† jour de la strat√©gie courante\n                strategy = self._get_strategy_from_regrets(info_set)\n                for action, prob in strategy.items():\n                    self.cfr_engine.strategy_sum[info_set][action] += prob\n                \n        except Exception as e:\n            pass  # Ignore les erreurs pour ne pas ralentir\n    \n    def _calculate_immediate_regrets(self, cfr_state, actions):\n        \"\"\"Calcul rapide des regrets pour un √©tat donn√©\"\"\"\n        regrets = {}\n        \n        try:\n            # Simulation Monte Carlo rapide\n            for action in actions:\n                # Valeur de l'action\n                action_value = self._quick_action_evaluation(cfr_state, action)\n                \n                # Valeur moyenne des autres actions\n                other_values = []\n                for other_action in actions:\n                    if other_action != action:\n                        other_values.append(self._quick_action_evaluation(cfr_state, other_action))\n                \n                avg_other_value = np.mean(other_values) if other_values else 0.0\n                \n                # Regret = diff√©rence\n                regrets[action] = max(0.0, float(avg_other_value - action_value))\n                \n        except Exception:\n            # Fallback: regrets uniformes\n            for action in actions:\n                regrets[action] = 0.1\n                \n        return regrets\n    \n    def _evaluate_hand_strength(self, hero_cards, board_cards):\n        \"\"\"√âvalue la force de la main actuelle\"\"\"\n        try:\n            # √âvaluation simplifi√©e de la force de main\n            if not hero_cards or len(hero_cards) != 2:\n                return 0.5\n                \n            # Bas√© sur les cartes hautes et potentiels\n            card_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, \n                          '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}\n            \n            hero_value = sum(card_values.get(card[0], 7) for card in hero_cards) / 28.0  # Normalis√©\n            \n            # Bonus pour paire\n            if hero_cards[0][0] == hero_cards[1][0]:\n                hero_value *= 1.5\n                \n            # Bonus pour couleur\n            if hero_cards[0][1] == hero_cards[1][1]:\n                hero_value *= 1.2\n                \n            return min(hero_value, 1.0)\n            \n        except Exception:\n            return 0.5\n    \n    def _quick_action_evaluation(self, cfr_state, action):\n        \"\"\"√âvaluation rapide d'une action\"\"\"\n        try:\n            # √âvaluation simplifi√©e bas√©e sur les heuristiques\n            hand_strength = self._evaluate_hand_strength(cfr_state.hero_cards, cfr_state.board_cards)\n            \n            if action == 'fold':\n                return 0.0\n            elif action == 'check_call':\n                return hand_strength * cfr_state.pot_size * 0.5\n            elif action.startswith('bet') or action.startswith('raise'):\n                # Valeur agressive bas√©e sur force de main\n                aggression_value = hand_strength * cfr_state.pot_size * 1.2\n                return aggression_value - (cfr_state.current_bet * 0.8)\n            else:\n                return hand_strength * cfr_state.pot_size * 0.3\n                \n        except Exception:\n            return 0.5  # Valeur neutre\n    \n    def _update_generation_stats(self, stats):\n        \"\"\"Met √† jour les statistiques de g√©n√©ration continue\"\"\"\n        try:\n            # Log p√©riodique des statistiques\n            if stats['hands_generated'] % 1000 == 0:\n                self.logger.info(f\"G√©n√©ration continue: {stats['hands_generated']} mains, \"\n                               f\"rate: {stats['generation_rate']:.1f}/s, \"\n                               f\"CPU: {stats['cpu_usage']*100:.1f}%\")\n                \n        except Exception as e:\n            pass\n    \n    def start_continuous_generation(self):\n        \"\"\"D√©marre la g√©n√©ration continue de mains\"\"\"\n        try:\n            if self.continuous_generator and not self.continuous_generator.running:\n                self.continuous_generator.start()\n                self.logger.info(\"G√©n√©ration continue de mains d√©marr√©e\")\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur d√©marrage g√©n√©ration continue: {e}\")\n    \n    def stop_continuous_generation(self):\n        \"\"\"Arr√™te la g√©n√©ration continue\"\"\"\n        try:\n            if self.continuous_generator and self.continuous_generator.running:\n                self.continuous_generator.stop()\n                self.logger.info(\"G√©n√©ration continue arr√™t√©e\")\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur arr√™t g√©n√©ration continue: {e}\")\n    \n    def boost_generation_for_scenario(self, scenario: str):\n        \"\"\"Booste la g√©n√©ration pour un sc√©nario sp√©cifique\"\"\"\n        try:\n            if self.continuous_generator:\n                self.continuous_generator.boost_generation(scenario, multiplier=3.0)\n                self.logger.info(f\"Boost g√©n√©ration activ√© pour: {scenario}\")\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur boost g√©n√©ration: {e}\")\n    \n    def _init_data_manager(self):\n        \"\"\"Initialise le gestionnaire de donn√©es optimis√©\"\"\"\n        try:\n            from .data_manager import DataManager, StorageSettings\n            \n            # Configuration du stockage\n            storage_settings = StorageSettings(\n                max_memory_hands=30000,  # 30k mains en m√©moire\n                max_disk_size_mb=200,    # 200MB max sur disque\n                compression_level=6,     # Compression √©quilibr√©e\n                cleanup_interval=180.0   # Nettoyage toutes les 3 minutes\n            )\n            \n            self.data_manager = DataManager(storage_settings)\n            self.data_manager.start_cleanup_service()\n            \n            self.logger.info(\"Gestionnaire de donn√©es initialis√©\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur init data manager: {e}\")\n    \n    def stop_continuous_generation_user(self):\n        \"\"\"Arr√™te la g√©n√©ration continue √† la demande de l'utilisateur\"\"\"\n        try:\n            if self.continuous_generator and self.continuous_generator.running:\n                self.continuous_generator.stop(user_initiated=True)\n                self.logger.info(\"G√©n√©ration continue arr√™t√©e par l'utilisateur\")\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur arr√™t utilisateur: {e}\")\n    \n    def is_generation_user_stopped(self) -> bool:\n        \"\"\"V√©rifie si la g√©n√©ration a √©t√© arr√™t√©e par l'utilisateur\"\"\"\n        if self.continuous_generator:\n            return self.continuous_generator.is_user_stopped()\n        return False\n    \n    def configure_generation_resources(self, cpu_percent: float = None, \n                                     memory_mb: float = None, rate_per_second: float = None):\n        \"\"\"Configure les ressources allou√©es √† la g√©n√©ration\"\"\"\n        try:\n            if self.continuous_generator:\n                cpu_limit = cpu_percent / 100.0 if cpu_percent else None\n                self.continuous_generator.set_resource_limits(\n                    cpu_limit=cpu_limit,\n                    memory_limit_mb=memory_mb,\n                    generation_rate=rate_per_second\n                )\n                self.logger.info(\"Ressources de g√©n√©ration mises √† jour\")\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur configuration ressources: {e}\")\n    \n    def configure_storage_settings(self, max_disk_mb: int = None, \n                                 max_memory_hands: int = None, compression_level: int = None):\n        \"\"\"Configure les param√®tres de stockage\"\"\"\n        try:\n            if self.data_manager:\n                settings_update = {}\n                if max_disk_mb is not None:\n                    settings_update['max_disk_size_mb'] = max_disk_mb\n                if max_memory_hands is not None:\n                    settings_update['max_memory_hands'] = max_memory_hands\n                if compression_level is not None:\n                    settings_update['compression_level'] = compression_level\n                \n                if settings_update:\n                    self.data_manager.configure_storage(settings_update)\n                    self.logger.info(\"Param√®tres de stockage mis √† jour\")\n                    \n        except Exception as e:\n            self.logger.error(f\"Erreur configuration stockage: {e}\")\n    \n    def get_storage_status(self) -> Dict[str, Any]:\n        \"\"\"Retourne le statut du stockage et des ressources\"\"\"\n        status = {\n            'generation_active': False,\n            'generation_user_stopped': False,\n            'storage_stats': {},\n            'generation_stats': {}\n        }\n        \n        try:\n            # Statut g√©n√©ration\n            if self.continuous_generator:\n                status['generation_active'] = self.continuous_generator.running\n                status['generation_user_stopped'] = self.continuous_generator.is_user_stopped()\n                status['generation_stats'] = self.continuous_generator.get_statistics()\n            \n            # Statut stockage\n            if self.data_manager:\n                status['storage_stats'] = self.data_manager.get_storage_statistics()\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur statut stockage: {e}\")\n        \n        return status\n    \n    def export_optimized_database(self, export_path: str) -> bool:\n        \"\"\"Exporte la base de donn√©es de fa√ßon optimis√©e\"\"\"\n        try:\n            if self.data_manager:\n                return self.data_manager.export_database(export_path)\n            else:\n                # Fallback export basique\n                self.logger.warning(\"Export basique - data manager non disponible\")\n                return self.export_cfr_data_fallback(export_path)\n                \n        except Exception as e:\n            self.logger.error(f\"Erreur export optimis√©: {e}\")\n            return False\n    \n    def export_cfr_data_fallback(self, export_path: str) -> bool:\n        \"\"\"Export basique des donn√©es CFR\"\"\"\n        try:\n            import json\n            \n            data = {\n                'training_hands': len(self.training_hands),\n                'regret_sum': dict(self.cfr_engine.regret_sum) if hasattr(self.cfr_engine, 'regret_sum') else {},\n                'strategy_sum': dict(self.cfr_engine.strategy_sum) if hasattr(self.cfr_engine, 'strategy_sum') else {},\n                'iterations': self.iterations_completed,\n                'timestamp': time.time()\n            }\n            \n            with open(export_path, 'w') as f:\n                json.dump(data, f, indent=2)\n            \n            self.logger.info(f\"Export CFR basique sauv√©: {export_path}\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur export CFR basique: {e}\")\n            return False\n    \n    def load_historical_hands(self, file_paths: List[str]) -> int:\n        \"\"\"Charge les mains historiques depuis les fichiers fournis\"\"\"\n        self.logger.info(\"Chargement des mains historiques...\")\n        \n        from .hand_parser import HandParser\n        parser = HandParser()\n        \n        total_hands = 0\n        for file_path in file_paths:\n            try:\n                hands = parser.parse_file(file_path)\n                self.training_hands.extend(hands)\n                total_hands += len(hands)\n                self.logger.info(f\"Charg√© {len(hands)} mains depuis {file_path}\")\n            except Exception as e:\n                self.logger.error(f\"Erreur chargement {file_path}: {e}\")\n        \n        self.logger.info(f\"Total mains historiques charg√©es: {total_hands}\")\n        return total_hands\n    \n    def generate_training_dataset(self, target_size: int = 500000) -> int:\n        \"\"\"G√©n√®re un dataset d'entra√Ænement massif\"\"\"\n        self.logger.info(f\"G√©n√©ration de {target_size} mains synth√©tiques...\")\n        \n        start_time = time.time()\n        \n        # G√©n√©ration par batches pour optimiser la m√©moire\n        batch_size = 10000\n        generated_hands = 0\n        \n        while generated_hands < target_size:\n            remaining = target_size - generated_hands\n            current_batch_size = min(batch_size, remaining)\n            \n            batch_hands = self.hand_generator.generate_batch(current_batch_size)\n            self.training_hands.extend(batch_hands)\n            generated_hands += len(batch_hands)\n            \n            if generated_hands % 50000 == 0:\n                self.logger.info(f\"G√©n√©r√© {generated_hands}/{target_size} mains...\")\n        \n        generation_time = time.time() - start_time\n        self.logger.info(f\"G√©n√©ration termin√©e: {generated_hands} mains en {generation_time:.2f}s\")\n        \n        return generated_hands\n    \n    def start_intensive_training(self, target_iterations: Optional[int] = None, \n                                target_convergence: Optional[float] = None) -> bool:\n        \"\"\"D√©marre l'entra√Ænement CFR intensif\"\"\"\n        if self.is_training:\n            self.logger.warning(\"Entra√Ænement d√©j√† en cours\")\n            return False\n        \n        if target_iterations:\n            self.target_iterations = target_iterations\n        if target_convergence:\n            self.convergence_threshold = target_convergence\n        \n        self.logger.info(f\"D√©marrage entra√Ænement CFR intensif:\")\n        self.logger.info(f\"  - Objectif: {self.target_iterations} it√©rations\")\n        self.logger.info(f\"  - Convergence: {self.convergence_threshold}\")\n        self.logger.info(f\"  - Mains disponibles: {len(self.training_hands)}\")\n        \n        # V√©rification dataset\n        if len(self.training_hands) < 10000:\n            self.logger.warning(\"Dataset insuffisant, g√©n√©ration de mains suppl√©mentaires...\")\n            self.generate_training_dataset(100000)\n        \n        # D√©marrage training en arri√®re-plan\n        self.is_training = True\n        self.start_time = time.time()\n        self.training_thread = threading.Thread(target=self._training_loop, daemon=True)\n        self.training_thread.start()\n        \n        return True\n    \n    def stop_training(self):\n        \"\"\"Arr√™te l'entra√Ænement\"\"\"\n        if self.is_training:\n            self.is_training = False\n            self.total_training_time += time.time() - self.start_time\n            self.logger.info(\"Arr√™t de l'entra√Ænement CFR demand√©\")\n    \n    def _training_loop(self):\n        \"\"\"Boucle principale d'entra√Ænement CFR\"\"\"\n        self.logger.info(\"D√©marrage de la boucle d'entra√Ænement CFR\")\n        \n        iteration = 0\n        last_convergence_check = 0\n        convergence = 1.0  # Initialize convergence\n        \n        # Initialiser le temps de d√©marrage pour l'estimation\n        self.training_start_time = time.time()\n        \n        while self.is_training and iteration < self.target_iterations:\n            try:\n                iter_start = time.time()\n                \n                # S√©lection batch de mains pour cette it√©ration\n                batch_hands = self._select_training_batch()\n                \n                # Entra√Ænement CFR sur le batch\n                convergence = self._train_cfr_batch(batch_hands, iteration)\n                \n                # Mise √† jour m√©triques\n                iter_time = time.time() - iter_start\n                self.iteration_times.append(iter_time)\n                self.convergence_history.append(convergence)\n                \n                iteration += 1\n                self.current_iteration = iteration  # Mettre √† jour pour l'interface\n                \n                # Check convergence p√©riodique\n                if iteration - last_convergence_check >= 100:\n                    quality = self._evaluate_strategy_quality()\n                    self.quality_history.append(quality)\n                    \n                    # Log progression\n                    if iteration % 1000 == 0:\n                        avg_time = np.mean(list(self.iteration_times))\n                        self.logger.info(f\"It√©ration {iteration}: convergence={convergence:.4f}, \"\n                                       f\"qualit√©={quality:.4f}, temps={avg_time:.3f}s\")\n                    \n                    # Check arr√™t anticip√© si convergence atteinte\n                    if convergence < self.convergence_threshold and quality > self.quality_threshold:\n                        self.logger.info(f\"Convergence atteinte √† l'it√©ration {iteration}\")\n                        break\n                    \n                    last_convergence_check = iteration\n                \n                # Pause courte pour √©viter surcharge CPU\n                time.sleep(0.001)\n                \n            except Exception as e:\n                self.logger.error(f\"Erreur it√©ration {iteration}: {e}\")\n                time.sleep(0.1)\n        \n        self.is_training = False\n        self.total_training_time += time.time() - self.start_time\n        \n        final_quality = self._evaluate_strategy_quality()\n        self.logger.info(f\"Entra√Ænement termin√©:\")\n        self.logger.info(f\"  - It√©rations: {iteration}\")\n        self.logger.info(f\"  - Convergence finale: {convergence:.4f}\")\n        self.logger.info(f\"  - Qualit√© finale: {final_quality:.4f}\")\n        self.logger.info(f\"  - Temps total: {self.total_training_time:.2f}s\")\n    \n    def _select_training_batch(self, batch_size: int = 100) -> List[ParsedHand]:\n        \"\"\"S√©lectionne un batch de mains pour l'entra√Ænement\"\"\"\n        if len(self.training_hands) < batch_size:\n            return self.training_hands.copy()\n        \n        # S√©lection stratifi√©e pour couvrir diff√©rentes situations\n        preflop_hands = [h for h in self.training_hands if h.street == 0]\n        postflop_hands = [h for h in self.training_hands if h.street > 0]\n        \n        batch = []\n        \n        # 40% preflop, 60% postflop\n        if preflop_hands:\n            batch.extend(np.random.choice(preflop_hands, size=min(40, len(preflop_hands)), replace=False))\n        if postflop_hands:\n            batch.extend(np.random.choice(postflop_hands, size=min(60, len(postflop_hands)), replace=False))\n        \n        return batch[:batch_size]\n    \n    def _train_cfr_batch(self, hands: List[ParsedHand], iteration: int) -> float:\n        \"\"\"Entra√Æne CFR sur un batch de mains\"\"\"\n        total_regret_change = 0.0\n        processed_hands = 0\n        \n        for hand in hands:\n            try:\n                # Conversion en PokerState\n                poker_state = self._convert_hand_to_poker_state(hand)\n                \n                # CFR traversal\n                regret_change = self._cfr_traversal(poker_state, iteration)\n                total_regret_change += abs(regret_change)\n                processed_hands += 1\n                \n            except Exception as e:\n                self.logger.error(f\"Erreur processing main {hand.hand_id}: {e}\")\n        \n        # Calcul de convergence (changement moyen des regrets)\n        convergence = total_regret_change / max(processed_hands, 1)\n        return convergence\n    \n    def _cfr_traversal(self, poker_state: PokerState, iteration: int) -> float:\n        \"\"\"Effectue une travers√©e CFR sur un √©tat de poker\"\"\"\n        \n        # Calcul information set\n        info_set = self.cfr_engine._get_information_set(poker_state)\n        \n        # Actions disponibles\n        actions = self.cfr_engine._get_available_actions(poker_state)\n        if not actions:\n            return 0.0\n        \n        # Strat√©gie actuelle\n        strategy = self.cfr_engine._get_strategy(info_set, poker_state)\n        \n        # Calcul des valeurs d'action (simplifi√©)\n        action_values = {}\n        for action in actions:\n            # Simulation de la valeur de l'action\n            value = self._simulate_action_value(poker_state, action)\n            action_values[action] = value\n        \n        # Calcul des regrets\n        node_value = sum(strategy.get(action, 0) * action_values.get(action, 0) for action in actions)\n        total_regret_change = 0.0\n        \n        for action in actions:\n            # Regret = valeur action - valeur noeud\n            regret = action_values.get(action, 0) - node_value\n            \n            # Mise √† jour regret avec discount\n            old_regret = self.cfr_engine.regret_sum[info_set][action]\n            self.cfr_engine.regret_sum[info_set][action] = max(0, old_regret + regret)\n            \n            total_regret_change += abs(regret)\n            self.regret_updates += 1\n        \n        # Mise √† jour strat√©gie cumul√©e\n        for action in actions:\n            self.cfr_engine.strategy_sum[info_set][action] += strategy.get(action, 0)\n            self.strategy_updates += 1\n        \n        return total_regret_change\n    \n    def _simulate_action_value(self, poker_state: PokerState, action: str) -> float:\n        \"\"\"Simule la valeur d'une action (impl√©mentation simplifi√©e)\"\"\"\n        \n        # √âvaluation basique selon l'action et l'√©tat\n        base_value = 0.0\n        \n        # Force de main approximative\n        hand_strength = self._estimate_hand_strength(poker_state)\n        \n        if action == 'fold':\n            base_value = -poker_state.current_bet\n        elif action == 'check' or action == 'call':\n            base_value = hand_strength * poker_state.pot_size - poker_state.current_bet\n        elif action.startswith('bet') or action.startswith('raise'):\n            # Extract bet size\n            try:\n                bet_size = float(action.split('_')[1]) if '_' in action else poker_state.pot_size * 0.5\n            except (ValueError, IndexError, AttributeError):\n                bet_size = poker_state.pot_size * 0.5\n            \n            # Agressivit√© r√©compens√©e selon force de main\n            aggression_bonus = hand_strength * bet_size * 0.5\n            base_value = hand_strength * (poker_state.pot_size + bet_size) - bet_size + aggression_bonus\n        \n        # Ajustement selon position et SPR\n        spr = poker_state.hero_stack / max(poker_state.pot_size, 1)\n        position_factor = 1.1 if poker_state.position == 1 else 0.9  # Button advantage\n        spr_factor = min(1.2, max(0.8, spr / 10))  # SPR adjustment\n        \n        return base_value * position_factor * spr_factor\n    \n    def _estimate_hand_strength(self, poker_state: PokerState) -> float:\n        \"\"\"Estime la force de la main (impl√©mentation simplifi√©e)\"\"\"\n        \n        hero_cards = poker_state.hero_cards\n        board_cards = poker_state.board_cards\n        \n        if not hero_cards or hero_cards == (\"\", \"\"):\n            return 0.5\n        \n        # Analyse basique des cartes\n        ranks = [card[0] for card in hero_cards if card]\n        suits = [card[1] for card in hero_cards if len(card) == 2]\n        \n        strength = 0.5  # Base\n        \n        # Pocket pairs\n        if len(ranks) == 2 and ranks[0] == ranks[1]:\n            pair_values = {'A': 0.95, 'K': 0.9, 'Q': 0.85, 'J': 0.8, 'T': 0.75}\n            strength = pair_values.get(ranks[0], 0.7)\n        \n        # High cards\n        elif 'A' in ranks:\n            strength = 0.75 if 'K' in ranks or 'Q' in ranks else 0.65\n        elif 'K' in ranks and 'Q' in ranks:\n            strength = 0.7\n        \n        # Suited\n        if len(suits) == 2 and suits[0] == suits[1]:\n            strength += 0.05\n        \n        # Ajustement selon board (tr√®s simplifi√©)\n        if board_cards:\n            hero_ranks_set = set(ranks)\n            board_ranks_set = set([card[0] for card in board_cards if card])\n            \n            # Paire avec board\n            if hero_ranks_set & board_ranks_set:\n                strength += 0.15\n        \n        return min(1.0, max(0.0, strength))\n    \n    def _convert_hand_to_poker_state(self, hand: ParsedHand) -> PokerState:\n        \"\"\"Convertit une ParsedHand en PokerState\"\"\"\n        return PokerState(\n            street=hand.street,\n            hero_cards=hand.hero_cards,\n            board_cards=hand.board_cards,\n            pot_size=hand.pot_size,\n            hero_stack=hand.hero_stack,\n            position=hand.position,\n            num_players=2,  # Heads-up par d√©faut\n            current_bet=hand.blinds[1],  # Big blind comme bet de base\n            action_history=hand.actions,\n            table_type=\"cashgame\"\n        )\n    \n    def _evaluate_strategy_quality(self) -> float:\n        \"\"\"√âvalue la qualit√© de la strat√©gie actuelle\"\"\"\n        \n        # M√©triques de qualit√©:\n        # 1. Coh√©rence des strat√©gies\n        # 2. Exploitation des situations √©videntes\n        # 3. Convergence des regrets\n        \n        if not self.cfr_engine.strategy_sum:\n            return 0.0\n        \n        quality_score = 0.0\n        num_evaluations = 0\n        \n        # Sample information sets pour √©valuation\n        info_sets = list(self.cfr_engine.strategy_sum.keys())\n        sample_size = min(100, len(info_sets))\n        \n        if sample_size == 0:\n            return 0.0\n        \n        sample_info_sets = np.random.choice(info_sets, size=sample_size, replace=False)\n        \n        for info_set in sample_info_sets:\n            strategy_sum = self.cfr_engine.strategy_sum[info_set]\n            \n            if not strategy_sum:\n                continue\n            \n            # Normalisation de la strat√©gie\n            total = sum(strategy_sum.values())\n            if total <= 0:\n                continue\n            \n            normalized_strategy = {action: count/total for action, count in strategy_sum.items()}\n            \n            # √âvaluation de coh√©rence (entropy inverse)\n            entropy = 0.0\n            for prob in normalized_strategy.values():\n                if prob > 0:\n                    entropy -= prob * np.log2(prob)\n            \n            # Score de qualit√© (pr√©f√®re strat√©gies moins al√©atoires)\n            max_entropy = np.log2(len(normalized_strategy))\n            coherence_score = 1.0 - (entropy / max_entropy) if max_entropy > 0 else 1.0\n            \n            quality_score += coherence_score\n            num_evaluations += 1\n        \n        average_quality = quality_score / max(num_evaluations, 1)\n        \n        # Ajustement selon nombre d'it√©rations (strat√©gies prennent temps √† converger)\n        iteration_factor = min(1.0, self.cfr_engine.iterations / 10000)\n        \n        return average_quality * iteration_factor\n    \n    def save_training_progress(self, file_path: str):\n        \"\"\"Sauvegarde le progr√®s d'entra√Ænement\"\"\"\n        try:\n            progress_data = {\n                'iterations': self.cfr_engine.iterations,\n                'total_training_time': self.total_training_time,\n                'convergence_history': list(self.convergence_history),\n                'quality_history': list(self.quality_history),\n                'regret_updates': self.regret_updates,\n                'strategy_updates': self.strategy_updates,\n                'hands_trained': len(self.training_hands),\n                'final_quality': self._evaluate_strategy_quality()\n            }\n            \n            with open(file_path, 'w') as f:\n                json.dump(progress_data, f, indent=2)\n            \n            self.logger.info(f\"Progr√®s sauvegard√©: {file_path}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur sauvegarde progr√®s: {e}\")\n    \n    def get_training_statistics(self) -> Dict[str, Any]:\n        \"\"\"Retourne les statistiques d'entra√Ænement stabilis√©es\"\"\"\n        \n        # Calcul qualit√© liss√©e pour √©viter fluctuations\n        try:\n            if not hasattr(self, '_quality_history'):\n                self._quality_history = []\n            \n            raw_quality = self._evaluate_strategy_quality()\n            self._quality_history.append(raw_quality)\n            \n            # Garder seulement les 5 derni√®res valeurs pour lissage\n            if len(self._quality_history) > 5:\n                self._quality_history.pop(0)\n            \n            # Moyenne mobile pour stabilit√©\n            current_quality = sum(self._quality_history) / len(self._quality_history)\n        except Exception:\n            current_quality = getattr(self, '_last_quality', 0.0)\n        \n        self._last_quality = current_quality\n        \n        # Convergence stabilis√©e\n        last_convergence = self.convergence_history[-1] if self.convergence_history else 1.0\n        \n        # Progression monotone croissante\n        if not hasattr(self, '_last_progress'):\n            self._last_progress = 0.0\n        \n        current_progress = min(100, (self.cfr_engine.iterations / max(self.target_iterations, 1)) * 100)\n        # S'assurer que la progression ne recule jamais\n        self._last_progress = max(self._last_progress, current_progress)\n        \n        # Temps d'estimation stabilis√©\n        if self.iteration_times and len(self.iteration_times) > 5:\n            avg_time = np.mean(list(self.iteration_times)[-5:])  # Moyenne des 5 derni√®res\n        else:\n            avg_time = np.mean(list(self.iteration_times)) if self.iteration_times else 0.1\n        \n        remaining_iterations = max(0, self.target_iterations - self.cfr_engine.iterations)\n        estimated_time_remaining = remaining_iterations * avg_time\n        \n        return {\n            'is_training': self.is_training,\n            'iterations': self.cfr_engine.iterations,\n            'target_iterations': self.target_iterations,\n            'training_hands': len(self.training_hands),\n            'regret_updates': self.regret_updates,\n            'strategy_updates': self.strategy_updates,\n            'total_training_time': self.total_training_time,\n            'current_quality': min(1.0, max(0.0, current_quality)),\n            'last_convergence': max(0.001, last_convergence),\n            'convergence_threshold': self.convergence_threshold,\n            'quality_threshold': self.quality_threshold,\n            'avg_iteration_time': max(0.01, avg_time),\n            'info_sets_learned': len(self.cfr_engine.strategy_sum),\n            'progress_percentage': self._last_progress,\n            'estimated_time_remaining': max(0, estimated_time_remaining)\n        }","size_bytes":39892},"src/algorithms/continuous_generator.py":{"content":"\"\"\"\nG√©n√©rateur continu de mains poker pour am√©lioration CFR temps r√©el\nTourne en arri√®re-plan sans ralentir le logiciel principal\n\"\"\"\n\nimport time\nimport threading\nimport queue\nfrom typing import Optional, Callable, List\nfrom dataclasses import dataclass\nimport random\n\nfrom .hand_generator import HandGenerator, GenerationSettings\nfrom .hand_parser import ParsedHand\nfrom ..utils.logger import get_logger\n\n@dataclass\nclass ContinuousSettings:\n    \"\"\"Configuration du g√©n√©rateur continu\"\"\"\n    batch_size: int = 50  # Petits batches pour √©viter latence\n    generation_interval: float = 0.1  # 100ms entre g√©n√©rations\n    max_queue_size: int = 1000  # File d'attente limit√©e\n    cpu_usage_limit: float = 0.15  # Max 15% CPU\n    priority_scenarios: Optional[List[str]] = None  # Sc√©narios prioritaires\n    \n    def __post_init__(self):\n        if self.priority_scenarios is None:\n            self.priority_scenarios = [\n                'heads_up',\n                'tournament_bubble', \n                'deep_stacks',\n                'short_stacks',\n                'multiway_pots'\n            ]\n\nclass ContinuousHandGenerator:\n    \"\"\"G√©n√©rateur de mains en continu optimis√© pour performance\"\"\"\n    \n    def __init__(self, settings: Optional[ContinuousSettings] = None):\n        self.logger = get_logger(__name__)\n        self.settings = settings or ContinuousSettings()\n        \n        # Composants\n        self.hand_generator = HandGenerator()\n        self.generation_queue = queue.Queue(maxsize=self.settings.max_queue_size)\n        \n        # √âtat du g√©n√©rateur\n        self.running = False\n        self.generation_thread = None\n        self.processing_thread = None\n        self.paused = False\n        self.user_stopped = False  # Arr√™t manuel par utilisateur\n        \n        # Statistiques\n        self.hands_generated = 0\n        self.hands_integrated = 0\n        self.generation_rate = 0.0  # mains/seconde\n        self.cpu_usage = 0.0\n        \n        # Callbacks\n        self.integration_callback: Optional[Callable] = None\n        self.stats_callback: Optional[Callable] = None\n        \n        # Optimisations performance\n        self.last_cpu_check = time.time()\n        self.adaptive_interval = self.settings.generation_interval\n        \n        self.logger.info(\"G√©n√©rateur continu initialis√©\")\n    \n    def set_integration_callback(self, callback: Callable):\n        \"\"\"D√©finit le callback pour int√©grer les mains dans CFR\"\"\"\n        self.integration_callback = callback\n    \n    def set_stats_callback(self, callback: Callable):\n        \"\"\"D√©finit le callback pour les statistiques temps r√©el\"\"\"\n        self.stats_callback = callback\n    \n    def start(self):\n        \"\"\"D√©marre la g√©n√©ration continue\"\"\"\n        if self.running:\n            return\n        \n        self.running = True\n        self.paused = False\n        \n        # Thread de g√©n√©ration (priorit√© basse)\n        self.generation_thread = threading.Thread(\n            target=self._generation_loop,\n            daemon=True,\n            name=\"ContinuousGenerator\"\n        )\n        \n        # Thread de traitement/int√©gration\n        self.processing_thread = threading.Thread(\n            target=self._processing_loop,\n            daemon=True,\n            name=\"HandProcessor\"\n        )\n        \n        self.generation_thread.start()\n        self.processing_thread.start()\n        \n        self.logger.info(\"G√©n√©ration continue d√©marr√©e\")\n    \n    def stop(self, user_initiated: bool = False):\n        \"\"\"Arr√™te la g√©n√©ration continue\"\"\"\n        self.running = False\n        self.user_stopped = user_initiated\n        \n        if self.generation_thread:\n            self.generation_thread.join(timeout=1.0)\n        if self.processing_thread:\n            self.processing_thread.join(timeout=1.0)\n        \n        stop_reason = \"par l'utilisateur\" if user_initiated else \"automatiquement\"\n        self.logger.info(f\"G√©n√©ration continue arr√™t√©e {stop_reason}\")\n    \n    def is_user_stopped(self) -> bool:\n        \"\"\"V√©rifie si l'arr√™t a √©t√© initi√© par l'utilisateur\"\"\"\n        return self.user_stopped\n    \n    def set_resource_limits(self, cpu_limit: Optional[float] = None, memory_limit_mb: Optional[float] = None, \n                           generation_rate: Optional[float] = None):\n        \"\"\"Configure les limites de ressources avec feedback utilisateur\"\"\"\n        if cpu_limit is not None:\n            old_limit = self.settings.cpu_usage_limit\n            self.settings.cpu_usage_limit = min(1.0, max(0.01, cpu_limit))\n            self.logger.info(f\"Limite CPU mise √† jour: {cpu_limit*100:.1f}%\")\n            print(f\"üéõÔ∏è CPU limite: {old_limit*100:.1f}% ‚Üí {self.settings.cpu_usage_limit*100:.1f}% (active dans la g√©n√©ration continue)\")\n        \n        if memory_limit_mb is not None:\n            # Ajustement de la taille de queue selon m√©moire disponible\n            old_queue = self.settings.max_queue_size\n            max_hands_in_queue = int(memory_limit_mb * 2)  # ~2 mains par MB\n            self.settings.max_queue_size = min(2000, max(100, max_hands_in_queue))\n            self.logger.info(f\"Limite m√©moire mise √† jour: {memory_limit_mb:.0f}MB\")\n            print(f\"üéõÔ∏è RAM limite: {old_queue} ‚Üí {self.settings.max_queue_size} mains en queue ({memory_limit_mb:.0f}MB)\")\n        \n        if generation_rate is not None:\n            old_interval = self.settings.generation_interval\n            self.settings.generation_interval = max(0.05, 1.0 / generation_rate)\n            self.logger.info(f\"Taux g√©n√©ration mis √† jour: {generation_rate:.1f} mains/s\")\n            old_rate = 1.0 / old_interval if old_interval > 0 else 0\n            new_rate = 1.0 / self.settings.generation_interval\n            print(f\"üéõÔ∏è Vitesse g√©n√©ration: {old_rate:.1f} ‚Üí {new_rate:.1f} mains/seconde\")\n        \n        # Afficher le r√©sum√© des param√®tres actuels\n        self._print_current_settings()\n    \n    def pause(self):\n        \"\"\"Met en pause la g√©n√©ration\"\"\"\n        self.paused = True\n        self.logger.info(\"G√©n√©ration continue en pause\")\n    \n    def resume(self):\n        \"\"\"Reprend la g√©n√©ration\"\"\"\n        self.paused = False\n        self.logger.info(\"G√©n√©ration continue reprise\")\n    \n    def _generation_loop(self):\n        \"\"\"Boucle principale de g√©n√©ration\"\"\"\n        start_time = time.time()\n        batch_count = 0\n        \n        while self.running:\n            try:\n                if self.paused:\n                    time.sleep(0.1)\n                    continue\n                \n                # V√©rification charge CPU\n                if self._should_throttle():\n                    time.sleep(self.adaptive_interval * 2)\n                    continue\n                \n                # G√©n√©ration d'un petit batch\n                batch = self._generate_optimized_batch()\n                \n                if batch:\n                    # Ajout √† la queue (non-bloquant)\n                    try:\n                        self.generation_queue.put(batch, block=False)\n                        self.hands_generated += len(batch)\n                        batch_count += 1\n                        \n                        # Calcul du taux de g√©n√©ration\n                        if batch_count % 10 == 0:\n                            elapsed = time.time() - start_time\n                            self.generation_rate = self.hands_generated / elapsed\n                    \n                    except queue.Full:\n                        # Queue pleine, on attend\n                        time.sleep(self.adaptive_interval * 3)\n                \n                # Attente adaptative\n                time.sleep(self.adaptive_interval)\n                \n            except Exception as e:\n                self.logger.error(f\"Erreur g√©n√©ration continue: {e}\")\n                time.sleep(1.0)\n    \n    def _processing_loop(self):\n        \"\"\"Boucle de traitement et int√©gration\"\"\"\n        while self.running:\n            try:\n                # R√©cup√©ration d'un batch\n                batch = self.generation_queue.get(timeout=1.0)\n                \n                if batch and self.integration_callback:\n                    # Int√©gration imm√©diate dans CFR\n                    self.integration_callback(batch)\n                    self.hands_integrated += len(batch)\n                    \n                    # Mise √† jour statistiques\n                    if self.stats_callback:\n                        stats = self.get_statistics()\n                        self.stats_callback(stats)\n                \n                self.generation_queue.task_done()\n                \n            except queue.Empty:\n                continue\n            except Exception as e:\n                self.logger.error(f\"Erreur traitement: {e}\")\n                time.sleep(0.5)\n    \n    def _generate_optimized_batch(self) -> List[ParsedHand]:\n        \"\"\"G√©n√®re un batch optimis√© selon les priorit√©s\"\"\"\n        try:\n            # S√©lection scenario prioritaire\n            if self.settings.priority_scenarios:\n                scenario = random.choice(self.settings.priority_scenarios)\n            else:\n                # Sc√©nario par d√©faut si pas de priorit√©s\n                default_scenarios = [\n                    'heads_up', 'deep_stacks', 'short_stacks', \n                    'tournament_bubble', 'multiway_pots'\n                ]\n                scenario = random.choice(default_scenarios)\n            \n            # Configuration adapt√©e au scenario\n            settings = self._get_scenario_settings(scenario)\n            \n            # G√©n√©ration rapide\n            temp_generator = HandGenerator(settings)\n            batch = temp_generator.generate_batch(self.settings.batch_size)\n            \n            return batch\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur g√©n√©ration batch: {e}\")\n            return []\n    \n    def _get_scenario_settings(self, scenario: str) -> GenerationSettings:\n        \"\"\"Retourne les param√®tres optimis√©s pour un sc√©nario\"\"\"\n        base_settings = GenerationSettings()\n        \n        if scenario == 'heads_up':\n            base_settings.stack_sizes = [1000.0, 1000.0]\n            \n        elif scenario == 'tournament_bubble':\n            base_settings.stack_sizes = [200.0, 300.0, 150.0, 400.0, 100.0, 250.0]\n            \n        elif scenario == 'deep_stacks':\n            base_settings.stack_sizes = [5000.0] * 6\n            base_settings.blind_levels = [(25.0, 50.0)]\n            \n        elif scenario == 'short_stacks':\n            base_settings.stack_sizes = [400.0] * 6\n            base_settings.blind_levels = [(50.0, 100.0)]\n            \n        elif scenario == 'multiway_pots':\n            # Configuration pour pots multiway\n            base_settings.stack_sizes = [2500.0] * 9\n        \n        return base_settings\n    \n    def _should_throttle(self) -> bool:\n        \"\"\"D√©termine si on doit ralentir pour √©conomiser CPU\"\"\"\n        current_time = time.time()\n        \n        # V√©rification CPU p√©riodique\n        if current_time - self.last_cpu_check > 5.0:  # Chaque 5 secondes\n            try:\n                import psutil\n                cpu_percent = psutil.cpu_percent(interval=0.1)\n                self.cpu_usage = cpu_percent / 100.0\n                \n                # Adaptation de l'intervalle selon CPU\n                if self.cpu_usage > self.settings.cpu_usage_limit:\n                    self.adaptive_interval = min(1.0, self.adaptive_interval * 1.5)\n                    return True\n                else:\n                    self.adaptive_interval = max(\n                        self.settings.generation_interval,\n                        self.adaptive_interval * 0.9\n                    )\n                \n                self.last_cpu_check = current_time\n                \n            except ImportError:\n                # Fallback si psutil non disponible\n                pass\n        \n        return False\n    \n    def _print_current_settings(self):\n        \"\"\"Affiche un r√©sum√© des param√®tres actuels\"\"\"\n        print(f\"üìä Param√®tres g√©n√©ration CFR:\")\n        print(f\"   ‚Ä¢ CPU limite: {self.settings.cpu_usage_limit*100:.1f}%\")\n        print(f\"   ‚Ä¢ Queue m√©moire: {self.settings.max_queue_size} mains max\")\n        print(f\"   ‚Ä¢ Vitesse cible: {1.0/self.settings.generation_interval:.1f} mains/seconde\")\n        print(f\"   ‚Ä¢ Intervalle adaptatif actuel: {self.adaptive_interval:.3f}s\")\n        print(f\"   ‚Ä¢ Usage CPU actuel: {self.cpu_usage*100:.1f}%\")\n    \n    def get_statistics(self) -> dict:\n        \"\"\"Retourne les statistiques de g√©n√©ration\"\"\"\n        queue_size = self.generation_queue.qsize()\n        \n        return {\n            'running': self.running,\n            'paused': self.paused,\n            'hands_generated': self.hands_generated,\n            'hands_integrated': self.hands_integrated,\n            'generation_rate': self.generation_rate,\n            'queue_size': queue_size,\n            'cpu_usage': self.cpu_usage,\n            'adaptive_interval': self.adaptive_interval,\n            'integration_pending': queue_size > 0\n        }\n    \n    def boost_generation(self, scenario: Optional[str] = None, multiplier: float = 2.0):\n        \"\"\"Booste temporairement la g√©n√©ration pour un sc√©nario\"\"\"\n        if scenario and self.settings.priority_scenarios:\n            # Focus sur un sc√©nario sp√©cifique\n            original_scenarios = self.settings.priority_scenarios.copy()\n            self.settings.priority_scenarios = [scenario] * 5\n            \n            # Restore apr√®s 10 secondes\n            def restore():\n                time.sleep(10.0)\n                if self.settings.priority_scenarios:\n                    self.settings.priority_scenarios = original_scenarios\n            \n            threading.Thread(target=restore, daemon=True).start()\n        \n        # R√©duction temporaire de l'intervalle\n        original_interval = self.adaptive_interval\n        self.adaptive_interval = original_interval / multiplier\n        \n        def restore_interval():\n            time.sleep(30.0)  # Boost pendant 30 secondes\n            self.adaptive_interval = original_interval\n        \n        threading.Thread(target=restore_interval, daemon=True).start()\n        \n        self.logger.info(f\"Boost g√©n√©ration activ√©: {scenario or 'g√©n√©ral'} x{multiplier}\")","size_bytes":14404},"src/algorithms/data_manager.py":{"content":"\"\"\"\nGestionnaire de donn√©es optimis√© pour g√©n√©ration continue\nGestion intelligente de l'espace disque et compactage automatique\n\"\"\"\n\nimport os\nimport time\nimport threading\nimport json\nimport gzip\nimport pickle\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom dataclasses import dataclass, asdict\nfrom collections import deque\nimport numpy as np\n\nfrom .hand_parser import ParsedHand\nfrom ..utils.logger import get_logger\n\n@dataclass\nclass StorageSettings:\n    \"\"\"Configuration de la gestion du stockage\"\"\"\n    max_memory_hands: int = 50000  # Mains max en m√©moire\n    max_disk_size_mb: int = 500   # Taille max sur disque (MB)\n    compression_level: int = 6    # Niveau compression gzip\n    archive_threshold: int = 100000  # Seuil d'archivage\n    cleanup_interval: float = 300.0  # Nettoyage toutes les 5 minutes\n    export_format: str = \"compressed\"  # \"json\", \"pickle\", \"compressed\"\n    retention_days: int = 7  # R√©tention des archives (jours)\n\nclass DataManager:\n    \"\"\"Gestionnaire de donn√©es avec compactage et gestion d'espace\"\"\"\n    \n    def __init__(self, storage_settings: Optional[StorageSettings] = None):\n        self.logger = get_logger(__name__)\n        self.settings = storage_settings or StorageSettings()\n        \n        # Stockage en m√©moire (circulaire)\n        self.active_hands = deque(maxlen=self.settings.max_memory_hands)\n        self.archived_hands_count = 0\n        \n        # Donn√©es CFR compact√©es\n        self.compressed_cfr_data = {}\n        self.cfr_snapshots = deque(maxlen=10)  # 10 snapshots max\n        \n        # Gestion des fichiers\n        self.data_directory = \"data\"\n        self.archive_directory = \"data/archives\"\n        self.temp_directory = \"data/temp\"\n        self._ensure_directories()\n        \n        # Thread de nettoyage automatique\n        self.cleanup_thread = None\n        self.cleanup_running = False\n        \n        # Statistiques de stockage\n        self.storage_stats = {\n            'memory_usage_mb': 0.0,\n            'disk_usage_mb': 0.0,\n            'compression_ratio': 0.0,\n            'hands_in_memory': 0,\n            'hands_archived': 0,\n            'last_cleanup': 0.0\n        }\n        \n        self.logger.info(\"DataManager initialis√© avec gestion d'espace optimis√©e\")\n    \n    def _ensure_directories(self):\n        \"\"\"Cr√©e les r√©pertoires n√©cessaires\"\"\"\n        for directory in [self.data_directory, self.archive_directory, self.temp_directory]:\n            os.makedirs(directory, exist_ok=True)\n    \n    def start_cleanup_service(self):\n        \"\"\"D√©marre le service de nettoyage automatique\"\"\"\n        if not self.cleanup_running:\n            self.cleanup_running = True\n            self.cleanup_thread = threading.Thread(\n                target=self._cleanup_loop,\n                daemon=True,\n                name=\"DataCleanup\"\n            )\n            self.cleanup_thread.start()\n            self.logger.info(\"Service de nettoyage automatique d√©marr√©\")\n    \n    def stop_cleanup_service(self):\n        \"\"\"Arr√™te le service de nettoyage\"\"\"\n        self.cleanup_running = False\n        if self.cleanup_thread:\n            self.cleanup_thread.join(timeout=2.0)\n        self.logger.info(\"Service de nettoyage arr√™t√©\")\n    \n    def add_hands(self, hands: List[ParsedHand]) -> bool:\n        \"\"\"Ajoute des mains avec gestion automatique de l'espace\"\"\"\n        try:\n            # V√©rification espace disponible\n            if not self._check_storage_capacity():\n                self.logger.warning(\"Espace insuffisant, d√©clenchement nettoyage\")\n                self._emergency_cleanup()\n            \n            # Ajout en m√©moire\n            self.active_hands.extend(hands)\n            \n            # Archivage automatique si n√©cessaire\n            if len(self.active_hands) >= self.settings.max_memory_hands * 0.8:\n                self._archive_oldest_hands()\n            \n            # Mise √† jour statistiques\n            self._update_storage_stats()\n            \n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur ajout mains: {e}\")\n            return False\n    \n    def add_cfr_snapshot(self, regret_sum: Dict, strategy_sum: Dict, metadata: Dict):\n        \"\"\"Ajoute un snapshot CFR compress√©\"\"\"\n        try:\n            snapshot = {\n                'timestamp': time.time(),\n                'regret_sum': self._compress_cfr_tables(regret_sum),\n                'strategy_sum': self._compress_cfr_tables(strategy_sum),\n                'metadata': metadata\n            }\n            \n            self.cfr_snapshots.append(snapshot)\n            self.logger.debug(f\"Snapshot CFR ajout√© ({len(self.cfr_snapshots)} total)\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur snapshot CFR: {e}\")\n    \n    def _compress_cfr_tables(self, tables: Dict) -> bytes:\n        \"\"\"Compresse les tables CFR avec optimisation\"\"\"\n        try:\n            # Conversion en format compact\n            compact_data = {}\n            for info_set, actions in tables.items():\n                if actions:  # Seulement les non-vides\n                    compact_data[info_set] = dict(actions)\n            \n            # S√©rialisation et compression\n            data_bytes = pickle.dumps(compact_data, protocol=pickle.HIGHEST_PROTOCOL)\n            compressed = gzip.compress(data_bytes, compresslevel=self.settings.compression_level)\n            \n            # Calcul ratio compression\n            if len(data_bytes) > 0:\n                ratio = len(compressed) / len(data_bytes)\n                self.storage_stats['compression_ratio'] = ratio\n            \n            return compressed\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur compression CFR: {e}\")\n            return b''\n    \n    def _decompress_cfr_tables(self, compressed_data: bytes) -> Dict:\n        \"\"\"D√©compresse les tables CFR\"\"\"\n        try:\n            if not compressed_data:\n                return {}\n            \n            decompressed = gzip.decompress(compressed_data)\n            return pickle.loads(decompressed)\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur d√©compression CFR: {e}\")\n            return {}\n    \n    def _archive_oldest_hands(self):\n        \"\"\"Archive les mains les plus anciennes\"\"\"\n        try:\n            if len(self.active_hands) < 1000:\n                return\n            \n            # Extraction des mains √† archiver\n            hands_to_archive = []\n            archive_count = min(10000, len(self.active_hands) // 2)\n            \n            for _ in range(archive_count):\n                if self.active_hands:\n                    hands_to_archive.append(self.active_hands.popleft())\n            \n            if hands_to_archive:\n                # Sauvegarde compress√©e\n                archive_file = self._create_archive_file(hands_to_archive)\n                if archive_file:\n                    self.archived_hands_count += len(hands_to_archive)\n                    self.logger.info(f\"Archiv√© {len(hands_to_archive)} mains dans {archive_file}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur archivage: {e}\")\n    \n    def _create_archive_file(self, hands: List[ParsedHand]) -> Optional[str]:\n        \"\"\"Cr√©e un fichier d'archive compress√©\"\"\"\n        try:\n            timestamp = int(time.time())\n            filename = f\"hands_archive_{timestamp}.gz\"\n            filepath = os.path.join(self.archive_directory, filename)\n            \n            # Conversion en format compact\n            compact_hands = []\n            for hand in hands:\n                compact_hands.append({\n                    'actions': hand.actions,\n                    'board': hand.board_cards,\n                    'hero_cards': hand.hero_cards,\n                    'pot': hand.pot_size,\n                    'positions': hand.positions\n                })\n            \n            # Sauvegarde compress√©e\n            with gzip.open(filepath, 'wt', encoding='utf-8') as f:\n                json.dump(compact_hands, f, separators=(',', ':'))\n            \n            return filename\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur cr√©ation archive: {e}\")\n            return None\n    \n    def _check_storage_capacity(self) -> bool:\n        \"\"\"V√©rifie la capacit√© de stockage disponible\"\"\"\n        try:\n            # Taille disque utilis√©e\n            total_size = 0\n            for root, dirs, files in os.walk(self.data_directory):\n                for file in files:\n                    filepath = os.path.join(root, file)\n                    total_size += os.path.getsize(filepath)\n            \n            size_mb = total_size / (1024 * 1024)\n            self.storage_stats['disk_usage_mb'] = size_mb\n            \n            # V√©rification limite\n            return size_mb < self.settings.max_disk_size_mb\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur v√©rification espace: {e}\")\n            return True  # Par s√©curit√©, autoriser par d√©faut\n    \n    def _emergency_cleanup(self):\n        \"\"\"Nettoyage d'urgence en cas d'espace insuffisant\"\"\"\n        try:\n            # Suppression des archives les plus anciennes\n            archive_files = []\n            for file in os.listdir(self.archive_directory):\n                if file.endswith('.gz'):\n                    filepath = os.path.join(self.archive_directory, file)\n                    mtime = os.path.getmtime(filepath)\n                    archive_files.append((filepath, mtime))\n            \n            # Tri par anciennet√©\n            archive_files.sort(key=lambda x: x[1])\n            \n            # Suppression des plus anciens (50%)\n            files_to_delete = len(archive_files) // 2\n            for filepath, _ in archive_files[:files_to_delete]:\n                os.remove(filepath)\n                self.logger.info(f\"Supprim√© archive: {os.path.basename(filepath)}\")\n            \n            # Compactage m√©moire\n            if len(self.active_hands) > self.settings.max_memory_hands // 2:\n                target_size = self.settings.max_memory_hands // 2\n                hands_to_remove = len(self.active_hands) - target_size\n                for _ in range(hands_to_remove):\n                    if self.active_hands:\n                        self.active_hands.popleft()\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur nettoyage d'urgence: {e}\")\n    \n    def _cleanup_loop(self):\n        \"\"\"Boucle de nettoyage automatique\"\"\"\n        while self.cleanup_running:\n            try:\n                # Nettoyage p√©riodique\n                self._periodic_cleanup()\n                self._update_storage_stats()\n                \n                # Attente jusqu'au prochain nettoyage\n                time.sleep(self.settings.cleanup_interval)\n                \n            except Exception as e:\n                self.logger.error(f\"Erreur boucle nettoyage: {e}\")\n                time.sleep(60)  # Attente en cas d'erreur\n    \n    def _periodic_cleanup(self):\n        \"\"\"Nettoyage p√©riodique automatique\"\"\"\n        try:\n            current_time = time.time()\n            \n            # Suppression archives expir√©es\n            retention_seconds = self.settings.retention_days * 24 * 3600\n            \n            for file in os.listdir(self.archive_directory):\n                if file.endswith('.gz'):\n                    filepath = os.path.join(self.archive_directory, file)\n                    if os.path.getmtime(filepath) < current_time - retention_seconds:\n                        os.remove(filepath)\n                        self.logger.debug(f\"Archive expir√©e supprim√©e: {file}\")\n            \n            # Archivage automatique si m√©moire pleine\n            if len(self.active_hands) >= self.settings.max_memory_hands * 0.9:\n                self._archive_oldest_hands()\n            \n            # V√©rification espace disque\n            if not self._check_storage_capacity():\n                self._emergency_cleanup()\n            \n            self.storage_stats['last_cleanup'] = current_time\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur nettoyage p√©riodique: {e}\")\n    \n    def _update_storage_stats(self):\n        \"\"\"Met √† jour les statistiques de stockage\"\"\"\n        try:\n            import sys\n            \n            # M√©moire utilis√©e\n            memory_mb = sys.getsizeof(self.active_hands) / (1024 * 1024)\n            self.storage_stats['memory_usage_mb'] = memory_mb\n            self.storage_stats['hands_in_memory'] = len(self.active_hands)\n            self.storage_stats['hands_archived'] = self.archived_hands_count\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur stats: {e}\")\n    \n    def export_database(self, export_path: str, include_archives: bool = False) -> bool:\n        \"\"\"Exporte la base de donn√©es compl√®te\"\"\"\n        try:\n            export_data = {\n                'timestamp': time.time(),\n                'version': '1.0',\n                'active_hands': len(self.active_hands),\n                'archived_hands': self.archived_hands_count,\n                'cfr_snapshots': len(self.cfr_snapshots),\n                'storage_stats': self.storage_stats\n            }\n            \n            # Export mains actives\n            if self.active_hands:\n                hands_data = []\n                for hand in list(self.active_hands):\n                    hands_data.append({\n                        'actions': hand.actions,\n                        'board': hand.board_cards,\n                        'hero_cards': hand.hero_cards,\n                        'pot': hand.pot_size,\n                        'positions': hand.positions\n                    })\n                export_data['hands'] = hands_data\n            \n            # Export snapshots CFR\n            if self.cfr_snapshots:\n                cfr_data = []\n                for snapshot in list(self.cfr_snapshots):\n                    cfr_data.append({\n                        'timestamp': snapshot['timestamp'],\n                        'metadata': snapshot['metadata'],\n                        'regret_compressed': len(snapshot.get('regret_sum', b'')),\n                        'strategy_compressed': len(snapshot.get('strategy_sum', b''))\n                    })\n                export_data['cfr_snapshots_info'] = cfr_data\n            \n            # Sauvegarde compress√©e\n            with gzip.open(export_path, 'wt', encoding='utf-8') as f:\n                json.dump(export_data, f, indent=2)\n            \n            self.logger.info(f\"Base de donn√©es export√©e: {export_path}\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur export: {e}\")\n            return False\n    \n    def get_storage_statistics(self) -> Dict[str, Any]:\n        \"\"\"Retourne les statistiques d√©taill√©es de stockage\"\"\"\n        self._update_storage_stats()\n        \n        stats = self.storage_stats.copy()\n        stats.update({\n            'active_hands_count': len(self.active_hands),\n            'cfr_snapshots_count': len(self.cfr_snapshots),\n            'disk_usage_percent': (stats['disk_usage_mb'] / self.settings.max_disk_size_mb) * 100,\n            'memory_limit_mb': self.settings.max_memory_hands * 0.001,  # Estimation\n            'compression_enabled': True,\n            'cleanup_active': self.cleanup_running\n        })\n        \n        return stats\n    \n    def configure_storage(self, new_settings: Dict[str, Any]):\n        \"\"\"Configure les param√®tres de stockage\"\"\"\n        try:\n            for key, value in new_settings.items():\n                if hasattr(self.settings, key):\n                    setattr(self.settings, key, value)\n                    self.logger.info(f\"Param√®tre {key} mis √† jour: {value}\")\n            \n            # Red√©marrage nettoyage si n√©cessaire\n            if 'cleanup_interval' in new_settings and self.cleanup_running:\n                self.stop_cleanup_service()\n                self.start_cleanup_service()\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur configuration: {e}\")","size_bytes":16217},"src/algorithms/hand_generator.py":{"content":"\"\"\"\nG√©n√©rateur de mains synth√©tiques pour entra√Ænement CFR massif\nCr√©ation de millions de situations poker r√©alistes\n\"\"\"\n\nimport random\nimport itertools\nimport numpy as np\nfrom typing import Dict, List, Tuple, Any, Optional\nfrom dataclasses import dataclass\nimport time\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\nfrom .hand_parser import ParsedHand\nfrom ..utils.logger import get_logger\n\n@dataclass\nclass GenerationSettings:\n    \"\"\"Configuration pour la g√©n√©ration de mains\"\"\"\n    hands_per_batch: int = 10000\n    max_hands: int = 1000000\n    preflop_ratio: float = 0.4\n    flop_ratio: float = 0.3\n    turn_ratio: float = 0.2\n    river_ratio: float = 0.1\n    aggressive_ratio: float = 0.3  # Proportion d'actions agressives\n    stack_sizes: Optional[List[float]] = None\n    blind_levels: Optional[List[Tuple[float, float]]] = None\n    \n    def __post_init__(self):\n        if self.stack_sizes is None:\n            self.stack_sizes = [1000, 2000, 5000, 10000, 20000]\n        if self.blind_levels is None:\n            self.blind_levels = [(25, 50), (50, 100), (100, 200), (200, 400), (400, 800)]\n\nclass HandGenerator:\n    \"\"\"G√©n√©rateur de mains poker synth√©tiques\"\"\"\n    \n    def __init__(self, settings: Optional[GenerationSettings] = None):\n        self.logger = get_logger(__name__)\n        self.settings = settings or GenerationSettings()\n        \n        # Deck de cartes\n        self.suits = ['h', 'd', 'c', 's']\n        self.ranks = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']\n        self.deck = [rank + suit for rank in self.ranks for suit in self.suits]\n        \n        # Statistiques de g√©n√©ration\n        self.hands_generated = 0\n        self.generation_time = 0.0\n        \n        # Poids pour r√©alisme des mains\n        self._init_hand_weights()\n    \n    def _init_hand_weights(self):\n        \"\"\"Initialise les poids de probabilit√© pour des mains r√©alistes\"\"\"\n        \n        # Poids des mains de d√©part (bas√© sur statistiques r√©elles)\n        self.preflop_weights = {}\n        \n        # Pairs\n        pairs = [f\"{rank}{rank}\" for rank in self.ranks]\n        for pair in pairs:\n            if pair in ['AA', 'KK', 'QQ']:\n                self.preflop_weights[pair] = 3.0  # Mains premium\n            elif pair in ['JJ', 'TT', '99']:\n                self.preflop_weights[pair] = 2.5\n            else:\n                self.preflop_weights[pair] = 2.0\n        \n        # Suited connectors et suited aces\n        for i, rank1 in enumerate(self.ranks):\n            for j, rank2 in enumerate(self.ranks):\n                if i != j:\n                    hand = f\"{rank1}{rank2}\"\n                    if abs(i - j) == 1:  # Connectors\n                        self.preflop_weights[hand + \"s\"] = 1.5\n                    elif rank1 == 'A' or rank2 == 'A':  # Ace-x suited\n                        self.preflop_weights[hand + \"s\"] = 1.8\n                    else:\n                        self.preflop_weights[hand + \"s\"] = 1.0\n        \n        # Offsuit hands\n        broadway = ['T', 'J', 'Q', 'K', 'A']\n        for rank1 in broadway:\n            for rank2 in broadway:\n                if rank1 != rank2:\n                    hand = f\"{rank1}{rank2}\"\n                    if hand + \"o\" not in self.preflop_weights:\n                        self.preflop_weights[hand + \"o\"] = 1.2\n    \n    def generate_batch(self, batch_size: Optional[int] = None) -> List[ParsedHand]:\n        \"\"\"G√©n√®re un batch de mains synth√©tiques\"\"\"\n        if batch_size is None:\n            batch_size = self.settings.hands_per_batch\n        \n        start_time = time.time()\n        hands = []\n        \n        for i in range(batch_size):\n            # D√©termine la street selon les ratios\n            street = self._select_street()\n            hand = self._generate_hand_for_street(street, str(self.hands_generated + i))\n            if hand:\n                hands.append(hand)\n        \n        self.hands_generated += len(hands)\n        self.generation_time += time.time() - start_time\n        \n        self.logger.info(f\"G√©n√©r√© {len(hands)} mains en {time.time() - start_time:.2f}s\")\n        return hands\n    \n    def generate_massive_dataset(self, target_hands: Optional[int] = None) -> List[ParsedHand]:\n        \"\"\"G√©n√®re un dataset massif de mains avec multiprocessing\"\"\"\n        if target_hands is None:\n            target_hands = self.settings.max_hands\n        \n        self.logger.info(f\"G√©n√©ration de {target_hands} mains synth√©tiques...\")\n        \n        hands = []\n        batch_size = self.settings.hands_per_batch\n        total_batches = (target_hands + batch_size - 1) // batch_size\n        \n        # G√©n√©ration parall√®le pour optimiser les performances\n        with ThreadPoolExecutor(max_workers=4) as executor:\n            future_to_batch = {}\n            \n            for batch_idx in range(total_batches):\n                remaining = target_hands - len(hands)\n                current_batch_size = min(batch_size, remaining)\n                \n                if current_batch_size <= 0:\n                    break\n                \n                future = executor.submit(self._generate_batch_worker, current_batch_size, batch_idx)\n                future_to_batch[future] = batch_idx\n            \n            # Collecte des r√©sultats\n            for future in as_completed(future_to_batch):\n                batch_hands = future.result()\n                hands.extend(batch_hands)\n                \n                if len(hands) % 50000 == 0:\n                    self.logger.info(f\"Progression: {len(hands)}/{target_hands} mains g√©n√©r√©es\")\n        \n        self.logger.info(f\"G√©n√©ration termin√©e: {len(hands)} mains cr√©√©es\")\n        return hands[:target_hands]\n    \n    def _generate_batch_worker(self, batch_size: int, batch_idx: int) -> List[ParsedHand]:\n        \"\"\"Worker pour g√©n√©ration parall√®le\"\"\"\n        hands = []\n        \n        for i in range(batch_size):\n            street = self._select_street()\n            hand_id = f\"{batch_idx * 10000 + i}\"\n            hand = self._generate_hand_for_street(street, hand_id)\n            if hand:\n                hands.append(hand)\n        \n        return hands\n    \n    def _select_street(self) -> int:\n        \"\"\"S√©lectionne une street selon les ratios configur√©s\"\"\"\n        rand = random.random()\n        \n        if rand < self.settings.preflop_ratio:\n            return 0  # preflop\n        elif rand < self.settings.preflop_ratio + self.settings.flop_ratio:\n            return 1  # flop\n        elif rand < self.settings.preflop_ratio + self.settings.flop_ratio + self.settings.turn_ratio:\n            return 2  # turn\n        else:\n            return 3  # river\n    \n    def _generate_hand_for_street(self, street: int, hand_id: str) -> Optional[ParsedHand]:\n        \"\"\"G√©n√®re une main pour une street donn√©e\"\"\"\n        try:\n            # S√©lection deck et cartes\n            deck = self.deck.copy()\n            random.shuffle(deck)\n            \n            # Cartes h√©ros\n            hero_cards = (deck.pop(), deck.pop())\n            \n            # Board selon street\n            board_cards = []\n            if street >= 1:  # flop\n                board_cards.extend([deck.pop(), deck.pop(), deck.pop()])\n            if street >= 2:  # turn\n                board_cards.append(deck.pop())\n            if street >= 3:  # river\n                board_cards.append(deck.pop())\n            \n            # Configuration de jeu\n            blinds = random.choice(self.settings.blind_levels)\n            stack_size = random.choice(self.settings.stack_sizes)\n            \n            # G√©n√©ration d'actions r√©alistes\n            actions = self._generate_realistic_actions(street, hero_cards, board_cards, blinds)\n            \n            # Calcul du pot et r√©sultat\n            pot_size = self._calculate_pot_from_actions(actions, blinds)\n            result = self._calculate_realistic_result(hero_cards, board_cards, actions, pot_size)\n            \n            return ParsedHand(\n                hand_id=hand_id,\n                hero_cards=hero_cards,\n                board_cards=board_cards,\n                actions=actions,\n                pot_size=pot_size,\n                hero_stack=stack_size,\n                villain_stack=stack_size,\n                position=random.randint(0, 8),  # 9-max positions (0-8)\n                blinds=blinds,\n                result=result,\n                street=street\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur g√©n√©ration main: {e}\")\n            return None\n    \n    def _generate_realistic_actions(self, street: int, hero_cards: Tuple[str, str], \n                                   board_cards: List[str], blinds: Tuple[float, float]) -> List[str]:\n        \"\"\"G√©n√®re une s√©quence d'actions r√©aliste\"\"\"\n        actions = []\n        \n        # Force de la main h√©ros\n        hand_strength = self._evaluate_hand_strength(hero_cards, board_cards)\n        \n        # Nombre d'actions par street (r√©aliste)\n        max_actions_per_street = {0: 4, 1: 3, 2: 3, 3: 2}  # preflop peut √™tre plus long\n        \n        for current_street in range(street + 1):\n            street_actions = self._generate_street_actions(\n                current_street, hand_strength, blinds, len(board_cards) >= (current_street * 3)\n            )\n            actions.extend(street_actions)\n        \n        return actions\n    \n    def _generate_street_actions(self, street: int, hand_strength: float, \n                                blinds: Tuple[float, float], has_board: bool) -> List[str]:\n        \"\"\"G√©n√®re les actions pour une street\"\"\"\n        actions = []\n        num_actions = random.randint(1, 4 if street == 0 else 3)\n        \n        # Probabilit√©s d'actions selon force de main\n        if hand_strength > 0.8:  # Main tr√®s forte\n            action_probs = {'bet': 0.5, 'raise': 0.3, 'call': 0.15, 'check': 0.05, 'fold': 0.0}\n        elif hand_strength > 0.6:  # Main forte\n            action_probs = {'bet': 0.3, 'raise': 0.2, 'call': 0.3, 'check': 0.15, 'fold': 0.05}\n        elif hand_strength > 0.4:  # Main moyenne\n            action_probs = {'bet': 0.15, 'raise': 0.1, 'call': 0.4, 'check': 0.25, 'fold': 0.1}\n        else:  # Main faible\n            action_probs = {'bet': 0.05, 'raise': 0.05, 'call': 0.2, 'check': 0.4, 'fold': 0.3}\n        \n        for i in range(num_actions):\n            # S√©lection action pond√©r√©e\n            action = np.random.choice(\n                list(action_probs.keys()),\n                p=list(action_probs.values())\n            )\n            \n            # Ajout de sizing pour bet/raise\n            if action in ['bet', 'raise']:\n                sizing = self._generate_bet_sizing(blinds[1])\n                actions.append(f\"{action}_{sizing}\")\n            else:\n                actions.append(action)\n            \n            # Arr√™t si fold\n            if action == 'fold':\n                break\n        \n        return actions\n    \n    def _generate_bet_sizing(self, big_blind: float) -> int:\n        \"\"\"G√©n√®re un sizing de bet r√©aliste\"\"\"\n        # Sizings standards en % du pot ou en BB\n        pot_sizings = [0.25, 0.33, 0.5, 0.66, 0.75, 1.0, 1.5]\n        bb_sizings = [2, 2.5, 3, 4, 5]\n        \n        if random.random() < 0.7:  # 70% pot-sized bets\n            sizing = int(random.choice(pot_sizings) * 100)  # Convert to percentage\n        else:  # 30% BB-sized bets\n            sizing = int(random.choice(bb_sizings) * big_blind)\n        \n        return max(sizing, int(big_blind))  # Minimum 1 BB\n    \n    def _evaluate_hand_strength(self, hero_cards: Tuple[str, str], board_cards: List[str]) -> float:\n        \"\"\"√âvalue la force de la main (0.0 √† 1.0)\"\"\"\n        # Simplification : √©valuation bas√©e sur les cartes et board\n        \n        # Parse cartes\n        ranks = [card[0] for card in hero_cards]\n        suits = [card[1] for card in hero_cards]\n        \n        strength = 0.0\n        \n        # Pocket pairs\n        if ranks[0] == ranks[1]:\n            pair_strength = {'A': 0.9, 'K': 0.85, 'Q': 0.8, 'J': 0.75, 'T': 0.7}\n            strength = pair_strength.get(ranks[0], 0.6)\n        \n        # High cards\n        elif 'A' in ranks:\n            strength = 0.7 if 'K' in ranks or 'Q' in ranks else 0.6\n        elif 'K' in ranks and 'Q' in ranks:\n            strength = 0.65\n        \n        # Suited bonus\n        if suits[0] == suits[1]:\n            strength += 0.1\n        \n        # Connecteur bonus\n        rank_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}\n        if abs(rank_values.get(ranks[0], 0) - rank_values.get(ranks[1], 0)) == 1:\n            strength += 0.05\n        \n        # Ajustement selon board (simplifi√©)\n        if board_cards:\n            # Check for pairs, flushes, straights etc. (implementation simplifi√©e)\n            hero_ranks = set(ranks)\n            board_ranks = set([card[0] for card in board_cards])\n            \n            # Paire avec le board\n            if hero_ranks & board_ranks:\n                strength += 0.2\n            \n            # Two pair potentiel\n            if len(hero_ranks & board_ranks) == 2:\n                strength += 0.3\n        \n        return min(1.0, max(0.0, strength))\n    \n    def _calculate_pot_from_actions(self, actions: List[str], blinds: Tuple[float, float]) -> float:\n        \"\"\"Calcule la taille du pot selon les actions\"\"\"\n        pot = blinds[0] + blinds[1]  # Start with blinds\n        \n        for action in actions:\n            if action.startswith('bet_'):\n                bet_size = int(action.split('_')[1])\n                pot += bet_size\n            elif action.startswith('raise_'):\n                raise_size = int(action.split('_')[1])\n                pot += raise_size\n            elif action == 'call':\n                pot += blinds[1]  # Assume BB call\n        \n        return pot\n    \n    def _calculate_realistic_result(self, hero_cards: Tuple[str, str], board_cards: List[str], \n                                   actions: List[str], pot_size: float) -> float:\n        \"\"\"Calcule un r√©sultat r√©aliste selon la force de main\"\"\"\n        \n        # Si fold, perte des blinds/investissement\n        if 'fold' in actions:\n            return -pot_size * 0.1  # Perte partielle\n        \n        # Force de main\n        hand_strength = self._evaluate_hand_strength(hero_cards, board_cards)\n        \n        # Win probability selon force\n        win_prob = hand_strength\n        \n        # R√©sultat selon probabilit√©\n        if random.random() < win_prob:\n            return pot_size * 0.5  # Gain\n        else:\n            return -pot_size * 0.3  # Perte\n    \n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"Retourne les statistiques de g√©n√©ration\"\"\"\n        return {\n            'hands_generated': self.hands_generated,\n            'generation_time': self.generation_time,\n            'hands_per_second': self.hands_generated / max(self.generation_time, 0.001),\n            'settings': {\n                'max_hands': self.settings.max_hands,\n                'batch_size': self.settings.hands_per_batch\n            }\n        }","size_bytes":15205},"src/algorithms/hand_parser.py":{"content":"\"\"\"\nParseur d'historiques de mains poker pour entra√Ænement CFR\nSupporte les formats ACPC, PokerStars et format compact\n\"\"\"\n\nimport re\nimport time\nfrom typing import Dict, List, Tuple, Any, Optional\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nfrom ..utils.logger import get_logger\n\nclass HandFormat(Enum):\n    ACPC = \"acpc\"\n    POKERSTARS = \"pokerstars\"\n    COMPACT = \"compact\"\n    UNKNOWN = \"unknown\"\n\n@dataclass\nclass ParsedHand:\n    \"\"\"Main de poker pars√©e et normalis√©e\"\"\"\n    hand_id: str\n    hero_cards: Tuple[str, str]\n    board_cards: List[str]\n    actions: List[str]  # S√©quence d'actions: f, c, r200, etc.\n    pot_size: float\n    hero_stack: float\n    villain_stack: float\n    position: int  # 9-max: 0=UTG, 1=UTG+1, 2=MP1, 3=MP2, 4=MP3, 5=CO, 6=BTN, 7=SB, 8=BB\n    blinds: Tuple[float, float]  # (small_blind, big_blind)\n    result: float  # Gain/perte pour le h√©ros\n    street: int  # 0=preflop, 1=flop, 2=turn, 3=river\n    \nclass HandParser:\n    \"\"\"Parseur multi-format pour historiques de mains\"\"\"\n    \n    def __init__(self):\n        self.logger = get_logger(__name__)\n        self.hands_parsed = 0\n        self.errors = 0\n        \n        # Expressions r√©guli√®res pour les diff√©rents formats\n        self._init_regex_patterns()\n    \n    def _init_regex_patterns(self):\n        \"\"\"Initialise les patterns regex pour le parsing\"\"\"\n        \n        # Format ACPC\n        self.acpc_pattern = re.compile(\n            r'STATE:(\\d+):(\\d+)\\|(\\d+):(\\d+)\\|(\\d+):([^:]+):([^:]*):([^:]+):(.+)'\n        )\n        \n        # Format PokerStars\n        self.pokerstars_hand_pattern = re.compile(\n            r'PokerStars Hand #(\\d+).*\\$(\\d+)/\\$(\\d+)'\n        )\n        self.pokerstars_cards_pattern = re.compile(\n            r'Dealt to \\w+ \\[([2-9TJQKA][shdc]) ([2-9TJQKA][shdc])\\]'\n        )\n        self.pokerstars_board_pattern = re.compile(\n            r'\\[([2-9TJQKA][shdc](?:\\s+[2-9TJQKA][shdc])*)\\]'\n        )\n        \n        # Format compact\n        self.compact_pattern = re.compile(\n            r'(\\d+):([^:]+):([^:]*):([^:]+):([^:]*):([^:]+)'\n        )\n    \n    def detect_format(self, line: str) -> HandFormat:\n        \"\"\"D√©tecte le format d'une ligne de main\"\"\"\n        if line.startswith('STATE:'):\n            return HandFormat.ACPC\n        elif 'PokerStars Hand' in line:\n            return HandFormat.POKERSTARS\n        elif ':' in line and ',' in line and '|' in line:\n            return HandFormat.COMPACT\n        else:\n            return HandFormat.UNKNOWN\n    \n    def parse_file(self, file_path: str) -> List[ParsedHand]:\n        \"\"\"Parse un fichier complet de mains\"\"\"\n        hands = []\n        \n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n            \n            # D√©tection du format majoritaire\n            lines = content.split('\\n')\n            format_counts = {fmt: 0 for fmt in HandFormat}\n            \n            for line in lines[:100]:  # √âchantillon\n                if line.strip():\n                    fmt = self.detect_format(line)\n                    format_counts[fmt] += 1\n            \n            main_format = max(format_counts.items(), key=lambda x: x[1])[0]\n            \n            if main_format == HandFormat.ACPC:\n                hands = self._parse_acpc_file(content)\n            elif main_format == HandFormat.POKERSTARS:\n                hands = self._parse_pokerstars_file(content)\n            elif main_format == HandFormat.COMPACT:\n                hands = self._parse_compact_file(content)\n            \n            self.logger.info(f\"Pars√© {len(hands)} mains depuis {file_path}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur parsing fichier {file_path}: {e}\")\n            \n        return hands\n    \n    def _parse_acpc_file(self, content: str) -> List[ParsedHand]:\n        \"\"\"Parse format ACPC\"\"\"\n        hands = []\n        \n        for line in content.split('\\n'):\n            if line.startswith('STATE:'):\n                hand = self._parse_acpc_line(line)\n                if hand:\n                    hands.append(hand)\n        \n        return hands\n    \n    def _parse_acpc_line(self, line: str) -> Optional[ParsedHand]:\n        \"\"\"Parse une ligne ACPC\"\"\"\n        try:\n            match = self.acpc_pattern.match(line)\n            if not match:\n                return None\n            \n            hand_id, hero_stack, villain_stack, sb, bb, actions, cards, result, players = match.groups()\n            \n            # Parse cartes\n            if '|' in cards:\n                hero_cards_str, board_str = cards.split('|', 1)\n                hero_cards = self._parse_card_pair(hero_cards_str)\n                board_cards = self._parse_board_cards(board_str)\n            else:\n                hero_cards = self._parse_card_pair(cards)\n                board_cards = []\n            \n            # Parse actions\n            action_list = self._parse_acpc_actions(actions)\n            \n            # Parse r√©sultat\n            result_parts = result.split(':')\n            hero_result = 0.0\n            if len(result_parts) >= 2:\n                try:\n                    hero_result = float(result_parts[0])\n                except:\n                    pass\n            \n            # D√©terminer street\n            street = self._determine_street(board_cards)\n            \n            return ParsedHand(\n                hand_id=hand_id,\n                hero_cards=hero_cards,\n                board_cards=board_cards,\n                actions=action_list,\n                pot_size=float(sb) + float(bb),\n                hero_stack=float(hero_stack),\n                villain_stack=float(villain_stack),\n                position=0,  # √Ä d√©terminer selon le format\n                blinds=(float(sb), float(bb)),\n                result=hero_result,\n                street=street\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur parsing ligne ACPC: {e}\")\n            return None\n    \n    def _parse_pokerstars_file(self, content: str) -> List[ParsedHand]:\n        \"\"\"Parse format PokerStars\"\"\"\n        hands = []\n        hand_blocks = content.split('PokerStars Hand')\n        \n        for i, block in enumerate(hand_blocks[1:], 1):  # Skip premier block vide\n            hand = self._parse_pokerstars_block(f\"PokerStars Hand{block}\", str(i))\n            if hand:\n                hands.append(hand)\n        \n        return hands\n    \n    def _parse_pokerstars_block(self, block: str, hand_id: str) -> Optional[ParsedHand]:\n        \"\"\"Parse un block PokerStars complet\"\"\"\n        try:\n            lines = block.split('\\n')\n            \n            # Parse blinds depuis header\n            header_match = self.pokerstars_hand_pattern.search(block)\n            if not header_match:\n                return None\n            \n            actual_hand_id, sb, bb = header_match.groups()\n            \n            # Parse cartes h√©ros\n            cards_match = self.pokerstars_cards_pattern.search(block)\n            if not cards_match:\n                return None\n            \n            hero_cards = (cards_match.group(1), cards_match.group(2))\n            \n            # Parse board\n            board_matches = self.pokerstars_board_pattern.findall(block)\n            board_cards = []\n            if board_matches:\n                # Prendre le board le plus complet (river)\n                last_board = board_matches[-1]\n                board_cards = last_board.split()\n            \n            # Parse actions (simplifi√©)\n            actions = self._parse_pokerstars_actions(block)\n            \n            # Parse r√©sultat (basique)\n            result = 0.0\n            if 'collected' in block:\n                # Extraction simplifi√©e du gain\n                if 'DeepStack collected' in block:\n                    result_match = re.search(r'collected \\$(\\d+)', block)\n                    if result_match:\n                        result = float(result_match.group(1))\n            \n            return ParsedHand(\n                hand_id=actual_hand_id,\n                hero_cards=hero_cards,\n                board_cards=board_cards,\n                actions=actions,\n                pot_size=float(sb) + float(bb),\n                hero_stack=20000.0,  # Stack standard DeepStack\n                villain_stack=20000.0,\n                position=0,\n                blinds=(float(sb), float(bb)),\n                result=result,\n                street=len(board_cards) // 3 if board_cards else 0\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur parsing block PokerStars: {e}\")\n            return None\n    \n    def _parse_compact_file(self, content: str) -> List[ParsedHand]:\n        \"\"\"Parse format compact\"\"\"\n        hands = []\n        \n        for line in content.split('\\n'):\n            if ':' in line and ',' in line:\n                hand = self._parse_compact_line(line)\n                if hand:\n                    hands.append(hand)\n        \n        return hands\n    \n    def _parse_compact_line(self, line: str) -> Optional[ParsedHand]:\n        \"\"\"Parse ligne format compact\"\"\"\n        try:\n            match = self.compact_pattern.match(line.strip())\n            if not match:\n                return None\n            \n            hand_id, players, actions, cards, board_info, result_info = match.groups()\n            \n            # Parse cartes\n            if ',' in cards:\n                cards_split = cards.split(',')\n                if len(cards_split) >= 2:\n                    hero_cards = self._parse_card_pair(cards_split[0])\n                else:\n                    return None\n            else:\n                return None\n            \n            # Parse board\n            board_cards = []\n            if '/' in board_info:\n                board_parts = board_info.split('/')\n                for part in board_parts[1:]:  # Skip premier qui est vide\n                    if part:\n                        board_cards.extend(self._parse_board_cards(part))\n            \n            # Parse actions\n            action_list = self._parse_compact_actions(actions)\n            \n            # Parse r√©sultat\n            result = 0.0\n            if ':' in result_info:\n                result_parts = result_info.split(':')\n                if len(result_parts) >= 2:\n                    try:\n                        result = float(result_parts[0])\n                    except:\n                        pass\n            \n            return ParsedHand(\n                hand_id=hand_id,\n                hero_cards=hero_cards,\n                board_cards=board_cards,\n                actions=action_list,\n                pot_size=100.0,  # Valeur par d√©faut\n                hero_stack=20000.0,\n                villain_stack=20000.0,\n                position=0,\n                blinds=(50.0, 100.0),\n                result=result,\n                street=self._determine_street(board_cards)\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"Erreur parsing ligne compact: {e}\")\n            return None\n    \n    def _parse_card_pair(self, cards_str: str) -> Tuple[str, str]:\n        \"\"\"Parse une paire de cartes\"\"\"\n        cards_str = cards_str.strip()\n        \n        if len(cards_str) == 4:  # Format \"AcKh\"\n            return (cards_str[:2], cards_str[2:])\n        elif ' ' in cards_str:  # Format \"Ac Kh\"\n            parts = cards_str.split()\n            if len(parts) >= 2:\n                return (parts[0], parts[1])\n        \n        return (\"\", \"\")\n    \n    def _parse_board_cards(self, board_str: str) -> List[str]:\n        \"\"\"Parse les cartes du board\"\"\"\n        if not board_str:\n            return []\n        \n        # Nettoie et split\n        board_str = board_str.strip()\n        cards = []\n        \n        # Diff√©rents formats possibles\n        if ' ' in board_str:\n            cards = board_str.split()\n        else:\n            # Format compact \"AcKhQs\"\n            i = 0\n            while i < len(board_str) - 1:\n                if i + 1 < len(board_str):\n                    card = board_str[i:i+2]\n                    if len(card) == 2:\n                        cards.append(card)\n                        i += 2\n                    else:\n                        i += 1\n                else:\n                    break\n        \n        return [card for card in cards if len(card) == 2]\n    \n    def _parse_acpc_actions(self, actions_str: str) -> List[str]:\n        \"\"\"Parse actions format ACPC\"\"\"\n        actions = []\n        \n        # Split par streets\n        streets = actions_str.split('/')\n        \n        for street in streets:\n            i = 0\n            while i < len(street):\n                if street[i] == 'f':\n                    actions.append('fold')\n                    i += 1\n                elif street[i] == 'c':\n                    actions.append('call')\n                    i += 1\n                elif street[i] == 'r':\n                    # Extract bet size\n                    j = i + 1\n                    while j < len(street) and street[j].isdigit():\n                        j += 1\n                    if j > i + 1:\n                        bet_size = street[i+1:j]\n                        actions.append(f'raise_{bet_size}')\n                        i = j\n                    else:\n                        actions.append('raise')\n                        i += 1\n                else:\n                    i += 1\n        \n        return actions\n    \n    def _parse_pokerstars_actions(self, block: str) -> List[str]:\n        \"\"\"Parse actions format PokerStars (simplifi√©)\"\"\"\n        actions = []\n        \n        # Recherche des patterns d'actions\n        if 'folds' in block:\n            actions.append('fold')\n        if 'calls' in block:\n            actions.append('call')\n        if 'raises' in block:\n            actions.append('raise')\n        if 'bets' in block:\n            actions.append('bet')\n        if 'checks' in block:\n            actions.append('check')\n        \n        return actions\n    \n    def _parse_compact_actions(self, actions_str: str) -> List[str]:\n        \"\"\"Parse actions format compact\"\"\"\n        actions = []\n        \n        # Format type \"cc/cc/cr200r19700f\"\n        streets = actions_str.split('/')\n        \n        for street in streets:\n            i = 0\n            while i < len(street):\n                if street[i] == 'f':\n                    actions.append('fold')\n                    i += 1\n                elif street[i] == 'c':\n                    actions.append('call')\n                    i += 1\n                elif street[i] == 'r':\n                    # Extract bet size\n                    j = i + 1\n                    while j < len(street) and street[j].isdigit():\n                        j += 1\n                    if j > i + 1:\n                        bet_size = street[i+1:j]\n                        actions.append(f'raise_{bet_size}')\n                        i = j\n                    else:\n                        actions.append('raise')\n                        i += 1\n                else:\n                    i += 1\n        \n        return actions\n    \n    def _determine_street(self, board_cards: List[str]) -> int:\n        \"\"\"D√©termine la street selon le nombre de cartes board\"\"\"\n        if not board_cards:\n            return 0  # preflop\n        elif len(board_cards) == 3:\n            return 1  # flop\n        elif len(board_cards) == 4:\n            return 2  # turn\n        elif len(board_cards) == 5:\n            return 3  # river\n        else:\n            return 0\n    \n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"Retourne les statistiques de parsing\"\"\"\n        return {\n            'hands_parsed': self.hands_parsed,\n            'errors': self.errors,\n            'success_rate': (self.hands_parsed / max(1, self.hands_parsed + self.errors)) * 100\n        }","size_bytes":15893},"test_cfr_integration.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTest d'int√©gration compl√®te du syst√®me CFR RTPA Studio\nValide l'entra√Ænement automatique et la qualit√© des recommandations\n\"\"\"\n\nimport time\nimport sys\nimport os\nsys.path.append('src')\n\nfrom src.algorithms.cfr_engine import CFREngine\nfrom src.algorithms.cfr_trainer import CFRTrainer\nfrom src.algorithms.hand_parser import HandParser\nfrom src.core.app_manager import GameState\nfrom src.utils.logger import get_logger\n\ndef test_cfr_integration():\n    \"\"\"Test complet d'int√©gration CFR\"\"\"\n    logger = get_logger(\"test_cfr_integration\")\n    \n    print(\"üéØ Test d'Int√©gration CFR RTPA Studio\")\n    print(\"=\" * 60)\n    \n    # 1. Initialisation CFR Engine\n    print(\"üìä 1. Initialisation CFR Engine...\")\n    cfr_engine = CFREngine()\n    initial_iterations = cfr_engine.iterations\n    print(f\"   ‚úì CFR initialis√© - It√©rations: {initial_iterations}\")\n    \n    # 2. Initialisation Trainer\n    print(\"üöÄ 2. Initialisation CFR Trainer...\")\n    cfr_engine.init_trainer()\n    time.sleep(3)  # Laisser temps √† l'initialisation\n    print(f\"   ‚úì Trainer initialis√©\")\n    \n    # 3. V√©rification chargement des mains\n    print(\"üìÅ 3. V√©rification chargement des mains...\")\n    if cfr_engine.cfr_trainer:\n        training_hands = len(cfr_engine.cfr_trainer.training_hands)\n        print(f\"   ‚úì Mains charg√©es: {training_hands}\")\n        \n        if training_hands == 0:\n            print(\"   ‚ö†Ô∏è  Aucune main charg√©e, g√©n√©ration de mains de test...\")\n            cfr_engine.cfr_trainer.generate_training_dataset(10000)\n            training_hands = len(cfr_engine.cfr_trainer.training_hands)\n            print(f\"   ‚úì Mains g√©n√©r√©es: {training_hands}\")\n    else:\n        print(\"   ‚ùå Trainer non initialis√©\")\n        return False\n    \n    # 4. Test de progression d'entra√Ænement\n    print(\"‚ö° 4. Test progression d'entra√Ænement...\")\n    progress_initial = cfr_engine.get_training_progress()\n    print(f\"   üìà Progression initiale:\")\n    print(f\"      - It√©rations: {progress_initial['iterations']}\")\n    print(f\"      - Qualit√©: {progress_initial['quality']:.2%}\")\n    print(f\"      - Confiance: {progress_initial['confidence']:.1f}%\")\n    print(f\"      - Info sets: {progress_initial['info_sets']}\")\n    \n    # 5. Test recommandation avec progression\n    print(\"üéØ 5. Test recommandations avec am√©lioration...\")\n    \n    # Cr√©ation d'un √©tat de jeu test\n    game_state = GameState(\n        table_type=\"cashgame\",\n        players_count=2,\n        hero_position=1,\n        hero_cards=(\"As\", \"Kh\"),\n        board_cards=(\"Ah\", \"Kd\", \"7c\"),\n        pot_size=150.0,\n        hero_stack=2500.0,\n        current_bet=50.0,\n        action_to_hero=True\n    )\n    \n    # Test initial\n    rec_initial = cfr_engine.get_recommendation(game_state)\n    print(f\"   üÉè Recommandation initiale:\")\n    print(f\"      - Action: {rec_initial.get('action_type', 'unknown')}\")\n    print(f\"      - Confiance: {rec_initial.get('confidence', 0):.1f}%\")\n    print(f\"      - Probabilit√© victoire: {rec_initial.get('win_probability', 0):.1%}\")\n    \n    # Attendre un peu d'entra√Ænement\n    print(\"   ‚è≥ Attente entra√Ænement (30 secondes)...\")\n    time.sleep(30)\n    \n    # Test apr√®s entra√Ænement\n    progress_after = cfr_engine.get_training_progress()\n    rec_after = cfr_engine.get_recommendation(game_state)\n    \n    print(f\"   üìà Progression apr√®s entra√Ænement:\")\n    print(f\"      - It√©rations: {progress_after['iterations']} (+{progress_after['iterations'] - progress_initial['iterations']})\")\n    print(f\"      - Qualit√©: {progress_after['quality']:.2%}\")\n    print(f\"      - Confiance: {progress_after['confidence']:.1f}%\")\n    print(f\"      - Info sets: {progress_after['info_sets']}\")\n    \n    print(f\"   üÉè Recommandation apr√®s entra√Ænement:\")\n    print(f\"      - Action: {rec_after.get('action_type', 'unknown')}\")\n    print(f\"      - Confiance: {rec_after.get('confidence', 0):.1f}%\")\n    print(f\"      - Probabilit√© victoire: {rec_after.get('win_probability', 0):.1%}\")\n    \n    # 6. Validation des am√©liorations\n    print(\"‚úÖ 6. Validation des am√©liorations...\")\n    \n    improvements = {\n        'iterations_increased': progress_after['iterations'] > progress_initial['iterations'],\n        'quality_acceptable': progress_after['quality'] > 0.1,  # Au moins 10%\n        'confidence_working': rec_after.get('confidence', 0) >= 0,\n        'training_active': progress_after['training_active'],\n        'info_sets_growing': progress_after['info_sets'] > 0\n    }\n    \n    for test_name, passed in improvements.items():\n        status = \"‚úì\" if passed else \"‚ùå\"\n        print(f\"   {status} {test_name.replace('_', ' ').title()}: {passed}\")\n    \n    # Calcul du score global\n    score = sum(improvements.values()) / len(improvements) * 100\n    print(f\"\\nüìä Score global: {score:.1f}%\")\n    \n    if score >= 80:\n        print(\"üéâ ‚úÖ SYST√àME CFR FONCTIONNEL ET VIABLE!\")\n        print(\"   Le syst√®me d'entra√Ænement automatique fonctionne correctement.\")\n        print(\"   Les recommandations s'am√©liorent avec l'entra√Ænement.\")\n        return True\n    elif score >= 60:\n        print(\"‚ö†Ô∏è  ‚úÖ SYST√àME CFR PARTIELLEMENT FONCTIONNEL\")\n        print(\"   Le syst√®me fonctionne mais n√©cessite plus d'entra√Ænement.\")\n        return True\n    else:\n        print(\"‚ùå SYST√àME CFR NON FONCTIONNEL\")\n        print(\"   Des probl√®mes emp√™chent le bon fonctionnement.\")\n        return False\n\nif __name__ == \"__main__\":\n    success = test_cfr_integration()\n    sys.exit(0 if success else 1)","size_bytes":5555},"src/algorithms/action_abstraction.py":{"content":"\"\"\"\nAbstraction des actions pour CFR\n\"\"\"\n\nfrom typing import List, Dict\nfrom ..utils.data_structures import PokerState\n\nclass ActionAbstraction:\n    \"\"\"Syst√®me d'abstraction pour l'espace d'actions\"\"\"\n    \n    def __init__(self):\n        self.action_buckets = {\n            'fold': 0,\n            'check': 1, \n            'call': 2,\n            'bet_small': 3,\n            'bet_medium': 4,\n            'bet_large': 5,\n            'bet_allin': 6\n        }\n    \n    def get_legal_actions(self, poker_state: PokerState) -> List[str]:\n        \"\"\"Retourne les actions l√©gales pour un √©tat donn√©\"\"\"\n        actions = []\n        \n        # Fold toujours possible (sauf si check gratuit)\n        if poker_state.current_bet > 0:\n            actions.append('fold')\n        \n        # Check/Call\n        if poker_state.current_bet == 0:\n            actions.append('check')\n        else:\n            actions.append('call')\n        \n        # Bet/Raise si stack suffisant\n        min_bet = max(poker_state.current_bet * 2, poker_state.pot_size * 0.25)\n        if poker_state.hero_stack > min_bet:\n            actions.extend(['bet_small', 'bet_medium', 'bet_large'])\n            \n        # All-in toujours possible\n        if poker_state.hero_stack > 0:\n            actions.append('bet_allin')\n            \n        return actions\n    \n    def get_action_bucket(self, action: str) -> int:\n        \"\"\"Retourne le bucket pour une action\"\"\"\n        return self.action_buckets.get(action, 0)","size_bytes":1476},"src/algorithms/card_abstraction.py":{"content":"\"\"\"\nAbstraction des cartes pour CFR\n\"\"\"\n\nfrom typing import List, Tuple\nimport hashlib\n\nclass CardAbstraction:\n    \"\"\"Syst√®me d'abstraction pour r√©duire l'espace des cartes\"\"\"\n    \n    def __init__(self, num_buckets: int = 64):\n        self.num_buckets = num_buckets\n        self.cache = {}\n    \n    def get_bucket(self, hero_cards: Tuple[str, str], board_cards: List[str], street: int) -> int:\n        \"\"\"Retourne le bucket d'abstraction pour une situation donn√©e\"\"\"\n        # Cache key\n        cache_key = f\"{hero_cards}_{board_cards}_{street}\"\n        if cache_key in self.cache:\n            return self.cache[cache_key]\n        \n        # Calcul simple bas√© sur hash pour la d√©mo\n        combined = f\"{hero_cards[0]}{hero_cards[1]}{''.join(board_cards)}{street}\"\n        hash_value = int(hashlib.md5(combined.encode()).hexdigest()[:8], 16)\n        bucket = hash_value % self.num_buckets\n        \n        self.cache[cache_key] = bucket\n        return bucket\n    \n    def get_bucket_preflop(self, hero_cards: Tuple[str, str]) -> int:\n        \"\"\"Retourne le bucket d'abstraction pour preflop\"\"\"\n        return self.get_bucket(hero_cards, [], 0)","size_bytes":1150},"src/utils/data_structures.py":{"content":"\"\"\"\nStructures de donn√©es pour RTPA Studio\n\"\"\"\n\nfrom dataclasses import dataclass\nfrom typing import List, Tuple, Optional\n\n@dataclass\nclass PokerState:\n    \"\"\"√âtat de poker pour CFR\"\"\"\n    street: int  # 0=preflop, 1=flop, 2=turn, 3=river\n    hero_cards: Tuple[str, str]\n    board_cards: List[str]\n    pot_size: float\n    hero_stack: float\n    position: int\n    num_players: int\n    current_bet: float\n    action_history: List[str]\n    table_type: str  # \"cashgame\" ou \"tournament\"\n\n@dataclass\nclass ActionSpace:\n    \"\"\"Espace d'actions possibles\"\"\"\n    fold: bool = True\n    check_call: bool = True\n    bet_sizes: Optional[List[float]] = None  # En pourcentage du pot\n    \n    def __post_init__(self):\n        if self.bet_sizes is None:\n            self.bet_sizes = [0.25, 0.33, 0.5, 0.66, 0.75, 1.0, 1.5, 2.0]  # Pourcentages du pot","size_bytes":837},"config.yaml":{"content":"# Configuration RTPA Studio\n# Fichier de configuration principal du syst√®me\n\napp:\n  name: \"RTPA Studio\"\n  version: \"2.5.0\"\n  author: \"MDS_AnGe - AnG(e)‚Ñ¢\"\n  log_level: \"INFO\"\n\ncfr:\n  target_iterations: 100000\n  convergence_threshold: 0.01\n  exploration_rate: 0.1\n  discount_factor: 0.95\n  cfr_plus_enabled: true\n  \ntraining:\n  batch_size: 5000\n  max_hands: 500000\n  auto_training: true\n  quality_threshold: 0.85\n\nocr:\n  tesseract_path: \"/usr/bin/tesseract\"\n  capture_interval: 1.0\n  confidence_threshold: 80\n\ndatabase:\n  type: \"memory\"\n  backup_enabled: true\n  backup_interval: 300\n\nperformance:\n  cpu_limit: 80.0\n  memory_limit: 75.0\n  threads: 4\n\ngpu:\n  enabled: false\n  memory_limit: 80.0\n  mixed_precision: true\n  batch_size: 1000\n\ngui:\n  theme: \"light\"\n  accent_color: \"blue\"\n  font_family: \"Arial\"\n  opacity: 1.0\n  window_size: \"1100x900\"\n\nplatforms:\n  pokerstars: true\n  winamax: true\n  pmu: true\n  partypoker: true","size_bytes":924},"src/algorithms/gpu_accelerator.py":{"content":"\"\"\"\nAcc√©l√©rateur GPU/CPU pour optimisations CFR et Nash\nModule d√©di√© pour l'acc√©l√©ration des calculs poker\n\"\"\"\n\nimport logging\nimport numpy as np\nimport time\nfrom typing import Dict, List, Tuple, Optional, Any\nfrom dataclasses import dataclass\nimport multiprocessing as mp\n\n# GPU/CPU Acceleration imports\ntry:\n    import torch\n    import torch.nn.functional as F\n    TORCH_AVAILABLE = True\nexcept ImportError:\n    TORCH_AVAILABLE = False\n    torch = None\n\nfrom numba import jit, prange\n\n@dataclass\nclass AccelerationConfig:\n    \"\"\"Configuration pour l'acc√©l√©ration GPU/CPU\"\"\"\n    gpu_enabled: bool = False\n    gpu_memory_limit: float = 0.8\n    cpu_threads: int = mp.cpu_count()\n    use_mixed_precision: bool = True\n    batch_size: int = 2000\n\nclass GPUAccelerator:\n    \"\"\"Gestionnaire d'acc√©l√©ration GPU/CPU pour calculs CFR\"\"\"\n    \n    def __init__(self, config: AccelerationConfig = None):\n        self.logger = logging.getLogger(__name__)\n        self.config = config or AccelerationConfig()\n        \n        # Configuration du device\n        self.device = self._setup_device()\n        self.memory_pool = {}\n        self.tensor_cache = {}\n        \n        # Statistiques de performance\n        self.performance_stats = {\n            \"total_calculations\": 0,\n            \"gpu_calculations\": 0,\n            \"cpu_calculations\": 0,\n            \"cache_hits\": 0,\n            \"total_time\": 0.0\n        }\n        \n        self.logger.info(f\"GPUAccelerator initialis√©: {self.device}\")\n    \n    def _setup_device(self):\n        \"\"\"Configure le device optimal\"\"\"\n        if not TORCH_AVAILABLE:\n            return \"cpu\"\n        \n        if TORCH_AVAILABLE and self.config.gpu_enabled and torch.cuda.is_available():\n            device = torch.device(\"cuda:0\")\n            # Configuration m√©moire GPU\n            torch.cuda.set_per_process_memory_fraction(self.config.gpu_memory_limit)\n            # Configuration threads CPU\n            torch.set_num_threads(self.config.cpu_threads)\n            torch.set_num_interop_threads(max(1, self.config.cpu_threads // 2))\n            \n            self.logger.info(f\"GPU activ√©: {torch.cuda.get_device_name(0)}\")\n            return device\n        else:\n            device = torch.device(\"cpu\") if TORCH_AVAILABLE else \"cpu\"\n            if TORCH_AVAILABLE:\n                torch.set_num_threads(self.config.cpu_threads)\n            self.logger.info(f\"CPU threads: {self.config.cpu_threads}\")\n            return device\n    \n    def update_config(self, gpu_enabled: bool, memory_limit: float):\n        \"\"\"Met √† jour la configuration GPU\"\"\"\n        self.config.gpu_enabled = gpu_enabled\n        self.config.gpu_memory_limit = memory_limit\n        \n        # Reconfigurer le device\n        old_device = self.device\n        self.device = self._setup_device()\n        \n        if old_device != self.device:\n            self.clear_cache()\n            self.logger.info(f\"Device chang√©: {old_device} ‚Üí {self.device}\")\n    \n    def clear_cache(self):\n        \"\"\"Vide tous les caches\"\"\"\n        self.tensor_cache.clear()\n        self.memory_pool.clear()\n        \n        if TORCH_AVAILABLE and torch.cuda.is_available():\n            torch.cuda.empty_cache()\n    \n    def get_memory_info(self):\n        \"\"\"Retourne les informations m√©moire\"\"\"\n        if TORCH_AVAILABLE and hasattr(self.device, 'type') and self.device.type == \"cuda\" and torch.cuda.is_available():\n            allocated = torch.cuda.memory_allocated() / 1024**2\n            cached = torch.cuda.memory_reserved() / 1024**2\n            total = torch.cuda.get_device_properties(0).total_memory / 1024**2\n            \n            return {\n                \"type\": \"gpu\",\n                \"allocated\": allocated,\n                \"cached\": cached,\n                \"total\": total,\n                \"percent\": (allocated / total) * 100,\n                \"available\": total - allocated\n            }\n        else:\n            import psutil\n            memory = psutil.virtual_memory()\n            return {\n                \"type\": \"cpu\",\n                \"allocated\": (memory.total - memory.available) / 1024**2,\n                \"total\": memory.total / 1024**2,\n                \"percent\": memory.percent,\n                \"available\": memory.available / 1024**2\n            }\n    \n    def compute_equity_fast(self, hand_strengths, opponent_ranges):\n        \"\"\"Calcul rapide d'equity avec Numba\"\"\"\n        return _compute_equity_numba(hand_strengths, opponent_ranges)\n    \n    def compute_regrets_batch(self, utilities_batch, strategies_batch):\n        \"\"\"Calcul optimis√© des regrets par lots\"\"\"\n        start_time = time.time()\n        \n        if not TORCH_AVAILABLE or utilities_batch.shape[0] < 100:\n            # Utiliser NumPy pour petits calculs\n            result = self._compute_regrets_numpy(utilities_batch, strategies_batch)\n            self.performance_stats[\"cpu_calculations\"] += 1\n        else:\n            # Utiliser PyTorch pour gros calculs\n            result = self._compute_regrets_torch(utilities_batch, strategies_batch)\n            self.performance_stats[\"gpu_calculations\"] += 1\n        \n        calc_time = time.time() - start_time\n        self.performance_stats[\"total_time\"] += calc_time\n        self.performance_stats[\"total_calculations\"] += 1\n        \n        return result\n    \n    def _compute_regrets_numpy(self, utilities, strategies):\n        \"\"\"Calcul regrets avec NumPy\"\"\"\n        batch_size, num_actions = utilities.shape\n        regrets = np.zeros_like(utilities)\n        \n        for i in range(batch_size):\n            ev = np.sum(utilities[i] * strategies[i])\n            regrets[i] = utilities[i] - ev\n        \n        return regrets\n    \n    def _compute_regrets_torch(self, utilities, strategies):\n        \"\"\"Calcul regrets avec PyTorch\"\"\"\n        if not TORCH_AVAILABLE:\n            return self._compute_regrets_numpy(utilities, strategies)\n        \n        # Convertir en tenseurs\n        utilities_tensor = torch.tensor(utilities, device=self.device, dtype=torch.float32)\n        strategies_tensor = torch.tensor(strategies, device=self.device, dtype=torch.float32)\n        \n        # Calcul vectoris√©\n        ev = torch.sum(utilities_tensor * strategies_tensor, dim=1, keepdim=True)\n        regrets = utilities_tensor - ev\n        \n        return regrets.cpu().numpy()\n    \n    def compute_nash_equilibrium(self, payoff_matrix, max_iterations=1000):\n        \"\"\"Calcul √©quilibre de Nash optimis√©\"\"\"\n        if not TORCH_AVAILABLE:\n            return self._compute_nash_numpy(payoff_matrix, max_iterations)\n        \n        return self._compute_nash_torch(payoff_matrix, max_iterations)\n    \n    def _compute_nash_torch(self, payoff_matrix, max_iterations):\n        \"\"\"Calcul Nash avec PyTorch\"\"\"\n        if not TORCH_AVAILABLE:\n            return self._compute_nash_numpy(payoff_matrix, max_iterations)\n        \n        n_actions = payoff_matrix.shape[0]\n        payoff_tensor = torch.tensor(payoff_matrix, device=self.device, dtype=torch.float32)\n        \n        # Initialiser strat√©gie uniforme\n        strategy = torch.ones(n_actions, device=self.device, dtype=torch.float32) / n_actions\n        \n        for iteration in range(max_iterations):\n            # Calcul des utilit√©s esper√©es\n            expected_utilities = torch.matmul(payoff_tensor, strategy)\n            \n            # Mise √† jour de la strat√©gie (fictitious play)\n            best_response = torch.zeros_like(strategy)\n            best_action = torch.argmax(expected_utilities)\n            best_response[best_action] = 1.0\n            \n            # Moyenne pond√©r√©e\n            alpha = 1.0 / (iteration + 1)\n            strategy = (1 - alpha) * strategy + alpha * best_response\n            \n            # Test de convergence\n            if iteration % 100 == 0:\n                exploitability = torch.max(expected_utilities) - torch.sum(strategy * expected_utilities)\n                if exploitability < 1e-6:\n                    break\n        \n        return strategy.cpu().numpy()\n    \n    def _compute_nash_numpy(self, payoff_matrix, max_iterations):\n        \"\"\"Calcul Nash avec NumPy\"\"\"\n        n_actions = payoff_matrix.shape[0]\n        strategy = np.ones(n_actions) / n_actions\n        \n        for iteration in range(max_iterations):\n            expected_utilities = np.dot(payoff_matrix, strategy)\n            \n            best_response = np.zeros(n_actions)\n            best_action = np.argmax(expected_utilities)\n            best_response[best_action] = 1.0\n            \n            alpha = 1.0 / (iteration + 1)\n            strategy = (1 - alpha) * strategy + alpha * best_response\n            \n            if iteration % 100 == 0:\n                exploitability = np.max(expected_utilities) - np.sum(strategy * expected_utilities)\n                if exploitability < 1e-6:\n                    break\n        \n        return strategy\n    \n    def optimize_hand_generation(self, num_hands, hand_types):\n        \"\"\"G√©n√©ration optimis√©e de mains\"\"\"\n        if TORCH_AVAILABLE and num_hands > 1000:\n            return self._generate_hands_torch(num_hands, hand_types)\n        else:\n            return self._generate_hands_numpy(num_hands, hand_types)\n    \n    def _generate_hands_torch(self, num_hands, hand_types):\n        \"\"\"G√©n√©ration de mains avec PyTorch\"\"\"\n        if not TORCH_AVAILABLE:\n            return self._generate_hands_numpy(num_hands, hand_types)\n        \n        # G√©n√©ration vectoris√©e rapide\n        cards = torch.randint(0, 52, (num_hands, 2), device=self.device)\n        \n        # √âviter les doublons (m√™me carte 2 fois)\n        mask = cards[:, 0] != cards[:, 1]\n        valid_hands = cards[mask]\n        \n        # Reg√©n√©rer si n√©cessaire\n        while len(valid_hands) < num_hands:\n            additional = torch.randint(0, 52, (num_hands - len(valid_hands), 2), device=self.device)\n            mask = additional[:, 0] != additional[:, 1]\n            valid_hands = torch.cat([valid_hands, additional[mask]])\n        \n        return valid_hands[:num_hands].cpu().numpy()\n    \n    def _generate_hands_numpy(self, num_hands, hand_types):\n        \"\"\"G√©n√©ration de mains avec NumPy\"\"\"\n        hands = []\n        for _ in range(num_hands):\n            hand = np.random.choice(52, 2, replace=False)\n            hands.append(hand)\n        return np.array(hands)\n    \n    def get_performance_stats(self):\n        \"\"\"Retourne les statistiques de performance\"\"\"\n        total_calcs = self.performance_stats[\"total_calculations\"]\n        if total_calcs == 0:\n            return self.performance_stats\n        \n        stats = self.performance_stats.copy()\n        stats[\"gpu_percent\"] = (stats[\"gpu_calculations\"] / total_calcs) * 100\n        stats[\"cpu_percent\"] = (stats[\"cpu_calculations\"] / total_calcs) * 100\n        stats[\"avg_time\"] = stats[\"total_time\"] / total_calcs\n        stats[\"cache_hit_rate\"] = (stats[\"cache_hits\"] / total_calcs) * 100\n        \n        return stats\n    \n    def benchmark(self):\n        \"\"\"Benchmark des performances GPU vs CPU\"\"\"\n        results = {}\n        \n        # Test matrices de diff√©rentes tailles\n        sizes = [100, 1000, 5000, 10000]\n        \n        for size in sizes:\n            utilities = np.random.randn(size, 8).astype(np.float32)\n            strategies = np.random.rand(size, 8).astype(np.float32)\n            strategies = strategies / strategies.sum(axis=1, keepdims=True)\n            \n            # Test CPU\n            start = time.time()\n            self._compute_regrets_numpy(utilities, strategies)\n            cpu_time = time.time() - start\n            \n            # Test GPU si disponible\n            gpu_time = None\n            if TORCH_AVAILABLE and hasattr(self.device, 'type') and self.device.type == \"cuda\":\n                start = time.time()\n                self._compute_regrets_torch(utilities, strategies)\n                torch.cuda.synchronize()  # Attendre la fin des calculs GPU\n                gpu_time = time.time() - start\n            \n            results[size] = {\n                \"cpu_time\": cpu_time,\n                \"gpu_time\": gpu_time,\n                \"speedup\": cpu_time / gpu_time if gpu_time else None\n            }\n        \n        return results\n\n@jit(nopython=True)\ndef _compute_equity_numba(hand_strengths, opponent_ranges):\n    \"\"\"Fonction Numba compil√©e pour calcul d'equity\"\"\"\n    equity = 0.0\n    total_combos = 0.0\n    \n    for i in prange(len(opponent_ranges)):\n        if opponent_ranges[i] > 0:\n            wins = np.sum(hand_strengths > hand_strengths[i])\n            ties = np.sum(hand_strengths == hand_strengths[i])\n            equity += opponent_ranges[i] * (wins + 0.5 * ties)\n            total_combos += opponent_ranges[i]\n    \n    return equity / total_combos if total_combos > 0 else 0.0","size_bytes":12754},"src/utils/auto_install.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nAuto-installation des d√©pendances pour RTPA Studio\nInstallation automatique lors du premier lancement\n\"\"\"\n\nimport subprocess\nimport sys\nimport os\nimport importlib.util\nfrom pathlib import Path\n\ndef check_and_install_dependencies():\n    \"\"\"\n    V√©rifie et installe automatiquement toutes les d√©pendances manquantes\n    \"\"\"\n    print(\"üîç V√©rification des d√©pendances...\")\n    \n    # Liste des d√©pendances critiques avec leur nom d'import et nom pip\n    dependencies = {\n        'yaml': 'pyyaml',\n        'cv2': 'opencv-python',\n        'pytesseract': 'pytesseract',\n        'numpy': 'numpy',\n        'scipy': 'scipy',\n        'numba': 'numba',\n        'pygame': 'pygame',\n        'customtkinter': 'customtkinter',\n        'PIL': 'pillow',\n        'matplotlib': 'matplotlib',\n        'seaborn': 'seaborn',\n        'mss': 'mss',\n        'psutil': 'psutil',\n        'requests': 'requests'\n    }\n    \n    missing_packages = []\n    \n    # V√©rification de chaque d√©pendance\n    for import_name, pip_name in dependencies.items():\n        if not is_package_installed(import_name):\n            missing_packages.append(pip_name)\n            print(f\"‚ùå {import_name} manquant\")\n        else:\n            print(f\"‚úÖ {import_name} disponible\")\n    \n    # Installation des paquets manquants\n    if missing_packages:\n        print(f\"\\nüì¶ Installation de {len(missing_packages)} d√©pendances manquantes...\")\n        install_packages(missing_packages)\n        print(\"‚úÖ Toutes les d√©pendances ont √©t√© install√©es avec succ√®s!\")\n    else:\n        print(\"‚úÖ Toutes les d√©pendances sont d√©j√† install√©es!\")\n    \n    return True\n\ndef is_package_installed(package_name):\n    \"\"\"\n    V√©rifie si un package est install√© et importable\n    \"\"\"\n    try:\n        spec = importlib.util.find_spec(package_name)\n        return spec is not None\n    except (ImportError, AttributeError, ValueError, ModuleNotFoundError):\n        return False\n\ndef install_packages(packages):\n    \"\"\"\n    Installe une liste de packages via pip\n    \"\"\"\n    for package in packages:\n        try:\n            print(f\"üì¶ Installation de {package}...\")\n            result = subprocess.run([\n                sys.executable, \"-m\", \"pip\", \"install\", package, \"--quiet\"\n            ], capture_output=True, text=True, check=True)\n            print(f\"‚úÖ {package} install√© avec succ√®s\")\n        except subprocess.CalledProcessError as e:\n            print(f\"‚ùå Erreur lors de l'installation de {package}: {e}\")\n            print(f\"üìù Sortie d'erreur: {e.stderr}\")\n            \n            # Tentative d'installation avec --user si √©chec\n            try:\n                print(f\"üîÑ Tentative d'installation avec --user pour {package}...\")\n                subprocess.run([\n                    sys.executable, \"-m\", \"pip\", \"install\", package, \"--user\", \"--quiet\"\n                ], capture_output=True, text=True, check=True)\n                print(f\"‚úÖ {package} install√© avec succ√®s (mode utilisateur)\")\n            except subprocess.CalledProcessError as e2:\n                print(f\"‚ùå √âchec complet de l'installation de {package}\")\n                return False\n    \n    return True\n\ndef install_from_requirements():\n    \"\"\"\n    Installe directement depuis requirements.txt si disponible\n    \"\"\"\n    requirements_path = Path(__file__).parent.parent.parent / \"requirements.txt\"\n    \n    if requirements_path.exists():\n        print(\"üìã Installation depuis requirements.txt...\")\n        try:\n            subprocess.run([\n                sys.executable, \"-m\", \"pip\", \"install\", \"-r\", str(requirements_path), \"--quiet\"\n            ], check=True)\n            print(\"‚úÖ Installation depuis requirements.txt r√©ussie!\")\n            return True\n        except subprocess.CalledProcessError as e:\n            print(f\"‚ùå Erreur lors de l'installation depuis requirements.txt: {e}\")\n            return False\n    \n    return False\n\ndef ensure_pip_available():\n    \"\"\"\n    S'assure que pip est disponible\n    \"\"\"\n    try:\n        subprocess.run([sys.executable, \"-m\", \"pip\", \"--version\"], \n                      capture_output=True, check=True)\n        return True\n    except subprocess.CalledProcessError:\n        print(\"‚ùå pip n'est pas disponible. Tentative d'installation...\")\n        try:\n            subprocess.run([sys.executable, \"-m\", \"ensurepip\", \"--default-pip\"], \n                          capture_output=True, check=True)\n            print(\"‚úÖ pip install√© avec succ√®s!\")\n            return True\n        except subprocess.CalledProcessError:\n            print(\"‚ùå Impossible d'installer pip automatiquement\")\n            return False\n\ndef auto_install_dependencies():\n    \"\"\"\n    Point d'entr√©e principal pour l'auto-installation\n    \"\"\"\n    print(\"üöÄ RTPA Studio - Installation automatique des d√©pendances\")\n    print(\"=\" * 60)\n    \n    # V√©rification de pip\n    if not ensure_pip_available():\n        print(\"‚ùå pip n'est pas disponible. Installation manuelle requise.\")\n        return False\n    \n    # Tentative d'installation depuis requirements.txt d'abord\n    if install_from_requirements():\n        return True\n    \n    # Sinon, installation package par package\n    return check_and_install_dependencies()\n\nif __name__ == \"__main__\":\n    auto_install_dependencies()","size_bytes":5289},"launch_rtpa.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nLanceur principal pour RTPA Studio\nConfigur√© pour appara√Ætre comme une application ind√©pendante\n\"\"\"\n\nimport sys\nimport os\nimport subprocess\nfrom pathlib import Path\n\ndef main():\n    \"\"\"Lance RTPA Studio avec configuration Windows appropri√©e\"\"\"\n    \n    # Configuration du titre pour Windows\n    if sys.platform == \"win32\":\n        try:\n            import ctypes\n            # D√©finir le titre de la console\n            ctypes.windll.kernel32.SetConsoleTitleW(\"RTPA Studio\")\n            \n            # Configuration de l'ID d'application Windows\n            try:\n                app_id = \"RTPA.Studio.PokerAnalysis.1.0\"\n                ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(app_id)\n            except Exception:\n                pass\n        except ImportError:\n            pass\n    \n    # Changer le titre du processus si possible\n    try:\n        if hasattr(sys, 'ps1'):  # Mode interactif\n            sys.ps1 = \"RTPA Studio >>> \"\n    except:\n        pass\n    \n    # Lancer le programme principal\n    script_path = Path(__file__).parent / \"main_gui.py\"\n    \n    try:\n        # Ex√©cuter avec le bon titre\n        if sys.platform == \"win32\":\n            os.system(f'title RTPA Studio & python \"{script_path}\"')\n        else:\n            subprocess.run([sys.executable, str(script_path)])\n    except Exception as e:\n        print(f\"Erreur lors du lancement: {e}\")\n        # Fallback - lancement direct\n        import main_gui\n        main_gui.main()\n\nif __name__ == \"__main__\":\n    main()","size_bytes":1542}},"version":1}